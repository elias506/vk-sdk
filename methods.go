// Code generated by https://github.com/elias506/vk-sdk. DO NOT EDIT.

package vk_sdk

import (
	"context"
	"net/url"
)

type Account_Ban_Request struct {
	//  Format: int64
	OwnerId *int
}

func (r Account_Ban_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Account_Ban ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.ban
func (vk *VK) Account_Ban(ctx context.Context, req Account_Ban_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.ban", ctx, values, &resp)
	return
}

type Account_ChangePassword_Request struct {
	// Session id received after the [vk.com/dev/auth.restore|auth.restore] method is executed. (If the password is changed right after the access was restored)
	RestoreSid *string
	// Hash received after a successful OAuth authorization with a code got by SMS. (If the password is changed right after the access was restored)
	ChangePasswordHash *string
	// Current user password.
	OldPassword *string
	// New password that will be set as a current
	//  MinLength: 6
	NewPassword string
}

func (r Account_ChangePassword_Request) fillIn(values url.Values) (err error) {
	if r.RestoreSid != nil {
		setString(values, "restore_sid", *r.RestoreSid)
	}
	if r.ChangePasswordHash != nil {
		setString(values, "change_password_hash", *r.ChangePasswordHash)
	}
	if r.OldPassword != nil {
		setString(values, "old_password", *r.OldPassword)
	}
	setString(values, "new_password", r.NewPassword)
	return
}

// Account_ChangePassword Changes a user password after access is successfully restored with the [vk.com/dev/auth.restore|auth.restore] method.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.changePassword
func (vk *VK) Account_ChangePassword(ctx context.Context, req Account_ChangePassword_Request, options ...Option) (resp Account_ChangePassword_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.changePassword", ctx, values, &resp)
	return
}

type Account_GetActiveOffers_Request struct {
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of results to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r Account_GetActiveOffers_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Account_GetActiveOffers Returns a list of active ads (offers) which executed by the user will bring him/her respective number of votes to his balance in the application.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getActiveOffers
func (vk *VK) Account_GetActiveOffers(ctx context.Context, req Account_GetActiveOffers_Request, options ...Option) (resp Account_GetActiveOffers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getActiveOffers", ctx, values, &resp)
	return
}

type Account_GetAppPermissions_Request struct {
	// User ID whose settings information shall be got. By default: current user.
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Account_GetAppPermissions_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	return
}

// Account_GetAppPermissions Gets settings of the user in this application.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getAppPermissions
func (vk *VK) Account_GetAppPermissions(ctx context.Context, req Account_GetAppPermissions_Request, options ...Option) (resp Account_GetAppPermissions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getAppPermissions", ctx, values, &resp)
	return
}

type Account_GetBanned_Request struct {
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of results to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
}

func (r Account_GetBanned_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Account_GetBanned Returns a user's blacklist.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getBanned
func (vk *VK) Account_GetBanned(ctx context.Context, req Account_GetBanned_Request, options ...Option) (resp Account_GetBanned_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getBanned", ctx, values, &resp)
	return
}

type Account_GetCounters_Filter string

const (
	Account_GetCounters_Filter_Friends                Account_GetCounters_Filter = "friends"
	Account_GetCounters_Filter_Messages               Account_GetCounters_Filter = "messages"
	Account_GetCounters_Filter_Photos                 Account_GetCounters_Filter = "photos"
	Account_GetCounters_Filter_Notes                  Account_GetCounters_Filter = "notes"
	Account_GetCounters_Filter_Gifts                  Account_GetCounters_Filter = "gifts"
	Account_GetCounters_Filter_Events                 Account_GetCounters_Filter = "events"
	Account_GetCounters_Filter_Groups                 Account_GetCounters_Filter = "groups"
	Account_GetCounters_Filter_Sdk                    Account_GetCounters_Filter = "sdk"
	Account_GetCounters_Filter_FriendsSuggestions     Account_GetCounters_Filter = "friends_suggestions"
	Account_GetCounters_Filter_Notifications          Account_GetCounters_Filter = "notifications"
	Account_GetCounters_Filter_AppRequests            Account_GetCounters_Filter = "app_requests"
	Account_GetCounters_Filter_FriendsRecommendations Account_GetCounters_Filter = "friends_recommendations"
)

type Account_GetCounters_Request struct {
	Filter *[]Account_GetCounters_Filter
	// User ID
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Account_GetCounters_Request) fillIn(values url.Values) (err error) {
	if r.Filter != nil {
		vs := make([]string, len(*r.Filter))
		for i, v := range *r.Filter {
			vs[i] = string(v)
		}
		setStrings(values, "filter", vs)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Account_GetCounters Returns non-null values of user counters.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getCounters
func (vk *VK) Account_GetCounters(ctx context.Context, req Account_GetCounters_Request, options ...Option) (resp Account_GetCounters_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getCounters", ctx, values, &resp)
	return
}

type Account_GetInfo_Fields string

const (
	Account_GetInfo_Fields_Country         Account_GetInfo_Fields = "country"
	Account_GetInfo_Fields_HttpsRequired   Account_GetInfo_Fields = "https_required"
	Account_GetInfo_Fields_OwnPostsDefault Account_GetInfo_Fields = "own_posts_default"
	Account_GetInfo_Fields_NoWallReplies   Account_GetInfo_Fields = "no_wall_replies"
	Account_GetInfo_Fields_Intro           Account_GetInfo_Fields = "intro"
	Account_GetInfo_Fields_Lang            Account_GetInfo_Fields = "lang"
)

type Account_GetInfo_Request struct {
	Fields *[]Account_GetInfo_Fields
}

func (r Account_GetInfo_Request) fillIn(values url.Values) (err error) {
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Account_GetInfo Returns current account info.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getInfo
func (vk *VK) Account_GetInfo(ctx context.Context, req Account_GetInfo_Request, options ...Option) (resp Account_GetInfo_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getInfo", ctx, values, &resp)
	return
}

// Account_GetProfileInfo Returns the current account info.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getProfileInfo
func (vk *VK) Account_GetProfileInfo(ctx context.Context, options ...Option) (resp Account_GetProfileInfo_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getProfileInfo", ctx, values, &resp)
	return
}

type Account_GetPushSettings_Request struct {
	// Unique device ID.
	DeviceId *string
}

func (r Account_GetPushSettings_Request) fillIn(values url.Values) (err error) {
	if r.DeviceId != nil {
		setString(values, "device_id", *r.DeviceId)
	}
	return
}

// Account_GetPushSettings Gets settings of push notifications.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.getPushSettings
func (vk *VK) Account_GetPushSettings(ctx context.Context, req Account_GetPushSettings_Request, options ...Option) (resp Account_GetPushSettings_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.getPushSettings", ctx, values, &resp)
	return
}

type Account_RegisterDevice_Request struct {
	// Device token used to send notifications. (for mpns, the token shall be URL for sending of notifications)
	Token string
	// String name of device model.
	DeviceModel *string
	// Device year.
	DeviceYear *int
	// Unique device ID.
	DeviceId string
	// String version of device operating system.
	SystemVersion *string
	// Push settings in a [vk.com/dev/push_settings|special format].
	Settings *string
	//  Default: 0
	Sandbox *bool
}

func (r Account_RegisterDevice_Request) fillIn(values url.Values) (err error) {
	setString(values, "token", r.Token)
	if r.DeviceModel != nil {
		setString(values, "device_model", *r.DeviceModel)
	}
	if r.DeviceYear != nil {
		setInt(values, "device_year", *r.DeviceYear)
	}
	setString(values, "device_id", r.DeviceId)
	if r.SystemVersion != nil {
		setString(values, "system_version", *r.SystemVersion)
	}
	if r.Settings != nil {
		setString(values, "settings", *r.Settings)
	}
	if r.Sandbox != nil {
		setBool(values, "sandbox", *r.Sandbox)
	}
	return
}

// Account_RegisterDevice Subscribes an iOS/Android/Windows Phone-based device to receive push notifications
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.registerDevice
func (vk *VK) Account_RegisterDevice(ctx context.Context, req Account_RegisterDevice_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.registerDevice", ctx, values, &resp)
	return
}

type Account_SaveProfileInfo_Sex int

const (
	Account_SaveProfileInfo_Sex_Undefined Account_SaveProfileInfo_Sex = 0
	Account_SaveProfileInfo_Sex_Female    Account_SaveProfileInfo_Sex = 1
	Account_SaveProfileInfo_Sex_Male      Account_SaveProfileInfo_Sex = 2
)

type Account_SaveProfileInfo_Relation int

const (
	Account_SaveProfileInfo_Relation_Single            Account_SaveProfileInfo_Relation = 1
	Account_SaveProfileInfo_Relation_Relationship      Account_SaveProfileInfo_Relation = 2
	Account_SaveProfileInfo_Relation_Engaged           Account_SaveProfileInfo_Relation = 3
	Account_SaveProfileInfo_Relation_Married           Account_SaveProfileInfo_Relation = 4
	Account_SaveProfileInfo_Relation_Complicated       Account_SaveProfileInfo_Relation = 5
	Account_SaveProfileInfo_Relation_ActivelySearching Account_SaveProfileInfo_Relation = 6
	Account_SaveProfileInfo_Relation_InLove            Account_SaveProfileInfo_Relation = 7
	Account_SaveProfileInfo_Relation_NotSpecified      Account_SaveProfileInfo_Relation = 0
)

type Account_SaveProfileInfo_BdateVisibility int

const (
	Account_SaveProfileInfo_BdateVisibility_Show     Account_SaveProfileInfo_BdateVisibility = 1
	Account_SaveProfileInfo_BdateVisibility_HideYear Account_SaveProfileInfo_BdateVisibility = 2
	Account_SaveProfileInfo_BdateVisibility_Hide     Account_SaveProfileInfo_BdateVisibility = 0
)

type Account_SaveProfileInfo_Request struct {
	// User first name.
	FirstName *string
	// User last name.
	LastName *string
	// User maiden name (female only)
	MaidenName *string
	// User screen name.
	ScreenName *string
	// ID of the name change request to be canceled. If this parameter is sent, all the others are ignored.
	//  Minimum: 0
	CancelRequestId *int
	// User sex. Possible values: , * '1' - female,, * '2' - male.
	//  Minimum: 0
	Sex *Account_SaveProfileInfo_Sex
	// User relationship status. Possible values: , * '1' - single,, * '2' - in a relationship,, * '3' - engaged,, * '4' - married,, * '5' - it's complicated,, * '6' - actively searching,, * '7' - in love,, * '0' - not specified.
	//  Minimum: 0
	Relation *Account_SaveProfileInfo_Relation
	// ID of the relationship partner.
	//  Format: int64
	//  Minimum: 0
	RelationPartnerId *int
	// User birth date, format: DD.MM.YYYY.
	Bdate *string
	// Birth date visibility. Returned values: , * '1' - show birth date,, * '2' - show only month and day,, * '0' - hide birth date.
	//  Minimum: 0
	BdateVisibility *Account_SaveProfileInfo_BdateVisibility
	// User home town.
	HomeTown *string
	// User country.
	//  Minimum: 0
	CountryId *int
	// User city.
	//  Minimum: 0
	CityId *int
	// Status text.
	Status *string
}

func (r Account_SaveProfileInfo_Request) fillIn(values url.Values) (err error) {
	if r.FirstName != nil {
		setString(values, "first_name", *r.FirstName)
	}
	if r.LastName != nil {
		setString(values, "last_name", *r.LastName)
	}
	if r.MaidenName != nil {
		setString(values, "maiden_name", *r.MaidenName)
	}
	if r.ScreenName != nil {
		setString(values, "screen_name", *r.ScreenName)
	}
	if r.CancelRequestId != nil {
		setInt(values, "cancel_request_id", *r.CancelRequestId)
	}
	if r.Sex != nil {
		setInt(values, "sex", int(*r.Sex))
	}
	if r.Relation != nil {
		setInt(values, "relation", int(*r.Relation))
	}
	if r.RelationPartnerId != nil {
		setInt(values, "relation_partner_id", *r.RelationPartnerId)
	}
	if r.Bdate != nil {
		setString(values, "bdate", *r.Bdate)
	}
	if r.BdateVisibility != nil {
		setInt(values, "bdate_visibility", int(*r.BdateVisibility))
	}
	if r.HomeTown != nil {
		setString(values, "home_town", *r.HomeTown)
	}
	if r.CountryId != nil {
		setInt(values, "country_id", *r.CountryId)
	}
	if r.CityId != nil {
		setInt(values, "city_id", *r.CityId)
	}
	if r.Status != nil {
		setString(values, "status", *r.Status)
	}
	return
}

// Account_SaveProfileInfo Edits current profile info.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_InvalidAddress ]
//
// https://dev.vk.com/method/account.saveProfileInfo
func (vk *VK) Account_SaveProfileInfo(ctx context.Context, req Account_SaveProfileInfo_Request, options ...Option) (resp Account_SaveProfileInfo_Response, apiErr ApiError, err error) {
	values := make(url.Values, 16+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.saveProfileInfo", ctx, values, &resp)
	return
}

type Account_SetInfo_Name string

const (
	Account_SetInfo_Name_Intro           Account_SetInfo_Name = "intro"
	Account_SetInfo_Name_NoWallReplies   Account_SetInfo_Name = "no_wall_replies"
	Account_SetInfo_Name_OwnPostsDefault Account_SetInfo_Name = "own_posts_default"
)

type Account_SetInfo_Request struct {
	// Setting name.
	Name *Account_SetInfo_Name
	// Setting value.
	Value *string
}

func (r Account_SetInfo_Request) fillIn(values url.Values) (err error) {
	if r.Name != nil {
		setString(values, "name", string(*r.Name))
	}
	if r.Value != nil {
		setString(values, "value", *r.Value)
	}
	return
}

// Account_SetInfo Allows to edit the current account info.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.setInfo
func (vk *VK) Account_SetInfo(ctx context.Context, req Account_SetInfo_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.setInfo", ctx, values, &resp)
	return
}

// Account_SetOffline Marks a current user as offline.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.setOffline
func (vk *VK) Account_SetOffline(ctx context.Context, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("account.setOffline", ctx, values, &resp)
	return
}

type Account_SetOnline_Request struct {
	// '1' if videocalls are available for current device.
	Voip *bool
}

func (r Account_SetOnline_Request) fillIn(values url.Values) (err error) {
	if r.Voip != nil {
		setBool(values, "voip", *r.Voip)
	}
	return
}

// Account_SetOnline Marks the current user as online for 15 minutes.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.setOnline
func (vk *VK) Account_SetOnline(ctx context.Context, req Account_SetOnline_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.setOnline", ctx, values, &resp)
	return
}

type Account_SetPushSettings_Request struct {
	// Unique device ID.
	DeviceId string
	// Push settings in a [vk.com/dev/push_settings|special format].
	Settings *string
	// Notification key.
	Key   *string
	Value *[]string
}

func (r Account_SetPushSettings_Request) fillIn(values url.Values) (err error) {
	setString(values, "device_id", r.DeviceId)
	if r.Settings != nil {
		setString(values, "settings", *r.Settings)
	}
	if r.Key != nil {
		setString(values, "key", *r.Key)
	}
	if r.Value != nil {
		setStrings(values, "value", *r.Value)
	}
	return
}

// Account_SetPushSettings Change push settings.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.setPushSettings
func (vk *VK) Account_SetPushSettings(ctx context.Context, req Account_SetPushSettings_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.setPushSettings", ctx, values, &resp)
	return
}

type Account_SetSilenceMode_Request struct {
	// Unique device ID.
	DeviceId *string
	// Time in seconds for what notifications should be disabled. '-1' to disable forever.
	Time *int
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	PeerId *int
	// '1' — to enable sound in this dialog, '0' — to disable sound. Only if 'peer_id' contains user or community ID.
	Sound *int
}

func (r Account_SetSilenceMode_Request) fillIn(values url.Values) (err error) {
	if r.DeviceId != nil {
		setString(values, "device_id", *r.DeviceId)
	}
	if r.Time != nil {
		setInt(values, "time", *r.Time)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.Sound != nil {
		setInt(values, "sound", *r.Sound)
	}
	return
}

// Account_SetSilenceMode Mutes push notifications for the set period of time.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.setSilenceMode
func (vk *VK) Account_SetSilenceMode(ctx context.Context, req Account_SetSilenceMode_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.setSilenceMode", ctx, values, &resp)
	return
}

type Account_Unban_Request struct {
	//  Format: int64
	OwnerId *int
}

func (r Account_Unban_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Account_Unban ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.unban
func (vk *VK) Account_Unban(ctx context.Context, req Account_Unban_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.unban", ctx, values, &resp)
	return
}

type Account_UnregisterDevice_Request struct {
	// Unique device ID.
	DeviceId *string
	//  Default: 0
	Sandbox *bool
}

func (r Account_UnregisterDevice_Request) fillIn(values url.Values) (err error) {
	if r.DeviceId != nil {
		setString(values, "device_id", *r.DeviceId)
	}
	if r.Sandbox != nil {
		setBool(values, "sandbox", *r.Sandbox)
	}
	return
}

// Account_UnregisterDevice Unsubscribes a device from push notifications.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/account.unregisterDevice
func (vk *VK) Account_UnregisterDevice(ctx context.Context, req Account_UnregisterDevice_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("account.unregisterDevice", ctx, values, &resp)
	return
}

type Ads_AddOfficeUsers_Request struct {
	// Advertising account ID.
	AccountId int
	//  Format: json
	//  MinItems: 1
	//  MaxItems: 10
	Data *[]Ads_UserSpecificationCutted
}

func (r Ads_AddOfficeUsers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.Data != nil {
		if err = setJSON(values, "data", *r.Data); err != nil {
			return
		}
	}
	return
}

// Ads_AddOfficeUsers Adds managers and/or supervisors to advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.addOfficeUsers
func (vk *VK) Ads_AddOfficeUsers(ctx context.Context, req Ads_AddOfficeUsers_Request, options ...Option) (resp Ads_AddOfficeUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.addOfficeUsers", ctx, values, &resp)
	return
}

type Ads_CheckLink_LinkType string

const (
	Ads_CheckLink_LinkType_Community   Ads_CheckLink_LinkType = "community"
	Ads_CheckLink_LinkType_Post        Ads_CheckLink_LinkType = "post"
	Ads_CheckLink_LinkType_Application Ads_CheckLink_LinkType = "application"
	Ads_CheckLink_LinkType_Video       Ads_CheckLink_LinkType = "video"
	Ads_CheckLink_LinkType_Site        Ads_CheckLink_LinkType = "site"
)

type Ads_CheckLink_Request struct {
	// Advertising account ID.
	AccountId int
	// Object type: *'community' — community,, *'post' — community post,, *'application' — VK application,, *'video' — video,, *'site' — external site.
	LinkType Ads_CheckLink_LinkType
	// Object URL.
	LinkUrl string
	// Campaign ID
	CampaignId *int
}

func (r Ads_CheckLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "link_type", string(r.LinkType))
	setString(values, "link_url", r.LinkUrl)
	if r.CampaignId != nil {
		setInt(values, "campaign_id", *r.CampaignId)
	}
	return
}

// Ads_CheckLink Allows to check the ad link.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.checkLink
func (vk *VK) Ads_CheckLink(ctx context.Context, req Ads_CheckLink_Request, options ...Option) (resp Ads_CheckLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.checkLink", ctx, values, &resp)
	return
}

type Ads_CreateAds_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe created ads. Description of 'ad_specification' objects see below.
	Data string
}

func (r Ads_CreateAds_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_CreateAds Creates ads.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.createAds
func (vk *VK) Ads_CreateAds(ctx context.Context, req Ads_CreateAds_Request, options ...Option) (resp Ads_CreateAds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.createAds", ctx, values, &resp)
	return
}

type Ads_CreateCampaigns_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe created campaigns. Description of 'campaign_specification' objects see below.
	Data string
}

func (r Ads_CreateCampaigns_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_CreateCampaigns Creates advertising campaigns.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.createCampaigns
func (vk *VK) Ads_CreateCampaigns(ctx context.Context, req Ads_CreateCampaigns_Request, options ...Option) (resp Ads_CreateCampaigns_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.createCampaigns", ctx, values, &resp)
	return
}

type Ads_CreateClients_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe created campaigns. Description of 'client_specification' objects see below.
	Data string
}

func (r Ads_CreateClients_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_CreateClients Creates clients of an advertising agency.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.createClients
func (vk *VK) Ads_CreateClients(ctx context.Context, req Ads_CreateClients_Request, options ...Option) (resp Ads_CreateClients_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.createClients", ctx, values, &resp)
	return
}

type Ads_CreateTargetGroup_Request struct {
	// Advertising account ID.
	AccountId int
	// 'Only for advertising agencies.', ID of the client with the advertising account where the group will be created.
	ClientId *int
	// Name of the target group — a string up to 64 characters long.
	Name string
	// 'For groups with auditory created with pixel code only.', , Number of days after that users will be automatically removed from the group.
	//  Minimum: 1
	//  Maximum: 720
	Lifetime         int
	TargetPixelId    *int
	TargetPixelRules *string
}

func (r Ads_CreateTargetGroup_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	setString(values, "name", r.Name)
	setInt(values, "lifetime", r.Lifetime)
	if r.TargetPixelId != nil {
		setInt(values, "target_pixel_id", *r.TargetPixelId)
	}
	if r.TargetPixelRules != nil {
		setString(values, "target_pixel_rules", *r.TargetPixelRules)
	}
	return
}

// Ads_CreateTargetGroup Creates a group to re-target ads for users who visited advertiser's site (viewed information about the product, registered, etc.).
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.createTargetGroup
func (vk *VK) Ads_CreateTargetGroup(ctx context.Context, req Ads_CreateTargetGroup_Request, options ...Option) (resp Ads_CreateTargetGroup_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.createTargetGroup", ctx, values, &resp)
	return
}

type Ads_DeleteAds_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array with ad IDs.
	Ids string
}

func (r Ads_DeleteAds_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids", r.Ids)
	return
}

// Ads_DeleteAds Archives ads.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsObjectDeleted, Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.deleteAds
func (vk *VK) Ads_DeleteAds(ctx context.Context, req Ads_DeleteAds_Request, options ...Option) (resp Ads_DeleteAds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.deleteAds", ctx, values, &resp)
	return
}

type Ads_DeleteCampaigns_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array with IDs of deleted campaigns.
	Ids string
}

func (r Ads_DeleteCampaigns_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids", r.Ids)
	return
}

// Ads_DeleteCampaigns Archives advertising campaigns.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsObjectDeleted, Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.deleteCampaigns
func (vk *VK) Ads_DeleteCampaigns(ctx context.Context, req Ads_DeleteCampaigns_Request, options ...Option) (resp Ads_DeleteCampaigns_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.deleteCampaigns", ctx, values, &resp)
	return
}

type Ads_DeleteClients_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array with IDs of deleted clients.
	Ids string
}

func (r Ads_DeleteClients_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids", r.Ids)
	return
}

// Ads_DeleteClients Archives clients of an advertising agency.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsObjectDeleted, Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.deleteClients
func (vk *VK) Ads_DeleteClients(ctx context.Context, req Ads_DeleteClients_Request, options ...Option) (resp Ads_DeleteClients_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.deleteClients", ctx, values, &resp)
	return
}

type Ads_DeleteTargetGroup_Request struct {
	// Advertising account ID.
	AccountId int
	// 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	ClientId *int
	// Group ID.
	TargetGroupId int
}

func (r Ads_DeleteTargetGroup_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	setInt(values, "target_group_id", r.TargetGroupId)
	return
}

// Ads_DeleteTargetGroup Deletes a retarget group.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.deleteTargetGroup
func (vk *VK) Ads_DeleteTargetGroup(ctx context.Context, req Ads_DeleteTargetGroup_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.deleteTargetGroup", ctx, values, &resp)
	return
}

// Ads_GetAccounts Returns a list of advertising accounts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getAccounts
func (vk *VK) Ads_GetAccounts(ctx context.Context, options ...Option) (resp Ads_GetAccounts_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getAccounts", ctx, values, &resp)
	return
}

type Ads_GetAds_Request struct {
	// Advertising account ID.
	AccountId int
	// Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	AdIds *string
	// Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	CampaignIds *string
	// 'Available and required for advertising agencies.' ID of the client ads are retrieved from.
	ClientId *int
	// Flag that specifies whether archived ads shall be shown: *0 — show only active ads,, *1 — show all ads.
	IncludeDeleted *bool
	// Flag that specifies whether to show only archived ads: *0 — show all ads,, *1 — show only archived ads. Available when include_deleted flag is *1
	OnlyDeleted *bool
	// Limit of number of returned ads. Used only if ad_ids parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Limit *int
	// Offset. Used in the same cases as 'limit' parameter.
	Offset *int
}

func (r Ads_GetAds_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.AdIds != nil {
		setString(values, "ad_ids", *r.AdIds)
	}
	if r.CampaignIds != nil {
		setString(values, "campaign_ids", *r.CampaignIds)
	}
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.IncludeDeleted != nil {
		setBool(values, "include_deleted", *r.IncludeDeleted)
	}
	if r.OnlyDeleted != nil {
		setBool(values, "only_deleted", *r.OnlyDeleted)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Ads_GetAds Returns number of ads.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getAds
func (vk *VK) Ads_GetAds(ctx context.Context, req Ads_GetAds_Request, options ...Option) (resp Ads_GetAds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getAds", ctx, values, &resp)
	return
}

type Ads_GetAdsLayout_Request struct {
	// Advertising account ID.
	AccountId int
	// 'For advertising agencies.' ID of the client ads are retrieved from.
	ClientId *int
	// Flag that specifies whether archived ads shall be shown. *0 — show only active ads,, *1 — show all ads.
	IncludeDeleted *bool
	// Flag that specifies whether to show only archived ads: *0 — show all ads,, *1 — show only archived ads. Available when include_deleted flag is *1
	OnlyDeleted *bool
	// Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	CampaignIds *string
	// Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	AdIds *string
	// Limit of number of returned ads. Used only if 'ad_ids' parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Limit *int
	// Offset. Used in the same cases as 'limit' parameter.
	Offset *int
}

func (r Ads_GetAdsLayout_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.IncludeDeleted != nil {
		setBool(values, "include_deleted", *r.IncludeDeleted)
	}
	if r.OnlyDeleted != nil {
		setBool(values, "only_deleted", *r.OnlyDeleted)
	}
	if r.CampaignIds != nil {
		setString(values, "campaign_ids", *r.CampaignIds)
	}
	if r.AdIds != nil {
		setString(values, "ad_ids", *r.AdIds)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Ads_GetAdsLayout Returns descriptions of ad layouts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getAdsLayout
func (vk *VK) Ads_GetAdsLayout(ctx context.Context, req Ads_GetAdsLayout_Request, options ...Option) (resp Ads_GetAdsLayout_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getAdsLayout", ctx, values, &resp)
	return
}

type Ads_GetAdsTargeting_Request struct {
	// Advertising account ID.
	AccountId int
	// Filter by ads. Serialized JSON array with ad IDs. If the parameter is null, all ads will be shown.
	AdIds *string
	// Filter by advertising campaigns. Serialized JSON array with campaign IDs. If the parameter is null, ads of all campaigns will be shown.
	CampaignIds *string
	// 'For advertising agencies.' ID of the client ads are retrieved from.
	ClientId *int
	// flag that specifies whether archived ads shall be shown: *0 — show only active ads,, *1 — show all ads.
	IncludeDeleted *bool
	// Limit of number of returned ads. Used only if 'ad_ids' parameter is null, and 'campaign_ids' parameter contains ID of only one campaign.
	Limit *int
	// Offset needed to return a specific subset of results.
	Offset *int
}

func (r Ads_GetAdsTargeting_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.AdIds != nil {
		setString(values, "ad_ids", *r.AdIds)
	}
	if r.CampaignIds != nil {
		setString(values, "campaign_ids", *r.CampaignIds)
	}
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.IncludeDeleted != nil {
		setBool(values, "include_deleted", *r.IncludeDeleted)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Ads_GetAdsTargeting Returns ad targeting parameters.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getAdsTargeting
func (vk *VK) Ads_GetAdsTargeting(ctx context.Context, req Ads_GetAdsTargeting_Request, options ...Option) (resp Ads_GetAdsTargeting_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getAdsTargeting", ctx, values, &resp)
	return
}

type Ads_GetBudget_Request struct {
	// Advertising account ID.
	AccountId int
}

func (r Ads_GetBudget_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	return
}

// Ads_GetBudget Returns current budget of the advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getBudget
func (vk *VK) Ads_GetBudget(ctx context.Context, req Ads_GetBudget_Request, options ...Option) (resp Ads_GetBudget_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getBudget", ctx, values, &resp)
	return
}

type Ads_GetCampaigns_Fields string

const (
	Ads_GetCampaigns_Fields_AdsCount Ads_GetCampaigns_Fields = "ads_count"
)

type Ads_GetCampaigns_Request struct {
	// Advertising account ID.
	AccountId int
	// 'For advertising agencies'. ID of the client advertising campaigns are retrieved from.
	ClientId *int
	// Flag that specifies whether archived ads shall be shown. *0 — show only active campaigns,, *1 — show all campaigns.
	IncludeDeleted *bool
	// Filter of advertising campaigns to show. Serialized JSON array with campaign IDs. Only campaigns that exist in 'campaign_ids' and belong to the specified advertising account will be shown. If the parameter is null, all campaigns will be shown.
	CampaignIds *string
	Fields      *[]Ads_GetCampaigns_Fields
}

func (r Ads_GetCampaigns_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.IncludeDeleted != nil {
		setBool(values, "include_deleted", *r.IncludeDeleted)
	}
	if r.CampaignIds != nil {
		setString(values, "campaign_ids", *r.CampaignIds)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Ads_GetCampaigns Returns a list of campaigns in an advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getCampaigns
func (vk *VK) Ads_GetCampaigns(ctx context.Context, req Ads_GetCampaigns_Request, options ...Option) (resp Ads_GetCampaigns_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getCampaigns", ctx, values, &resp)
	return
}

type Ads_GetCategories_Request struct {
	// Language. The full list of supported languages is [vk.com/dev/api_requests|here].
	Lang *string
}

func (r Ads_GetCategories_Request) fillIn(values url.Values) (err error) {
	if r.Lang != nil {
		setString(values, "lang", *r.Lang)
	}
	return
}

// Ads_GetCategories Returns a list of possible ad categories.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getCategories
func (vk *VK) Ads_GetCategories(ctx context.Context, req Ads_GetCategories_Request, options ...Option) (resp Ads_GetCategories_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getCategories", ctx, values, &resp)
	return
}

type Ads_GetClients_Request struct {
	// Advertising account ID.
	AccountId int
}

func (r Ads_GetClients_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	return
}

// Ads_GetClients Returns a list of advertising agency's clients.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getClients
func (vk *VK) Ads_GetClients(ctx context.Context, req Ads_GetClients_Request, options ...Option) (resp Ads_GetClients_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getClients", ctx, values, &resp)
	return
}

type Ads_GetDemographics_IdsType string

const (
	Ads_GetDemographics_IdsType_Ad       Ads_GetDemographics_IdsType = "ad"
	Ads_GetDemographics_IdsType_Campaign Ads_GetDemographics_IdsType = "campaign"
)

type Ads_GetDemographics_Period string

const (
	Ads_GetDemographics_Period_Day     Ads_GetDemographics_Period = "day"
	Ads_GetDemographics_Period_Month   Ads_GetDemographics_Period = "month"
	Ads_GetDemographics_Period_Overall Ads_GetDemographics_Period = "overall"
)

type Ads_GetDemographics_Request struct {
	// Advertising account ID.
	AccountId int
	// Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns.
	IdsType Ads_GetDemographics_IdsType
	// IDs requested ads or campaigns, separated with a comma, depending on the value set in 'ids_type'. Maximum 2000 objects.
	Ids string
	// Data grouping by dates: *day — statistics by days,, *month — statistics by months,, *overall — overall statistics. 'date_from' and 'date_to' parameters set temporary limits.
	Period Ads_GetDemographics_Period
	// Date to show statistics from. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — day it was created on,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — month it was created in,, *overall: 0.
	DateFrom string
	// Date to show statistics to. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — current day,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — current month,, *overall: 0.
	DateTo string
}

func (r Ads_GetDemographics_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids_type", string(r.IdsType))
	setString(values, "ids", r.Ids)
	setString(values, "period", string(r.Period))
	setString(values, "date_from", r.DateFrom)
	setString(values, "date_to", r.DateTo)
	return
}

// Ads_GetDemographics Returns demographics for ads or campaigns.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getDemographics
func (vk *VK) Ads_GetDemographics(ctx context.Context, req Ads_GetDemographics_Request, options ...Option) (resp Ads_GetDemographics_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getDemographics", ctx, values, &resp)
	return
}

type Ads_GetFloodStats_Request struct {
	// Advertising account ID.
	AccountId int
}

func (r Ads_GetFloodStats_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	return
}

// Ads_GetFloodStats Returns information about current state of a counter — number of remaining runs of methods and time to the next counter nulling in seconds.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getFloodStats
func (vk *VK) Ads_GetFloodStats(ctx context.Context, req Ads_GetFloodStats_Request, options ...Option) (resp Ads_GetFloodStats_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getFloodStats", ctx, values, &resp)
	return
}

type Ads_GetLookalikeRequests_Request struct {
	AccountId   int
	ClientId    *int
	RequestsIds *string
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 200
	Limit *int
	//  Default: id
	SortBy *string
}

func (r Ads_GetLookalikeRequests_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.RequestsIds != nil {
		setString(values, "requests_ids", *r.RequestsIds)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.SortBy != nil {
		setString(values, "sort_by", *r.SortBy)
	}
	return
}

// Ads_GetLookalikeRequests ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getLookalikeRequests
func (vk *VK) Ads_GetLookalikeRequests(ctx context.Context, req Ads_GetLookalikeRequests_Request, options ...Option) (resp Ads_GetLookalikeRequests_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getLookalikeRequests", ctx, values, &resp)
	return
}

type Ads_GetMusicians_Request struct {
	//  MinLength: 3
	ArtistName string
}

func (r Ads_GetMusicians_Request) fillIn(values url.Values) (err error) {
	setString(values, "artist_name", r.ArtistName)
	return
}

// Ads_GetMusicians ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood, Error_NotFound ]
//
// https://dev.vk.com/method/ads.getMusicians
func (vk *VK) Ads_GetMusicians(ctx context.Context, req Ads_GetMusicians_Request, options ...Option) (resp Ads_GetMusicians_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getMusicians", ctx, values, &resp)
	return
}

type Ads_GetMusiciansByIds_Request struct {
	//  MaxItems: 200
	//  Minimum: 0
	Ids *[]int
}

func (r Ads_GetMusiciansByIds_Request) fillIn(values url.Values) (err error) {
	if r.Ids != nil {
		setInts(values, "ids", *r.Ids)
	}
	return
}

// Ads_GetMusiciansByIds ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getMusiciansByIds
func (vk *VK) Ads_GetMusiciansByIds(ctx context.Context, req Ads_GetMusiciansByIds_Request, options ...Option) (resp Ads_GetMusicians_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getMusiciansByIds", ctx, values, &resp)
	return
}

type Ads_GetOfficeUsers_Request struct {
	// Advertising account ID.
	AccountId int
}

func (r Ads_GetOfficeUsers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	return
}

// Ads_GetOfficeUsers Returns a list of managers and supervisors of advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getOfficeUsers
func (vk *VK) Ads_GetOfficeUsers(ctx context.Context, req Ads_GetOfficeUsers_Request, options ...Option) (resp Ads_GetOfficeUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getOfficeUsers", ctx, values, &resp)
	return
}

type Ads_GetPostsReach_IdsType string

const (
	Ads_GetPostsReach_IdsType_Ad       Ads_GetPostsReach_IdsType = "ad"
	Ads_GetPostsReach_IdsType_Campaign Ads_GetPostsReach_IdsType = "campaign"
)

type Ads_GetPostsReach_Request struct {
	// Advertising account ID.
	AccountId int
	// Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns.
	IdsType Ads_GetPostsReach_IdsType
	// IDs requested ads or campaigns, separated with a comma, depending on the value set in 'ids_type'. Maximum 100 objects.
	Ids string
}

func (r Ads_GetPostsReach_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids_type", string(r.IdsType))
	setString(values, "ids", r.Ids)
	return
}

// Ads_GetPostsReach Returns detailed statistics of promoted posts reach from campaigns and ads.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getPostsReach
func (vk *VK) Ads_GetPostsReach(ctx context.Context, req Ads_GetPostsReach_Request, options ...Option) (resp Ads_GetPostsReach_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getPostsReach", ctx, values, &resp)
	return
}

type Ads_GetRejectionReason_Request struct {
	// Advertising account ID.
	AccountId int
	// Ad ID.
	AdId int
}

func (r Ads_GetRejectionReason_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setInt(values, "ad_id", r.AdId)
	return
}

// Ads_GetRejectionReason Returns a reason of ad rejection for pre-moderation.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getRejectionReason
func (vk *VK) Ads_GetRejectionReason(ctx context.Context, req Ads_GetRejectionReason_Request, options ...Option) (resp Ads_GetRejectionReason_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getRejectionReason", ctx, values, &resp)
	return
}

type Ads_GetStatistics_IdsType string

const (
	Ads_GetStatistics_IdsType_Ad       Ads_GetStatistics_IdsType = "ad"
	Ads_GetStatistics_IdsType_Campaign Ads_GetStatistics_IdsType = "campaign"
	Ads_GetStatistics_IdsType_Client   Ads_GetStatistics_IdsType = "client"
	Ads_GetStatistics_IdsType_Office   Ads_GetStatistics_IdsType = "office"
)

type Ads_GetStatistics_Period string

const (
	Ads_GetStatistics_Period_Day     Ads_GetStatistics_Period = "day"
	Ads_GetStatistics_Period_Month   Ads_GetStatistics_Period = "month"
	Ads_GetStatistics_Period_Overall Ads_GetStatistics_Period = "overall"
)

type Ads_GetStatistics_StatsFields string

const (
	Ads_GetStatistics_StatsFields_ViewsTimes Ads_GetStatistics_StatsFields = "views_times"
)

type Ads_GetStatistics_Request struct {
	// Advertising account ID.
	AccountId int
	// Type of requested objects listed in 'ids' parameter: *ad — ads,, *campaign — campaigns,, *client — clients,, *office — account.
	IdsType Ads_GetStatistics_IdsType
	// IDs requested ads, campaigns, clients or account, separated with a comma, depending on the value set in 'ids_type'. Maximum 2000 objects.
	Ids string
	// Data grouping by dates: *day — statistics by days,, *month — statistics by months,, *overall — overall statistics. 'date_from' and 'date_to' parameters set temporary limits.
	Period Ads_GetStatistics_Period
	// Date to show statistics from. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — day it was created on,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — month it was created in,, *overall: 0.
	DateFrom string
	// Date to show statistics to. For different value of 'period' different date format is used: *day: YYYY-MM-DD, example: 2011-09-27 — September 27, 2011, **0 — current day,, *month: YYYY-MM, example: 2011-09 — September 2011, **0 — current month,, *overall: 0.
	DateTo      string
	StatsFields *[]Ads_GetStatistics_StatsFields
}

func (r Ads_GetStatistics_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids_type", string(r.IdsType))
	setString(values, "ids", r.Ids)
	setString(values, "period", string(r.Period))
	setString(values, "date_from", r.DateFrom)
	setString(values, "date_to", r.DateTo)
	if r.StatsFields != nil {
		vs := make([]string, len(*r.StatsFields))
		for i, v := range *r.StatsFields {
			vs[i] = string(v)
		}
		setStrings(values, "stats_fields", vs)
	}
	return
}

// Ads_GetStatistics Returns statistics of performance indicators for ads, campaigns, clients or the whole account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getStatistics
func (vk *VK) Ads_GetStatistics(ctx context.Context, req Ads_GetStatistics_Request, options ...Option) (resp Ads_GetStatistics_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getStatistics", ctx, values, &resp)
	return
}

type Ads_GetSuggestions_Section string

const (
	Ads_GetSuggestions_Section_Countries  Ads_GetSuggestions_Section = "countries"
	Ads_GetSuggestions_Section_Regions    Ads_GetSuggestions_Section = "regions"
	Ads_GetSuggestions_Section_Cities     Ads_GetSuggestions_Section = "cities"
	Ads_GetSuggestions_Section_Districts  Ads_GetSuggestions_Section = "districts"
	Ads_GetSuggestions_Section_Stations   Ads_GetSuggestions_Section = "stations"
	Ads_GetSuggestions_Section_Streets    Ads_GetSuggestions_Section = "streets"
	Ads_GetSuggestions_Section_Schools    Ads_GetSuggestions_Section = "schools"
	Ads_GetSuggestions_Section_Interests  Ads_GetSuggestions_Section = "interests"
	Ads_GetSuggestions_Section_Positions  Ads_GetSuggestions_Section = "positions"
	Ads_GetSuggestions_Section_GroupTypes Ads_GetSuggestions_Section = "group_types"
	Ads_GetSuggestions_Section_Religions  Ads_GetSuggestions_Section = "religions"
	Ads_GetSuggestions_Section_Browsers   Ads_GetSuggestions_Section = "browsers"
)

type Ads_GetSuggestions_Lang string

const (
	Ads_GetSuggestions_Lang_Russian   Ads_GetSuggestions_Lang = "ru"
	Ads_GetSuggestions_Lang_Ukrainian Ads_GetSuggestions_Lang = "ua"
	Ads_GetSuggestions_Lang_English   Ads_GetSuggestions_Lang = "en"
)

type Ads_GetSuggestions_Request struct {
	// Section, suggestions are retrieved in. Available values: *countries — request of a list of countries. If q is not set or blank, a short list of countries is shown. Otherwise, a full list of countries is shown. *regions — requested list of regions. 'country' parameter is required. *cities — requested list of cities. 'country' parameter is required. *districts — requested list of districts. 'cities' parameter is required. *stations — requested list of subway stations. 'cities' parameter is required. *streets — requested list of streets. 'cities' parameter is required. *schools — requested list of educational organizations. 'cities' parameter is required. *interests — requested list of interests. *positions — requested list of positions (professions). *group_types — requested list of group types. *religions — requested list of religious commitments. *browsers — requested list of browsers and mobile devices.
	Section Ads_GetSuggestions_Section
	// Objects IDs separated by commas. If the parameter is passed, 'q, country, cities' should not be passed.
	Ids *string
	// Filter-line of the request (for countries, regions, cities, streets, schools, interests, positions).
	Q *string
	// ID of the country objects are searched in.
	Country *int
	// IDs of cities where objects are searched in, separated with a comma.
	Cities *string
	// Language of the returned string values. Supported languages: *ru — Russian,, *ua — Ukrainian,, *en — English.
	Lang *Ads_GetSuggestions_Lang
}

func (r Ads_GetSuggestions_Request) fillIn(values url.Values) (err error) {
	setString(values, "section", string(r.Section))
	if r.Ids != nil {
		setString(values, "ids", *r.Ids)
	}
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Country != nil {
		setInt(values, "country", *r.Country)
	}
	if r.Cities != nil {
		setString(values, "cities", *r.Cities)
	}
	if r.Lang != nil {
		setString(values, "lang", string(*r.Lang))
	}
	return
}

// Ads_GetSuggestions Returns a set of auto-suggestions for various targeting parameters.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getSuggestions
func (vk *VK) Ads_GetSuggestions(ctx context.Context, req Ads_GetSuggestions_Request, options ...Option) (resp Ads_GetSuggestions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getSuggestions", ctx, values, &resp)
	return
}

type Ads_GetTargetGroups_Request struct {
	// Advertising account ID.
	AccountId int
	// 'Only for advertising agencies.', ID of the client with the advertising account where the group will be created.
	ClientId *int
	// '1' — to return pixel code.
	Extended *bool
}

func (r Ads_GetTargetGroups_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Ads_GetTargetGroups Returns a list of target groups.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getTargetGroups
func (vk *VK) Ads_GetTargetGroups(ctx context.Context, req Ads_GetTargetGroups_Request, options ...Option) (resp Ads_GetTargetGroups_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getTargetGroups", ctx, values, &resp)
	return
}

type Ads_GetTargetingStats_AdFormat int

const (
	Ads_GetTargetingStats_AdFormat_ImageAndText           Ads_GetTargetingStats_AdFormat = 1
	Ads_GetTargetingStats_AdFormat_BigImage               Ads_GetTargetingStats_AdFormat = 2
	Ads_GetTargetingStats_AdFormat_ExclusiveFormat        Ads_GetTargetingStats_AdFormat = 3
	Ads_GetTargetingStats_AdFormat_CommunitySquareImage   Ads_GetTargetingStats_AdFormat = 4
	Ads_GetTargetingStats_AdFormat_SpecialAppFormat       Ads_GetTargetingStats_AdFormat = 7
	Ads_GetTargetingStats_AdFormat_SpecialCommunityFormat Ads_GetTargetingStats_AdFormat = 8
	Ads_GetTargetingStats_AdFormat_PostInCommunity        Ads_GetTargetingStats_AdFormat = 9
	Ads_GetTargetingStats_AdFormat_AppBoard               Ads_GetTargetingStats_AdFormat = 10
)

type Ads_GetTargetingStats_Request struct {
	// Advertising account ID.
	AccountId int
	ClientId  *int
	// Serialized JSON object that describes targeting parameters. Description of 'criteria' object see below.
	Criteria *string
	// ID of an ad which targeting parameters shall be analyzed.
	AdId *int
	// Ad format. Possible values: *'1' — image and text,, *'2' — big image,, *'3' — exclusive format,, *'4' — community, square image,, *'7' — special app format,, *'8' — special community format,, *'9' — post in community,, *'10' — app board.
	AdFormat *Ads_GetTargetingStats_AdFormat
	// Platforms to use for ad showing. Possible values: (for 'ad_format' = '1'), *'0' — VK and partner sites,, *'1' — VK only. (for 'ad_format' = '9'), *'all' — all platforms,, *'desktop' — desktop version,, *'mobile' — mobile version and apps.
	AdPlatform            *string
	AdPlatformNoWall      *string
	AdPlatformNoAdNetwork *string
	PublisherPlatforms    *string
	// URL for the advertised object.
	LinkUrl string
	// Domain of the advertised object.
	LinkDomain *string
	// Additionally return recommended cpc and cpm to reach 5,10..95 percents of audience.
	NeedPrecise *bool
	// Impressions limit period in seconds, must be a multiple of 86400(day)
	ImpressionsLimitPeriod *int
}

func (r Ads_GetTargetingStats_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	if r.Criteria != nil {
		setString(values, "criteria", *r.Criteria)
	}
	if r.AdId != nil {
		setInt(values, "ad_id", *r.AdId)
	}
	if r.AdFormat != nil {
		setInt(values, "ad_format", int(*r.AdFormat))
	}
	if r.AdPlatform != nil {
		setString(values, "ad_platform", *r.AdPlatform)
	}
	if r.AdPlatformNoWall != nil {
		setString(values, "ad_platform_no_wall", *r.AdPlatformNoWall)
	}
	if r.AdPlatformNoAdNetwork != nil {
		setString(values, "ad_platform_no_ad_network", *r.AdPlatformNoAdNetwork)
	}
	if r.PublisherPlatforms != nil {
		setString(values, "publisher_platforms", *r.PublisherPlatforms)
	}
	setString(values, "link_url", r.LinkUrl)
	if r.LinkDomain != nil {
		setString(values, "link_domain", *r.LinkDomain)
	}
	if r.NeedPrecise != nil {
		setBool(values, "need_precise", *r.NeedPrecise)
	}
	if r.ImpressionsLimitPeriod != nil {
		setInt(values, "impressions_limit_period", *r.ImpressionsLimitPeriod)
	}
	return
}

// Ads_GetTargetingStats Returns the size of targeting audience, and also recommended values for CPC and CPM.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.getTargetingStats
func (vk *VK) Ads_GetTargetingStats(ctx context.Context, req Ads_GetTargetingStats_Request, options ...Option) (resp Ads_GetTargetingStats_Response, apiErr ApiError, err error) {
	values := make(url.Values, 15+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getTargetingStats", ctx, values, &resp)
	return
}

type Ads_GetUploadURL_AdFormat int

const (
	Ads_GetUploadURL_AdFormat_ImageAndText         Ads_GetUploadURL_AdFormat = 1
	Ads_GetUploadURL_AdFormat_BigImage             Ads_GetUploadURL_AdFormat = 2
	Ads_GetUploadURL_AdFormat_ExclusiveFormat      Ads_GetUploadURL_AdFormat = 3
	Ads_GetUploadURL_AdFormat_CommunitySquareImage Ads_GetUploadURL_AdFormat = 4
	Ads_GetUploadURL_AdFormat_SpecialAppFormat     Ads_GetUploadURL_AdFormat = 7
)

type Ads_GetUploadURL_Request struct {
	// Ad format: *1 — image and text,, *2 — big image,, *3 — exclusive format,, *4 — community, square image,, *7 — special app format.
	AdFormat Ads_GetUploadURL_AdFormat
	Icon     *int
}

func (r Ads_GetUploadURL_Request) fillIn(values url.Values) (err error) {
	setInt(values, "ad_format", int(r.AdFormat))
	if r.Icon != nil {
		setInt(values, "icon", *r.Icon)
	}
	return
}

// Ads_GetUploadURL Returns URL to upload an ad photo to.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getUploadURL
func (vk *VK) Ads_GetUploadURL(ctx context.Context, req Ads_GetUploadURL_Request, options ...Option) (resp Ads_GetUploadURL_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getUploadURL", ctx, values, &resp)
	return
}

// Ads_GetVideoUploadURL Returns URL to upload an ad video to.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/ads.getVideoUploadURL
func (vk *VK) Ads_GetVideoUploadURL(ctx context.Context, options ...Option) (resp Ads_GetVideoUploadURL_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.getVideoUploadURL", ctx, values, &resp)
	return
}

type Ads_ImportTargetContacts_Request struct {
	// Advertising account ID.
	AccountId int
	// 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	ClientId *int
	// Target group ID.
	TargetGroupId int
	// List of phone numbers, emails or user IDs separated with a comma.
	Contacts string
}

func (r Ads_ImportTargetContacts_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	setInt(values, "target_group_id", r.TargetGroupId)
	setString(values, "contacts", r.Contacts)
	return
}

// Ads_ImportTargetContacts Imports a list of advertiser's contacts to count VK registered users against the target group.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.importTargetContacts
func (vk *VK) Ads_ImportTargetContacts(ctx context.Context, req Ads_ImportTargetContacts_Request, options ...Option) (resp Ads_ImportTargetContacts_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.importTargetContacts", ctx, values, &resp)
	return
}

type Ads_RemoveOfficeUsers_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array with IDs of deleted managers.
	Ids string
}

func (r Ads_RemoveOfficeUsers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "ids", r.Ids)
	return
}

// Ads_RemoveOfficeUsers Removes managers and/or supervisors from advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.removeOfficeUsers
func (vk *VK) Ads_RemoveOfficeUsers(ctx context.Context, req Ads_RemoveOfficeUsers_Request, options ...Option) (resp Ads_RemoveOfficeUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.removeOfficeUsers", ctx, values, &resp)
	return
}

type Ads_UpdateAds_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe changes in ads. Description of 'ad_edit_specification' objects see below.
	Data string
}

func (r Ads_UpdateAds_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_UpdateAds Edits ads.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.updateAds
func (vk *VK) Ads_UpdateAds(ctx context.Context, req Ads_UpdateAds_Request, options ...Option) (resp Ads_UpdateAds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.updateAds", ctx, values, &resp)
	return
}

type Ads_UpdateCampaigns_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe changes in campaigns. Description of 'campaign_mod' objects see below.
	Data string
}

func (r Ads_UpdateCampaigns_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_UpdateCampaigns Edits advertising campaigns.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AdsPartialSuccess, Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.updateCampaigns
func (vk *VK) Ads_UpdateCampaigns(ctx context.Context, req Ads_UpdateCampaigns_Request, options ...Option) (resp Ads_UpdateCampaigns_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.updateCampaigns", ctx, values, &resp)
	return
}

type Ads_UpdateClients_Request struct {
	// Advertising account ID.
	AccountId int
	// Serialized JSON array of objects that describe changes in clients. Description of 'client_mod' objects see below.
	Data string
}

func (r Ads_UpdateClients_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	setString(values, "data", r.Data)
	return
}

// Ads_UpdateClients Edits clients of an advertising agency.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.updateClients
func (vk *VK) Ads_UpdateClients(ctx context.Context, req Ads_UpdateClients_Request, options ...Option) (resp Ads_UpdateClients_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.updateClients", ctx, values, &resp)
	return
}

type Ads_UpdateOfficeUsers_Request struct {
	// Advertising account ID.
	//  Minimum: 0
	AccountId int
	//  Format: json
	//  MinItems: 1
	//  MaxItems: 10
	Data *[]Ads_UserSpecification
}

func (r Ads_UpdateOfficeUsers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.Data != nil {
		if err = setJSON(values, "data", *r.Data); err != nil {
			return
		}
	}
	return
}

// Ads_UpdateOfficeUsers Adds managers and/or supervisors to advertising account.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.updateOfficeUsers
func (vk *VK) Ads_UpdateOfficeUsers(ctx context.Context, req Ads_UpdateOfficeUsers_Request, options ...Option) (resp Ads_UpdateOfficeUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.updateOfficeUsers", ctx, values, &resp)
	return
}

type Ads_UpdateTargetGroup_Request struct {
	// Advertising account ID.
	AccountId int
	// 'Only for advertising agencies.' , ID of the client with the advertising account where the group will be created.
	ClientId *int
	// Group ID.
	TargetGroupId int
	// New name of the target group — a string up to 64 characters long.
	Name string
	// Domain of the site where user accounting code will be placed.
	Domain *string
	// 'Only for the groups that get audience from sites with user accounting code.', Time in days when users added to a retarget group will be automatically excluded from it. '0' - automatic exclusion is off.
	//  Minimum: 1
	//  Maximum: 720
	Lifetime         int
	TargetPixelId    *int
	TargetPixelRules *string
}

func (r Ads_UpdateTargetGroup_Request) fillIn(values url.Values) (err error) {
	setInt(values, "account_id", r.AccountId)
	if r.ClientId != nil {
		setInt(values, "client_id", *r.ClientId)
	}
	setInt(values, "target_group_id", r.TargetGroupId)
	setString(values, "name", r.Name)
	if r.Domain != nil {
		setString(values, "domain", *r.Domain)
	}
	setInt(values, "lifetime", r.Lifetime)
	if r.TargetPixelId != nil {
		setInt(values, "target_pixel_id", *r.TargetPixelId)
	}
	if r.TargetPixelRules != nil {
		setString(values, "target_pixel_rules", *r.TargetPixelRules)
	}
	return
}

// Ads_UpdateTargetGroup Edits a retarget group.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WeightedFlood ]
//
// https://dev.vk.com/method/ads.updateTargetGroup
func (vk *VK) Ads_UpdateTargetGroup(ctx context.Context, req Ads_UpdateTargetGroup_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("ads.updateTargetGroup", ctx, values, &resp)
	return
}

type Adsweb_GetAdCategories_Request struct {
	OfficeId int
}

func (r Adsweb_GetAdCategories_Request) fillIn(values url.Values) (err error) {
	setInt(values, "office_id", r.OfficeId)
	return
}

// Adsweb_GetAdCategories ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getAdCategories
func (vk *VK) Adsweb_GetAdCategories(ctx context.Context, req Adsweb_GetAdCategories_Request, options ...Option) (resp Adsweb_GetAdCategories_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getAdCategories", ctx, values, &resp)
	return
}

// Adsweb_GetAdUnitCode ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getAdUnitCode
func (vk *VK) Adsweb_GetAdUnitCode(ctx context.Context, options ...Option) (resp Adsweb_GetAdUnitCode_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getAdUnitCode", ctx, values, &resp)
	return
}

type Adsweb_GetAdUnits_Request struct {
	OfficeId   int
	SitesIds   *string
	AdUnitsIds *string
	Fields     *string
	//  Minimum: 0
	Limit *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
}

func (r Adsweb_GetAdUnits_Request) fillIn(values url.Values) (err error) {
	setInt(values, "office_id", r.OfficeId)
	if r.SitesIds != nil {
		setString(values, "sites_ids", *r.SitesIds)
	}
	if r.AdUnitsIds != nil {
		setString(values, "ad_units_ids", *r.AdUnitsIds)
	}
	if r.Fields != nil {
		setString(values, "fields", *r.Fields)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Adsweb_GetAdUnits ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getAdUnits
func (vk *VK) Adsweb_GetAdUnits(ctx context.Context, req Adsweb_GetAdUnits_Request, options ...Option) (resp Adsweb_GetAdUnits_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getAdUnits", ctx, values, &resp)
	return
}

type Adsweb_GetFraudHistory_Request struct {
	OfficeId int
	SitesIds *string
	//  Minimum: 0
	Limit *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
}

func (r Adsweb_GetFraudHistory_Request) fillIn(values url.Values) (err error) {
	setInt(values, "office_id", r.OfficeId)
	if r.SitesIds != nil {
		setString(values, "sites_ids", *r.SitesIds)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Adsweb_GetFraudHistory ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getFraudHistory
func (vk *VK) Adsweb_GetFraudHistory(ctx context.Context, req Adsweb_GetFraudHistory_Request, options ...Option) (resp Adsweb_GetFraudHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getFraudHistory", ctx, values, &resp)
	return
}

type Adsweb_GetSites_Request struct {
	OfficeId int
	SitesIds *string
	Fields   *string
	//  Minimum: 0
	Limit *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
}

func (r Adsweb_GetSites_Request) fillIn(values url.Values) (err error) {
	setInt(values, "office_id", r.OfficeId)
	if r.SitesIds != nil {
		setString(values, "sites_ids", *r.SitesIds)
	}
	if r.Fields != nil {
		setString(values, "fields", *r.Fields)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Adsweb_GetSites ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getSites
func (vk *VK) Adsweb_GetSites(ctx context.Context, req Adsweb_GetSites_Request, options ...Option) (resp Adsweb_GetSites_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getSites", ctx, values, &resp)
	return
}

type Adsweb_GetStatistics_Request struct {
	OfficeId int
	IdsType  string
	Ids      string
	Period   string
	DateFrom string
	DateTo   string
	Fields   *string
	//  Minimum: 0
	Limit  *int
	PageId *string
}

func (r Adsweb_GetStatistics_Request) fillIn(values url.Values) (err error) {
	setInt(values, "office_id", r.OfficeId)
	setString(values, "ids_type", r.IdsType)
	setString(values, "ids", r.Ids)
	setString(values, "period", r.Period)
	setString(values, "date_from", r.DateFrom)
	setString(values, "date_to", r.DateTo)
	if r.Fields != nil {
		setString(values, "fields", *r.Fields)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.PageId != nil {
		setString(values, "page_id", *r.PageId)
	}
	return
}

// Adsweb_GetStatistics ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/adsweb.getStatistics
func (vk *VK) Adsweb_GetStatistics(ctx context.Context, req Adsweb_GetStatistics_Request, options ...Option) (resp Adsweb_GetStatistics_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("adsweb.getStatistics", ctx, values, &resp)
	return
}

type AppWidgets_GetAppImageUploadServer_ImageType string

const (
	AppWidgets_GetAppImageUploadServer_ImageType_160x160 AppWidgets_GetAppImageUploadServer_ImageType = "160x160"
	AppWidgets_GetAppImageUploadServer_ImageType_160x240 AppWidgets_GetAppImageUploadServer_ImageType = "160x240"
	AppWidgets_GetAppImageUploadServer_ImageType_24x24   AppWidgets_GetAppImageUploadServer_ImageType = "24x24"
	AppWidgets_GetAppImageUploadServer_ImageType_50x50   AppWidgets_GetAppImageUploadServer_ImageType = "50x50"
	AppWidgets_GetAppImageUploadServer_ImageType_510x128 AppWidgets_GetAppImageUploadServer_ImageType = "510x128"
)

type AppWidgets_GetAppImageUploadServer_Request struct {
	ImageType AppWidgets_GetAppImageUploadServer_ImageType
}

func (r AppWidgets_GetAppImageUploadServer_Request) fillIn(values url.Values) (err error) {
	setString(values, "image_type", string(r.ImageType))
	return
}

// AppWidgets_GetAppImageUploadServer Returns a URL for uploading a photo to the community collection for community app widgets
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/appWidgets.getAppImageUploadServer
func (vk *VK) AppWidgets_GetAppImageUploadServer(ctx context.Context, req AppWidgets_GetAppImageUploadServer_Request, options ...Option) (resp AppWidgets_GetAppImageUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.getAppImageUploadServer", ctx, values, &resp)
	return
}

type AppWidgets_GetAppImages_ImageType string

const (
	AppWidgets_GetAppImages_ImageType_160x160 AppWidgets_GetAppImages_ImageType = "160x160"
	AppWidgets_GetAppImages_ImageType_160x240 AppWidgets_GetAppImages_ImageType = "160x240"
	AppWidgets_GetAppImages_ImageType_24x24   AppWidgets_GetAppImages_ImageType = "24x24"
	AppWidgets_GetAppImages_ImageType_50x50   AppWidgets_GetAppImages_ImageType = "50x50"
	AppWidgets_GetAppImages_ImageType_510x128 AppWidgets_GetAppImages_ImageType = "510x128"
)

type AppWidgets_GetAppImages_Request struct {
	// Offset needed to return a specific subset of images.
	//  Minimum: 0
	Offset *int
	// Maximum count of results.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count     *int
	ImageType *AppWidgets_GetAppImages_ImageType
}

func (r AppWidgets_GetAppImages_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.ImageType != nil {
		setString(values, "image_type", string(*r.ImageType))
	}
	return
}

// AppWidgets_GetAppImages Returns an app collection of images for community app widgets
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/appWidgets.getAppImages
func (vk *VK) AppWidgets_GetAppImages(ctx context.Context, req AppWidgets_GetAppImages_Request, options ...Option) (resp AppWidgets_GetAppImages_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.getAppImages", ctx, values, &resp)
	return
}

type AppWidgets_GetGroupImageUploadServer_ImageType string

const (
	AppWidgets_GetGroupImageUploadServer_ImageType_160x160 AppWidgets_GetGroupImageUploadServer_ImageType = "160x160"
	AppWidgets_GetGroupImageUploadServer_ImageType_160x240 AppWidgets_GetGroupImageUploadServer_ImageType = "160x240"
	AppWidgets_GetGroupImageUploadServer_ImageType_24x24   AppWidgets_GetGroupImageUploadServer_ImageType = "24x24"
	AppWidgets_GetGroupImageUploadServer_ImageType_50x50   AppWidgets_GetGroupImageUploadServer_ImageType = "50x50"
	AppWidgets_GetGroupImageUploadServer_ImageType_510x128 AppWidgets_GetGroupImageUploadServer_ImageType = "510x128"
)

type AppWidgets_GetGroupImageUploadServer_Request struct {
	ImageType AppWidgets_GetGroupImageUploadServer_ImageType
}

func (r AppWidgets_GetGroupImageUploadServer_Request) fillIn(values url.Values) (err error) {
	setString(values, "image_type", string(r.ImageType))
	return
}

// AppWidgets_GetGroupImageUploadServer Returns a URL for uploading a photo to the community collection for community app widgets
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/appWidgets.getGroupImageUploadServer
func (vk *VK) AppWidgets_GetGroupImageUploadServer(ctx context.Context, req AppWidgets_GetGroupImageUploadServer_Request, options ...Option) (resp AppWidgets_GetGroupImageUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.getGroupImageUploadServer", ctx, values, &resp)
	return
}

type AppWidgets_GetGroupImages_ImageType string

const (
	AppWidgets_GetGroupImages_ImageType_160x160 AppWidgets_GetGroupImages_ImageType = "160x160"
	AppWidgets_GetGroupImages_ImageType_160x240 AppWidgets_GetGroupImages_ImageType = "160x240"
	AppWidgets_GetGroupImages_ImageType_24x24   AppWidgets_GetGroupImages_ImageType = "24x24"
	AppWidgets_GetGroupImages_ImageType_50x50   AppWidgets_GetGroupImages_ImageType = "50x50"
	AppWidgets_GetGroupImages_ImageType_510x128 AppWidgets_GetGroupImages_ImageType = "510x128"
)

type AppWidgets_GetGroupImages_Request struct {
	// Offset needed to return a specific subset of images.
	//  Minimum: 0
	Offset *int
	// Maximum count of results.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count     *int
	ImageType *AppWidgets_GetGroupImages_ImageType
}

func (r AppWidgets_GetGroupImages_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.ImageType != nil {
		setString(values, "image_type", string(*r.ImageType))
	}
	return
}

// AppWidgets_GetGroupImages Returns a community collection of images for community app widgets
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/appWidgets.getGroupImages
func (vk *VK) AppWidgets_GetGroupImages(ctx context.Context, req AppWidgets_GetGroupImages_Request, options ...Option) (resp AppWidgets_GetGroupImages_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.getGroupImages", ctx, values, &resp)
	return
}

type AppWidgets_GetImagesById_Request struct {
	//  MaxItems: 100
	Images *[]string
}

func (r AppWidgets_GetImagesById_Request) fillIn(values url.Values) (err error) {
	if r.Images != nil {
		setStrings(values, "images", *r.Images)
	}
	return
}

// AppWidgets_GetImagesById Returns an image for community app widgets by its ID
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/appWidgets.getImagesById
func (vk *VK) AppWidgets_GetImagesById(ctx context.Context, req AppWidgets_GetImagesById_Request, options ...Option) (resp AppWidgets_GetImagesById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.getImagesById", ctx, values, &resp)
	return
}

type AppWidgets_SaveAppImage_Request struct {
	// Parameter returned when photo is uploaded to server
	Hash string
	// Parameter returned when photo is uploaded to server
	Image string
}

func (r AppWidgets_SaveAppImage_Request) fillIn(values url.Values) (err error) {
	setString(values, "hash", r.Hash)
	setString(values, "image", r.Image)
	return
}

// AppWidgets_SaveAppImage Allows to save image into app collection for community app widgets
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhoto ]
//
// https://dev.vk.com/method/appWidgets.saveAppImage
func (vk *VK) AppWidgets_SaveAppImage(ctx context.Context, req AppWidgets_SaveAppImage_Request, options ...Option) (resp AppWidgets_SaveAppImage_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.saveAppImage", ctx, values, &resp)
	return
}

type AppWidgets_SaveGroupImage_Request struct {
	// Parameter returned when photo is uploaded to server
	Hash string
	// Parameter returned when photo is uploaded to server
	Image string
}

func (r AppWidgets_SaveGroupImage_Request) fillIn(values url.Values) (err error) {
	setString(values, "hash", r.Hash)
	setString(values, "image", r.Image)
	return
}

// AppWidgets_SaveGroupImage Allows to save image into community collection for community app widgets
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhoto ]
//
// https://dev.vk.com/method/appWidgets.saveGroupImage
func (vk *VK) AppWidgets_SaveGroupImage(ctx context.Context, req AppWidgets_SaveGroupImage_Request, options ...Option) (resp AppWidgets_SaveGroupImage_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.saveGroupImage", ctx, values, &resp)
	return
}

type AppWidgets_Update_Type string

const (
	AppWidgets_Update_Type_CompactList AppWidgets_Update_Type = "compact_list"
	AppWidgets_Update_Type_CoverList   AppWidgets_Update_Type = "cover_list"
	AppWidgets_Update_Type_Donation    AppWidgets_Update_Type = "donation"
	AppWidgets_Update_Type_List        AppWidgets_Update_Type = "list"
	AppWidgets_Update_Type_Match       AppWidgets_Update_Type = "match"
	AppWidgets_Update_Type_Matches     AppWidgets_Update_Type = "matches"
	AppWidgets_Update_Type_Table       AppWidgets_Update_Type = "table"
	AppWidgets_Update_Type_Text        AppWidgets_Update_Type = "text"
	AppWidgets_Update_Type_Tiles       AppWidgets_Update_Type = "tiles"
)

type AppWidgets_Update_Request struct {
	//  MaxLength: 100000
	Code string
	Type AppWidgets_Update_Type
}

func (r AppWidgets_Update_Request) fillIn(values url.Values) (err error) {
	setString(values, "code", r.Code)
	setString(values, "type", string(r.Type))
	return
}

// AppWidgets_Update Allows to update community app widget
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Compile, Error_Runtime, Error_Blocked, Error_WallAccessPost, Error_WallAccessReplies, Error_ParamGroupId ]
//
// https://dev.vk.com/method/appWidgets.update
func (vk *VK) AppWidgets_Update(ctx context.Context, req AppWidgets_Update_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("appWidgets.update", ctx, values, &resp)
	return
}

// Apps_DeleteAppRequests Deletes all request notifications from the current app.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.deleteAppRequests
func (vk *VK) Apps_DeleteAppRequests(ctx context.Context, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.deleteAppRequests", ctx, values, &resp)
	return
}

type Apps_Get_Platform string

const (
	Apps_Get_Platform_Android  Apps_Get_Platform = "android"
	Apps_Get_Platform_Ios      Apps_Get_Platform = "ios"
	Apps_Get_Platform_Web      Apps_Get_Platform = "web"
	Apps_Get_Platform_Winphone Apps_Get_Platform = "winphone"
)

type Apps_Get_NameCase string

const (
	Apps_Get_NameCase_Nominative    Apps_Get_NameCase = "nom"
	Apps_Get_NameCase_Genitive      Apps_Get_NameCase = "gen"
	Apps_Get_NameCase_Dative        Apps_Get_NameCase = "dat"
	Apps_Get_NameCase_Accusative    Apps_Get_NameCase = "acc"
	Apps_Get_NameCase_Instrumental  Apps_Get_NameCase = "ins"
	Apps_Get_NameCase_Prepositional Apps_Get_NameCase = "abl"
)

type Apps_Get_Request struct {
	// Application ID
	//  Minimum: 0
	AppId *int
	//  MaxItems: 100
	AppIds *[]string
	// platform. Possible values: *'ios' — iOS,, *'android' — Android,, *'winphone' — Windows Phone,, *'web' — приложения на vk.com. By default: 'web'.
	//  Default: web
	Platform *Apps_Get_Platform
	//  Default: 0
	Extended *bool
	//  Default: 0
	ReturnFriends *bool
	Fields        *[]Users_Fields
	// Case for declension of user name and surname: 'nom' — nominative (default),, 'gen' — genitive,, 'dat' — dative,, 'acc' — accusative,, 'ins' — instrumental,, 'abl' — prepositional. (only if 'return_friends' = '1')
	NameCase *Apps_Get_NameCase
}

func (r Apps_Get_Request) fillIn(values url.Values) (err error) {
	if r.AppId != nil {
		setInt(values, "app_id", *r.AppId)
	}
	if r.AppIds != nil {
		setStrings(values, "app_ids", *r.AppIds)
	}
	if r.Platform != nil {
		setString(values, "platform", string(*r.Platform))
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.ReturnFriends != nil {
		setBool(values, "return_friends", *r.ReturnFriends)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Apps_Get Returns applications data.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.get
func (vk *VK) Apps_Get(ctx context.Context, req Apps_Get_Request, options ...Option) (resp Apps_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.get", ctx, values, &resp)
	return
}

type Apps_GetCatalog_Sort string

const (
	Apps_GetCatalog_Sort_PopularToday Apps_GetCatalog_Sort = "popular_today"
	Apps_GetCatalog_Sort_Visitors     Apps_GetCatalog_Sort = "visitors"
	Apps_GetCatalog_Sort_CreateDate   Apps_GetCatalog_Sort = "create_date"
	Apps_GetCatalog_Sort_GrowthRate   Apps_GetCatalog_Sort = "growth_rate"
	Apps_GetCatalog_Sort_PopularWeek  Apps_GetCatalog_Sort = "popular_week"
)

type Apps_GetCatalog_Filter string

const (
	Apps_GetCatalog_Filter_Favorite  Apps_GetCatalog_Filter = "favorite"
	Apps_GetCatalog_Filter_Featured  Apps_GetCatalog_Filter = "featured"
	Apps_GetCatalog_Filter_Installed Apps_GetCatalog_Filter = "installed"
	Apps_GetCatalog_Filter_New       Apps_GetCatalog_Filter = "new"
)

type Apps_GetCatalog_Request struct {
	// Sort order: 'popular_today' — popular for one day (default), 'visitors' — by visitors number , 'create_date' — by creation date, 'growth_rate' — by growth rate, 'popular_week' — popular for one week
	Sort *Apps_GetCatalog_Sort
	// Offset required to return a specific subset of apps.
	//  Minimum: 0
	Offset *int
	// Number of apps to return.
	//  Default: 100
	//  Minimum: 0
	Count    int
	Platform *string
	// '1' — to return additional fields 'screenshots', 'MAU', 'catalog_position', and 'international'. If set, 'count' must be less than or equal to '100'. '0' — not to return additional fields (default).
	Extended      *bool
	ReturnFriends *bool
	Fields        *[]Users_Fields
	NameCase      *string
	// Search query string.
	Q *string
	//  Minimum: 0
	GenreId *int
	// 'installed' — to return list of installed apps (only for mobile platform).
	Filter *Apps_GetCatalog_Filter
}

func (r Apps_GetCatalog_Request) fillIn(values url.Values) (err error) {
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	setInt(values, "count", r.Count)
	if r.Platform != nil {
		setString(values, "platform", *r.Platform)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.ReturnFriends != nil {
		setBool(values, "return_friends", *r.ReturnFriends)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", *r.NameCase)
	}
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.GenreId != nil {
		setInt(values, "genre_id", *r.GenreId)
	}
	if r.Filter != nil {
		setString(values, "filter", string(*r.Filter))
	}
	return
}

// Apps_GetCatalog Returns a list of applications (apps) available to users in the App Catalog.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getCatalog
func (vk *VK) Apps_GetCatalog(ctx context.Context, req Apps_GetCatalog_Request, options ...Option) (resp Apps_GetCatalog_Response, apiErr ApiError, err error) {
	values := make(url.Values, 13+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getCatalog", ctx, values, &resp)
	return
}

type Apps_GetFriendsList_Type string

const (
	Apps_GetFriendsList_Type_Invite  Apps_GetFriendsList_Type = "invite"
	Apps_GetFriendsList_Type_Request Apps_GetFriendsList_Type = "request"
)

type Apps_GetFriendsList_Request struct {
	// List size.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 5000
	Count *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// List type. Possible values: * 'invite' — available for invites (don't play the game),, * 'request' — available for request (play the game). By default: 'invite'.
	//  Default: invite
	Type   *Apps_GetFriendsList_Type
	Fields *[]Users_Fields
}

func (r Apps_GetFriendsList_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Apps_GetFriendsList Creates friends list for requests and invites in current app.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getFriendsList
func (vk *VK) Apps_GetFriendsList(ctx context.Context, req Apps_GetFriendsList_Request, options ...Option) (resp Apps_GetFriendsList_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getFriendsList", ctx, values, &resp)
	return
}

// Apps_GetFriendsListExtended Creates friends list for requests and invites in current app.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getFriendsList
func (vk *VK) Apps_GetFriendsListExtended(ctx context.Context, req Apps_GetFriendsList_Request, options ...Option) (resp Apps_GetFriendsListExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getFriendsList", ctx, values, &resp)
	return
}

type Apps_GetLeaderboard_Type string

const (
	Apps_GetLeaderboard_Type_Level  Apps_GetLeaderboard_Type = "level"
	Apps_GetLeaderboard_Type_Points Apps_GetLeaderboard_Type = "points"
	Apps_GetLeaderboard_Type_Score  Apps_GetLeaderboard_Type = "score"
)

type Apps_GetLeaderboard_Request struct {
	// Leaderboard type. Possible values: *'level' — by level,, *'points' — by mission points,, *'score' — by score ().
	Type Apps_GetLeaderboard_Type
	// Rating type. Possible values: *'1' — global rating among all players,, *'0' — rating among user friends.
	//  Default: 1
	Global *bool
}

func (r Apps_GetLeaderboard_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.Global != nil {
		setBool(values, "global", *r.Global)
	}
	return
}

// Apps_GetLeaderboard Returns players rating in the game.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getLeaderboard
func (vk *VK) Apps_GetLeaderboard(ctx context.Context, req Apps_GetLeaderboard_Request, options ...Option) (resp Apps_GetLeaderboard_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getLeaderboard", ctx, values, &resp)
	return
}

// Apps_GetLeaderboardExtended Returns players rating in the game.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getLeaderboard
func (vk *VK) Apps_GetLeaderboardExtended(ctx context.Context, req Apps_GetLeaderboard_Request, options ...Option) (resp Apps_GetLeaderboardExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getLeaderboard", ctx, values, &resp)
	return
}

type Apps_GetMiniAppPolicies_Request struct {
	// Mini App ID
	//  Minimum: 0
	AppId int
}

func (r Apps_GetMiniAppPolicies_Request) fillIn(values url.Values) (err error) {
	setInt(values, "app_id", r.AppId)
	return
}

// Apps_GetMiniAppPolicies Returns policies and terms given to a mini app.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getMiniAppPolicies
func (vk *VK) Apps_GetMiniAppPolicies(ctx context.Context, req Apps_GetMiniAppPolicies_Request, options ...Option) (resp Apps_GetMiniAppPolicies_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getMiniAppPolicies", ctx, values, &resp)
	return
}

type Apps_GetScopes_Type string

const (
	Apps_GetScopes_Type_Group Apps_GetScopes_Type = "group"
	Apps_GetScopes_Type_User  Apps_GetScopes_Type = "user"
)

type Apps_GetScopes_Request struct {
	//  Default: user
	Type *Apps_GetScopes_Type
}

func (r Apps_GetScopes_Request) fillIn(values url.Values) (err error) {
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	return
}

// Apps_GetScopes Returns scopes for auth
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getScopes
func (vk *VK) Apps_GetScopes(ctx context.Context, req Apps_GetScopes_Request, options ...Option) (resp Apps_GetScopes_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getScopes", ctx, values, &resp)
	return
}

type Apps_GetScore_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Apps_GetScore_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	return
}

// Apps_GetScore Returns user score in app
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.getScore
func (vk *VK) Apps_GetScore(ctx context.Context, req Apps_GetScore_Request, options ...Option) (resp Apps_GetScore_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.getScore", ctx, values, &resp)
	return
}

type Apps_PromoHasActiveGift_Request struct {
	// Id of game promo action
	//  Minimum: 0
	PromoId int
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Apps_PromoHasActiveGift_Request) fillIn(values url.Values) (err error) {
	setInt(values, "promo_id", r.PromoId)
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Apps_PromoHasActiveGift ...
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ActionFailed ]
//
// https://dev.vk.com/method/apps.promoHasActiveGift
func (vk *VK) Apps_PromoHasActiveGift(ctx context.Context, req Apps_PromoHasActiveGift_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.promoHasActiveGift", ctx, values, &resp)
	return
}

type Apps_PromoUseGift_Request struct {
	// Id of game promo action
	//  Minimum: 0
	PromoId int
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Apps_PromoUseGift_Request) fillIn(values url.Values) (err error) {
	setInt(values, "promo_id", r.PromoId)
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Apps_PromoUseGift ...
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ActionFailed ]
//
// https://dev.vk.com/method/apps.promoUseGift
func (vk *VK) Apps_PromoUseGift(ctx context.Context, req Apps_PromoUseGift_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.promoUseGift", ctx, values, &resp)
	return
}

type Apps_SendRequest_Type string

const (
	Apps_SendRequest_Type_Invite  Apps_SendRequest_Type = "invite"
	Apps_SendRequest_Type_Request Apps_SendRequest_Type = "request"
)

type Apps_SendRequest_Request struct {
	// id of the user to send a request
	//  Format: int64
	//  Minimum: 1
	UserId int
	// request text
	Text *string
	// request type. Values: 'invite' - if the request is sent to a user who does not have the app installed,, 'request' - if a user has already installed the app
	//  Default: request
	Type *Apps_SendRequest_Type
	//  MaxLength: 128
	Name *string
	// special string key to be sent with the request
	Key      *string
	Separate *bool
}

func (r Apps_SendRequest_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	if r.Key != nil {
		setString(values, "key", *r.Key)
	}
	if r.Separate != nil {
		setBool(values, "separate", *r.Separate)
	}
	return
}

// Apps_SendRequest Sends a request to another user in an app that uses VK authorization.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/apps.sendRequest
func (vk *VK) Apps_SendRequest(ctx context.Context, req Apps_SendRequest_Request, options ...Option) (resp Apps_SendRequest_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("apps.sendRequest", ctx, values, &resp)
	return
}

type Auth_Restore_Request struct {
	// User phone number.
	Phone string
	// User last name.
	LastName string
}

func (r Auth_Restore_Request) fillIn(values url.Values) (err error) {
	setString(values, "phone", r.Phone)
	setString(values, "last_name", r.LastName)
	return
}

// Auth_Restore Allows to restore account access using a code received via SMS. " This method is only available for apps with [vk.com/dev/auth_direct|Direct authorization] access. "
// May execute with listed access token types:
//    [ user, open, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AuthFloodError ]
//
// https://dev.vk.com/method/auth.restore
func (vk *VK) Auth_Restore(ctx context.Context, req Auth_Restore_Request, options ...Option) (resp Auth_Restore_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("auth.restore", ctx, values, &resp)
	return
}

type Board_AddTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic title.
	Title string
	// Text of the topic.
	Text *string
	// For a community: '1' — to post the topic as by the community, '0' — to post the topic as by the user (default)
	FromGroup   *bool
	Attachments *[]string
}

func (r Board_AddTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "title", r.Title)
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Board_AddTopic Creates a new topic on a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.addTopic
func (vk *VK) Board_AddTopic(ctx context.Context, req Board_AddTopic_Request, options ...Option) (resp Board_AddTopic_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.addTopic", ctx, values, &resp)
	return
}

type Board_CloseTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Minimum: 0
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
}

func (r Board_CloseTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	return
}

// Board_CloseTopic Closes a topic on a community's discussion board so that comments cannot be posted.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.closeTopic
func (vk *VK) Board_CloseTopic(ctx context.Context, req Board_CloseTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.closeTopic", ctx, values, &resp)
	return
}

type Board_CreateComment_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// ID of the topic to be commented on.
	//  Minimum: 0
	TopicId int
	// (Required if 'attachments' is not set.) Text of the comment.
	Message     *string
	Attachments *[]string
	// '1' — to post the comment as by the community, '0' — to post the comment as by the user (default)
	FromGroup *bool
	// Sticker ID.
	//  Minimum: 0
	StickerId *int
	// Unique identifier to avoid repeated comments.
	Guid *string
}

func (r Board_CreateComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Board_CreateComment Adds a comment on a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.createComment
func (vk *VK) Board_CreateComment(ctx context.Context, req Board_CreateComment_Request, options ...Option) (resp Board_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.createComment", ctx, values, &resp)
	return
}

type Board_DeleteComment_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 1
	TopicId int
	// Comment ID.
	//  Minimum: 1
	CommentId int
}

func (r Board_DeleteComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	setInt(values, "comment_id", r.CommentId)
	return
}

// Board_DeleteComment Deletes a comment on a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.deleteComment
func (vk *VK) Board_DeleteComment(ctx context.Context, req Board_DeleteComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.deleteComment", ctx, values, &resp)
	return
}

type Board_DeleteTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
}

func (r Board_DeleteTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	return
}

// Board_DeleteTopic Deletes a topic from a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.deleteTopic
func (vk *VK) Board_DeleteTopic(ctx context.Context, req Board_DeleteTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.deleteTopic", ctx, values, &resp)
	return
}

type Board_EditComment_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
	// ID of the comment on the topic.
	//  Minimum: 0
	CommentId int
	// (Required if 'attachments' is not set). New comment text.
	Message     *string
	Attachments *[]string
}

func (r Board_EditComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	setInt(values, "comment_id", r.CommentId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Board_EditComment Edits a comment on a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.editComment
func (vk *VK) Board_EditComment(ctx context.Context, req Board_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.editComment", ctx, values, &resp)
	return
}

type Board_EditTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
	// New title of the topic.
	Title string
}

func (r Board_EditTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	setString(values, "title", r.Title)
	return
}

// Board_EditTopic Edits the title of a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.editTopic
func (vk *VK) Board_EditTopic(ctx context.Context, req Board_EditTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.editTopic", ctx, values, &resp)
	return
}

type Board_FixTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Minimum: 0
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
}

func (r Board_FixTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	return
}

// Board_FixTopic Pins a topic (fixes its place) to the top of a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.fixTopic
func (vk *VK) Board_FixTopic(ctx context.Context, req Board_FixTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.fixTopic", ctx, values, &resp)
	return
}

type Board_GetComments_Sort string

const (
	Board_GetComments_Sort_Chronological        Board_GetComments_Sort = "asc"
	Board_GetComments_Sort_ReverseChronological Board_GetComments_Sort = "desc"
)

type Board_GetComments_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
	// '1' — to return the 'likes' field, '0' — not to return the 'likes' field (default)
	NeedLikes *bool
	//  Minimum: 0
	StartCommentId *int
	// Offset needed to return a specific subset of comments.
	Offset *int
	// Number of comments to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// Sort order: 'asc' — by creation date in chronological order, 'desc' — by creation date in reverse chronological order,
	Sort *Board_GetComments_Sort
}

func (r Board_GetComments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.StartCommentId != nil {
		setInt(values, "start_comment_id", *r.StartCommentId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	return
}

// Board_GetComments Returns a list of comments on a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.getComments
func (vk *VK) Board_GetComments(ctx context.Context, req Board_GetComments_Request, options ...Option) (resp Board_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("board.getComments", ctx, values, &resp)
	return
}

// Board_GetCommentsExtended Returns a list of comments on a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.getComments
func (vk *VK) Board_GetCommentsExtended(ctx context.Context, req Board_GetComments_Request, options ...Option) (resp Board_GetCommentsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("board.getComments", ctx, values, &resp)
	return
}

type Board_GetTopics_Order int

const (
	Board_GetTopics_Order_UpdatedDesc       Board_GetTopics_Order = 1
	Board_GetTopics_Order_CreatedDesc       Board_GetTopics_Order = 2
	Board_GetTopics_Order_UpdatedAsc        Board_GetTopics_Order = -1
	Board_GetTopics_Order_CreatedAsc        Board_GetTopics_Order = -2
	Board_GetTopics_Order_AsByAdministrator Board_GetTopics_Order = 0
)

type Board_GetTopics_Preview int

const (
	Board_GetTopics_Preview_First Board_GetTopics_Preview = 1
	Board_GetTopics_Preview_Last  Board_GetTopics_Preview = 2
	Board_GetTopics_Preview_None  Board_GetTopics_Preview = 0
)

type Board_GetTopics_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId  int
	TopicIds *[]int
	// Sort order: '1' — by date updated in reverse chronological order. '2' — by date created in reverse chronological order. '-1' — by date updated in chronological order. '-2' — by date created in chronological order. If no sort order is specified, topics are returned in the order specified by the group administrator. Pinned topics are returned first, regardless of the sorting.
	Order *Board_GetTopics_Order
	// Offset needed to return a specific subset of topics.
	//  Minimum: 0
	Offset *int
	// Number of topics to return.
	//  Default: 40
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// '1' — to return the first comment in each topic,, '2' — to return the last comment in each topic,, '0' — to return no comments. By default: '0'.
	Preview *Board_GetTopics_Preview
	// Number of characters after which to truncate the previewed comment. To preview the full comment, specify '0'.
	//  Default: 90
	//  Minimum: 0
	PreviewLength *int
}

func (r Board_GetTopics_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.TopicIds != nil {
		setInts(values, "topic_ids", *r.TopicIds)
	}
	if r.Order != nil {
		setInt(values, "order", int(*r.Order))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Preview != nil {
		setInt(values, "preview", int(*r.Preview))
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	return
}

// Board_GetTopics Returns a list of topics on a community's discussion board.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.getTopics
func (vk *VK) Board_GetTopics(ctx context.Context, req Board_GetTopics_Request, options ...Option) (resp Board_GetTopics_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("board.getTopics", ctx, values, &resp)
	return
}

// Board_GetTopicsExtended Returns a list of topics on a community's discussion board.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.getTopics
func (vk *VK) Board_GetTopicsExtended(ctx context.Context, req Board_GetTopics_Request, options ...Option) (resp Board_GetTopicsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("board.getTopics", ctx, values, &resp)
	return
}

type Board_OpenTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Minimum: 0
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
}

func (r Board_OpenTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	return
}

// Board_OpenTopic Re-opens a previously closed topic on a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.openTopic
func (vk *VK) Board_OpenTopic(ctx context.Context, req Board_OpenTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.openTopic", ctx, values, &resp)
	return
}

type Board_RestoreComment_Request struct {
	// ID of the community that owns the discussion board.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
	// Comment ID.
	//  Minimum: 0
	CommentId int
}

func (r Board_RestoreComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	setInt(values, "comment_id", r.CommentId)
	return
}

// Board_RestoreComment Restores a comment deleted from a topic on a community's discussion board.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.restoreComment
func (vk *VK) Board_RestoreComment(ctx context.Context, req Board_RestoreComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.restoreComment", ctx, values, &resp)
	return
}

type Board_UnfixTopic_Request struct {
	// ID of the community that owns the discussion board.
	//  Minimum: 0
	GroupId int
	// Topic ID.
	//  Minimum: 0
	TopicId int
}

func (r Board_UnfixTopic_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "topic_id", r.TopicId)
	return
}

// Board_UnfixTopic Unpins a pinned topic from the top of a community's discussion board.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/board.unfixTopic
func (vk *VK) Board_UnfixTopic(ctx context.Context, req Board_UnfixTopic_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("board.unfixTopic", ctx, values, &resp)
	return
}

type Database_GetChairs_Request struct {
	// id of the faculty to get chairs from
	//  Minimum: 0
	FacultyId int
	// offset required to get a certain subset of chairs
	//  Minimum: 0
	Offset *int
	// amount of chairs to get
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 10000
	Count *int
}

func (r Database_GetChairs_Request) fillIn(values url.Values) (err error) {
	setInt(values, "faculty_id", r.FacultyId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetChairs Returns list of chairs on a specified faculty.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getChairs
func (vk *VK) Database_GetChairs(ctx context.Context, req Database_GetChairs_Request, options ...Option) (resp Database_GetChairs_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getChairs", ctx, values, &resp)
	return
}

type Database_GetCities_Request struct {
	// Country ID.
	//  Minimum: 0
	CountryId int
	// Region ID.
	//  Minimum: 0
	RegionId *int
	// Search query.
	Q *string
	// '1' — to return all cities in the country, '0' — to return major cities in the country (default),
	NeedAll *bool
	// Offset needed to return a specific subset of cities.
	//  Minimum: 0
	Offset *int
	// Number of cities to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Database_GetCities_Request) fillIn(values url.Values) (err error) {
	setInt(values, "country_id", r.CountryId)
	if r.RegionId != nil {
		setInt(values, "region_id", *r.RegionId)
	}
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.NeedAll != nil {
		setBool(values, "need_all", *r.NeedAll)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetCities Returns a list of cities.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getCities
func (vk *VK) Database_GetCities(ctx context.Context, req Database_GetCities_Request, options ...Option) (resp Database_GetCities_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getCities", ctx, values, &resp)
	return
}

type Database_GetCitiesById_Request struct {
	//  MaxItems: 1000
	//  Minimum: 0
	CityIds *[]int
}

func (r Database_GetCitiesById_Request) fillIn(values url.Values) (err error) {
	if r.CityIds != nil {
		setInts(values, "city_ids", *r.CityIds)
	}
	return
}

// Database_GetCitiesById Returns information about cities by their IDs.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getCitiesById
func (vk *VK) Database_GetCitiesById(ctx context.Context, req Database_GetCitiesById_Request, options ...Option) (resp Database_GetCitiesById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getCitiesById", ctx, values, &resp)
	return
}

type Database_GetCountries_Request struct {
	// '1' — to return a full list of all countries, '0' — to return a list of countries near the current user's country (default).
	NeedAll *bool
	// Country codes in [vk.com/dev/country_codes|ISO 3166-1 alpha-2] standard.
	Code *string
	// Offset needed to return a specific subset of countries.
	//  Minimum: 0
	Offset *int
	// Number of countries to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Database_GetCountries_Request) fillIn(values url.Values) (err error) {
	if r.NeedAll != nil {
		setBool(values, "need_all", *r.NeedAll)
	}
	if r.Code != nil {
		setString(values, "code", *r.Code)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetCountries Returns a list of countries.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getCountries
func (vk *VK) Database_GetCountries(ctx context.Context, req Database_GetCountries_Request, options ...Option) (resp Database_GetCountries_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getCountries", ctx, values, &resp)
	return
}

type Database_GetCountriesById_Request struct {
	//  MaxItems: 1000
	//  Minimum: 0
	CountryIds *[]int
}

func (r Database_GetCountriesById_Request) fillIn(values url.Values) (err error) {
	if r.CountryIds != nil {
		setInts(values, "country_ids", *r.CountryIds)
	}
	return
}

// Database_GetCountriesById Returns information about countries by their IDs.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getCountriesById
func (vk *VK) Database_GetCountriesById(ctx context.Context, req Database_GetCountriesById_Request, options ...Option) (resp Database_GetCountriesById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getCountriesById", ctx, values, &resp)
	return
}

type Database_GetFaculties_Request struct {
	// University ID.
	//  Minimum: 0
	UniversityId int
	// Offset needed to return a specific subset of faculties.
	//  Minimum: 0
	Offset *int
	// Number of faculties to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 10000
	Count *int
}

func (r Database_GetFaculties_Request) fillIn(values url.Values) (err error) {
	setInt(values, "university_id", r.UniversityId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetFaculties Returns a list of faculties (i.e., university departments).
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getFaculties
func (vk *VK) Database_GetFaculties(ctx context.Context, req Database_GetFaculties_Request, options ...Option) (resp Database_GetFaculties_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getFaculties", ctx, values, &resp)
	return
}

type Database_GetMetroStations_Request struct {
	//  Minimum: 0
	CityId int
	//  Minimum: 0
	Offset *int
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 500
	Count *int
	//  Default: false
	Extended *bool
}

func (r Database_GetMetroStations_Request) fillIn(values url.Values) (err error) {
	setInt(values, "city_id", r.CityId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Database_GetMetroStations Get metro stations by city
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getMetroStations
func (vk *VK) Database_GetMetroStations(ctx context.Context, req Database_GetMetroStations_Request, options ...Option) (resp Database_GetMetroStations_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getMetroStations", ctx, values, &resp)
	return
}

type Database_GetMetroStationsById_Request struct {
	//  MaxItems: 30
	//  Minimum: 0
	StationIds *[]int
}

func (r Database_GetMetroStationsById_Request) fillIn(values url.Values) (err error) {
	if r.StationIds != nil {
		setInts(values, "station_ids", *r.StationIds)
	}
	return
}

// Database_GetMetroStationsById Get metro station by his id
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getMetroStationsById
func (vk *VK) Database_GetMetroStationsById(ctx context.Context, req Database_GetMetroStationsById_Request, options ...Option) (resp Database_GetMetroStationsById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getMetroStationsById", ctx, values, &resp)
	return
}

type Database_GetRegions_Request struct {
	// Country ID, received in [vk.com/dev/database.getCountries|database.getCountries] method.
	//  Minimum: 0
	CountryId int
	// Search query.
	Q *string
	// Offset needed to return specific subset of regions.
	//  Minimum: 0
	Offset *int
	// Number of regions to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Database_GetRegions_Request) fillIn(values url.Values) (err error) {
	setInt(values, "country_id", r.CountryId)
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetRegions Returns a list of regions.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getRegions
func (vk *VK) Database_GetRegions(ctx context.Context, req Database_GetRegions_Request, options ...Option) (resp Database_GetRegions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getRegions", ctx, values, &resp)
	return
}

type Database_GetSchoolClasses_Request struct {
	// Country ID.
	//  Minimum: 0
	CountryId *int
}

func (r Database_GetSchoolClasses_Request) fillIn(values url.Values) (err error) {
	if r.CountryId != nil {
		setInt(values, "country_id", *r.CountryId)
	}
	return
}

// Database_GetSchoolClasses Returns a list of school classes specified for the country.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getSchoolClasses
func (vk *VK) Database_GetSchoolClasses(ctx context.Context, req Database_GetSchoolClasses_Request, options ...Option) (resp Database_GetSchoolClasses_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getSchoolClasses", ctx, values, &resp)
	return
}

type Database_GetSchools_Request struct {
	// Search query.
	Q *string
	// City ID.
	//  Minimum: 0
	CityId int
	// Offset needed to return a specific subset of schools.
	//  Minimum: 0
	Offset *int
	// Number of schools to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 10000
	Count *int
}

func (r Database_GetSchools_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	setInt(values, "city_id", r.CityId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetSchools Returns a list of schools.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getSchools
func (vk *VK) Database_GetSchools(ctx context.Context, req Database_GetSchools_Request, options ...Option) (resp Database_GetSchools_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getSchools", ctx, values, &resp)
	return
}

type Database_GetUniversities_Request struct {
	// Search query.
	Q *string
	// Country ID.
	//  Minimum: 0
	CountryId *int
	// City ID.
	//  Minimum: 0
	CityId *int
	// Offset needed to return a specific subset of universities.
	//  Minimum: 0
	Offset *int
	// Number of universities to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 10000
	Count *int
}

func (r Database_GetUniversities_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.CountryId != nil {
		setInt(values, "country_id", *r.CountryId)
	}
	if r.CityId != nil {
		setInt(values, "city_id", *r.CityId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Database_GetUniversities Returns a list of higher education institutions.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/database.getUniversities
func (vk *VK) Database_GetUniversities(ctx context.Context, req Database_GetUniversities_Request, options ...Option) (resp Database_GetUniversities_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("database.getUniversities", ctx, values, &resp)
	return
}

type Docs_Add_Request struct {
	// ID of the user or community that owns the document. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
	// Document ID.
	//  Minimum: 0
	DocId int
	// Access key. This parameter is required if 'access_key' was returned with the document's data.
	AccessKey *string
}

func (r Docs_Add_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "doc_id", r.DocId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Docs_Add Copies a document to a user's or community's document list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.add
func (vk *VK) Docs_Add(ctx context.Context, req Docs_Add_Request, options ...Option) (resp Docs_Add_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.add", ctx, values, &resp)
	return
}

type Docs_Delete_Request struct {
	// ID of the user or community that owns the document. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
	// Document ID.
	//  Minimum: 0
	DocId int
}

func (r Docs_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "doc_id", r.DocId)
	return
}

// Docs_Delete Deletes a user or community document.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamDocDeleteAccess, Error_ParamDocId ]
//
// https://dev.vk.com/method/docs.delete
func (vk *VK) Docs_Delete(ctx context.Context, req Docs_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.delete", ctx, values, &resp)
	return
}

type Docs_Edit_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
	// Document ID.
	//  Minimum: 0
	DocId int
	// Document title.
	//  MaxLength: 128
	Title string
	Tags  *[]string
}

func (r Docs_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "doc_id", r.DocId)
	setString(values, "title", r.Title)
	if r.Tags != nil {
		setStrings(values, "tags", *r.Tags)
	}
	return
}

// Docs_Edit Edits a document.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamDocAccess, Error_ParamDocId, Error_ParamDocTitle ]
//
// https://dev.vk.com/method/docs.edit
func (vk *VK) Docs_Edit(ctx context.Context, req Docs_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.edit", ctx, values, &resp)
	return
}

type Docs_Get_Type int

const (
	Docs_Get_Type_All     Docs_Get_Type = 0
	Docs_Get_Type_Text    Docs_Get_Type = 1
	Docs_Get_Type_Archive Docs_Get_Type = 2
	Docs_Get_Type_Gif     Docs_Get_Type = 3
	Docs_Get_Type_Image   Docs_Get_Type = 4
	Docs_Get_Type_Audio   Docs_Get_Type = 5
	Docs_Get_Type_Video   Docs_Get_Type = 6
	Docs_Get_Type_Ebook   Docs_Get_Type = 7
	Docs_Get_Type_Default Docs_Get_Type = 8
)

type Docs_Get_Request struct {
	// Number of documents to return. By default, all documents.
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of documents.
	//  Minimum: 0
	Offset *int
	//  Default: 0
	//  Minimum: 0
	Type *Docs_Get_Type
	// ID of the user or community that owns the documents. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	//  Default: false
	ReturnTags *bool
}

func (r Docs_Get_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Type != nil {
		setInt(values, "type", int(*r.Type))
	}
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.ReturnTags != nil {
		setBool(values, "return_tags", *r.ReturnTags)
	}
	return
}

// Docs_Get Returns detailed information about user or community documents.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.get
func (vk *VK) Docs_Get(ctx context.Context, req Docs_Get_Request, options ...Option) (resp Docs_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.get", ctx, values, &resp)
	return
}

type Docs_GetById_Request struct {
	Docs *[]string
	//  Default: false
	ReturnTags *bool
}

func (r Docs_GetById_Request) fillIn(values url.Values) (err error) {
	if r.Docs != nil {
		setStrings(values, "docs", *r.Docs)
	}
	if r.ReturnTags != nil {
		setBool(values, "return_tags", *r.ReturnTags)
	}
	return
}

// Docs_GetById Returns information about documents by their IDs.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.getById
func (vk *VK) Docs_GetById(ctx context.Context, req Docs_GetById_Request, options ...Option) (resp Docs_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.getById", ctx, values, &resp)
	return
}

type Docs_GetMessagesUploadServer_Type string

const (
	Docs_GetMessagesUploadServer_Type_AudioMessage Docs_GetMessagesUploadServer_Type = "audio_message"
	Docs_GetMessagesUploadServer_Type_Doc          Docs_GetMessagesUploadServer_Type = "doc"
	Docs_GetMessagesUploadServer_Type_Graffiti     Docs_GetMessagesUploadServer_Type = "graffiti"
)

type Docs_GetMessagesUploadServer_Request struct {
	// Document type.
	//  Default: doc
	Type *Docs_GetMessagesUploadServer_Type
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	//  Format: int32
	PeerId *int
}

func (r Docs_GetMessagesUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	return
}

// Docs_GetMessagesUploadServer Returns the server address for document upload.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesDenySend ]
//
// https://dev.vk.com/method/docs.getMessagesUploadServer
func (vk *VK) Docs_GetMessagesUploadServer(ctx context.Context, req Docs_GetMessagesUploadServer_Request, options ...Option) (resp Docs_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.getMessagesUploadServer", ctx, values, &resp)
	return
}

type Docs_GetTypes_Request struct {
	// ID of the user or community that owns the documents. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
}

func (r Docs_GetTypes_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	return
}

// Docs_GetTypes Returns documents types available for current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.getTypes
func (vk *VK) Docs_GetTypes(ctx context.Context, req Docs_GetTypes_Request, options ...Option) (resp Docs_GetTypes_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.getTypes", ctx, values, &resp)
	return
}

type Docs_GetUploadServer_Request struct {
	// Community ID (if the document will be uploaded to the community).
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Docs_GetUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Docs_GetUploadServer Returns the server address for document upload.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.getUploadServer
func (vk *VK) Docs_GetUploadServer(ctx context.Context, req Docs_GetUploadServer_Request, options ...Option) (resp Docs_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.getUploadServer", ctx, values, &resp)
	return
}

type Docs_GetWallUploadServer_Request struct {
	// Community ID (if the document will be uploaded to the community).
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Docs_GetWallUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Docs_GetWallUploadServer Returns the server address for document upload onto a user's or community's wall.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.getWallUploadServer
func (vk *VK) Docs_GetWallUploadServer(ctx context.Context, req Docs_GetWallUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.getWallUploadServer", ctx, values, &resp)
	return
}

type Docs_Save_Request struct {
	// This parameter is returned when the file is [vk.com/dev/upload_files_2|uploaded to the server].
	File string
	// Document title.
	Title *string
	// Document tags.
	Tags *string
	//  Default: false
	ReturnTags *bool
}

func (r Docs_Save_Request) fillIn(values url.Values) (err error) {
	setString(values, "file", r.File)
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Tags != nil {
		setString(values, "tags", *r.Tags)
	}
	if r.ReturnTags != nil {
		setBool(values, "return_tags", *r.ReturnTags)
	}
	return
}

// Docs_Save Saves a document after [vk.com/dev/upload_files_2|uploading it to a server].
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_SaveFile ]
//
// https://dev.vk.com/method/docs.save
func (vk *VK) Docs_Save(ctx context.Context, req Docs_Save_Request, options ...Option) (resp Docs_Save_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.save", ctx, values, &resp)
	return
}

type Docs_Search_Request struct {
	// Search query string.
	//  MaxLength: 512
	Q         string
	SearchOwn *bool
	// Number of results to return.
	//  Default: 20
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset     *int
	ReturnTags *bool
}

func (r Docs_Search_Request) fillIn(values url.Values) (err error) {
	setString(values, "q", r.Q)
	if r.SearchOwn != nil {
		setBool(values, "search_own", *r.SearchOwn)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.ReturnTags != nil {
		setBool(values, "return_tags", *r.ReturnTags)
	}
	return
}

// Docs_Search Returns a list of documents matching the search criteria.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/docs.search
func (vk *VK) Docs_Search(ctx context.Context, req Docs_Search_Request, options ...Option) (resp Docs_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("docs.search", ctx, values, &resp)
	return
}

type Donut_GetFriends_Request struct {
	//  Format: int64
	OwnerId int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 100
	Count  *int
	Fields *[]string
}

func (r Donut_GetFriends_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	return
}

// Donut_GetFriends ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/donut.getFriends
func (vk *VK) Donut_GetFriends(ctx context.Context, req Donut_GetFriends_Request, options ...Option) (resp Groups_GetMembersFields_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("donut.getFriends", ctx, values, &resp)
	return
}

type Donut_GetSubscription_Request struct {
	//  Format: int64
	OwnerId int
}

func (r Donut_GetSubscription_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	return
}

// Donut_GetSubscription ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/donut.getSubscription
func (vk *VK) Donut_GetSubscription(ctx context.Context, req Donut_GetSubscription_Request, options ...Option) (resp Donut_GetSubscription_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("donut.getSubscription", ctx, values, &resp)
	return
}

type Donut_GetSubscriptions_Request struct {
	Fields *[]Base_UserGroupFields
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r Donut_GetSubscriptions_Request) fillIn(values url.Values) (err error) {
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Donut_GetSubscriptions Returns a list of user's VK Donut subscriptions.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/donut.getSubscriptions
func (vk *VK) Donut_GetSubscriptions(ctx context.Context, req Donut_GetSubscriptions_Request, options ...Option) (resp Donut_GetSubscriptions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("donut.getSubscriptions", ctx, values, &resp)
	return
}

type Donut_IsDon_Request struct {
	//  Format: int64
	OwnerId int
}

func (r Donut_IsDon_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	return
}

// Donut_IsDon ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/donut.isDon
func (vk *VK) Donut_IsDon(ctx context.Context, req Donut_IsDon_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("donut.isDon", ctx, values, &resp)
	return
}

type DownloadedGames_GetPaidStatus_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r DownloadedGames_GetPaidStatus_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// DownloadedGames_GetPaidStatus ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ActionFailed, Error_NotFound ]
//
// https://dev.vk.com/method/downloadedGames.getPaidStatus
func (vk *VK) DownloadedGames_GetPaidStatus(ctx context.Context, req DownloadedGames_GetPaidStatus_Request, options ...Option) (resp DownloadedGames_PaidStatus_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("downloadedGames.getPaidStatus", ctx, values, &resp)
	return
}

type Fave_AddArticle_Request struct {
	Url string
}

func (r Fave_AddArticle_Request) fillIn(values url.Values) (err error) {
	setString(values, "url", r.Url)
	return
}

// Fave_AddArticle ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/fave.addArticle
func (vk *VK) Fave_AddArticle(ctx context.Context, req Fave_AddArticle_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addArticle", ctx, values, &resp)
	return
}

type Fave_AddLink_Request struct {
	// Link URL.
	Link string
}

func (r Fave_AddLink_Request) fillIn(values url.Values) (err error) {
	setString(values, "link", r.Link)
	return
}

// Fave_AddLink Adds a link to user faves.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.addLink
func (vk *VK) Fave_AddLink(ctx context.Context, req Fave_AddLink_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addLink", ctx, values, &resp)
	return
}

type Fave_AddPage_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Fave_AddPage_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Fave_AddPage ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.addPage
func (vk *VK) Fave_AddPage(ctx context.Context, req Fave_AddPage_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addPage", ctx, values, &resp)
	return
}

type Fave_AddPost_Request struct {
	//  Format: int64
	OwnerId   int
	Id        int
	AccessKey *string
}

func (r Fave_AddPost_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Fave_AddPost ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.addPost
func (vk *VK) Fave_AddPost(ctx context.Context, req Fave_AddPost_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addPost", ctx, values, &resp)
	return
}

type Fave_AddProduct_Request struct {
	//  Format: int64
	OwnerId   int
	Id        int
	AccessKey *string
}

func (r Fave_AddProduct_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Fave_AddProduct ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.addProduct
func (vk *VK) Fave_AddProduct(ctx context.Context, req Fave_AddProduct_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addProduct", ctx, values, &resp)
	return
}

type Fave_AddTag_Position string

const (
	Fave_AddTag_Position_Back  Fave_AddTag_Position = "back"
	Fave_AddTag_Position_Front Fave_AddTag_Position = "front"
)

type Fave_AddTag_Request struct {
	//  MaxLength: 50
	Name *string
	//  Default: back
	Position *Fave_AddTag_Position
}

func (r Fave_AddTag_Request) fillIn(values url.Values) (err error) {
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	if r.Position != nil {
		setString(values, "position", string(*r.Position))
	}
	return
}

// Fave_AddTag ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits ]
//
// https://dev.vk.com/method/fave.addTag
func (vk *VK) Fave_AddTag(ctx context.Context, req Fave_AddTag_Request, options ...Option) (resp Fave_AddTag_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addTag", ctx, values, &resp)
	return
}

type Fave_AddVideo_Request struct {
	//  Format: int64
	OwnerId   int
	Id        int
	AccessKey *string
}

func (r Fave_AddVideo_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Fave_AddVideo ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.addVideo
func (vk *VK) Fave_AddVideo(ctx context.Context, req Fave_AddVideo_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.addVideo", ctx, values, &resp)
	return
}

type Fave_EditTag_Request struct {
	Id int
	//  MaxLength: 50
	Name string
}

func (r Fave_EditTag_Request) fillIn(values url.Values) (err error) {
	setInt(values, "id", r.Id)
	setString(values, "name", r.Name)
	return
}

// Fave_EditTag ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.editTag
func (vk *VK) Fave_EditTag(ctx context.Context, req Fave_EditTag_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.editTag", ctx, values, &resp)
	return
}

type Fave_Get_ItemType string

const (
	Fave_Get_ItemType_Article      Fave_Get_ItemType = "article"
	Fave_Get_ItemType_Clip         Fave_Get_ItemType = "clip"
	Fave_Get_ItemType_Link         Fave_Get_ItemType = "link"
	Fave_Get_ItemType_Narrative    Fave_Get_ItemType = "narrative"
	Fave_Get_ItemType_Page         Fave_Get_ItemType = "page"
	Fave_Get_ItemType_Podcast      Fave_Get_ItemType = "podcast"
	Fave_Get_ItemType_Post         Fave_Get_ItemType = "post"
	Fave_Get_ItemType_Product      Fave_Get_ItemType = "product"
	Fave_Get_ItemType_Video        Fave_Get_ItemType = "video"
	Fave_Get_ItemType_YoulaProduct Fave_Get_ItemType = "youla_product"
)

type Fave_Get_Request struct {
	ItemType *Fave_Get_ItemType
	// Tag ID.
	TagId *int
	// Offset needed to return a specific subset of users.
	//  Minimum: 0
	Offset *int
	// Number of users to return.
	//  Default: 50
	//  Minimum: 1
	//  Maximum: 100
	Count          *int
	Fields         *[]Users_Fields
	IsFromSnackbar *bool
}

func (r Fave_Get_Request) fillIn(values url.Values) (err error) {
	if r.ItemType != nil {
		setString(values, "item_type", string(*r.ItemType))
	}
	if r.TagId != nil {
		setInt(values, "tag_id", *r.TagId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.IsFromSnackbar != nil {
		setBool(values, "is_from_snackbar", *r.IsFromSnackbar)
	}
	return
}

// Fave_Get ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.get
func (vk *VK) Fave_Get(ctx context.Context, req Fave_Get_Request, options ...Option) (resp Fave_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.get", ctx, values, &resp)
	return
}

// Fave_GetExtended ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.get
func (vk *VK) Fave_GetExtended(ctx context.Context, req Fave_Get_Request, options ...Option) (resp Fave_GetExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.get", ctx, values, &resp)
	return
}

type Fave_GetPages_Type string

const (
	Fave_GetPages_Type_Groups Fave_GetPages_Type = "groups"
	Fave_GetPages_Type_Hints  Fave_GetPages_Type = "hints"
	Fave_GetPages_Type_Users  Fave_GetPages_Type = "users"
)

type Fave_GetPages_Request struct {
	//  Minimum: 0
	//  Maximum: 10000
	Offset *int
	//  Default: 50
	//  Minimum: 1
	//  Maximum: 500
	Count  *int
	Type   *Fave_GetPages_Type
	Fields *[]Base_UserGroupFields
	TagId  *int
}

func (r Fave_GetPages_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.TagId != nil {
		setInt(values, "tag_id", *r.TagId)
	}
	return
}

// Fave_GetPages ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.getPages
func (vk *VK) Fave_GetPages(ctx context.Context, req Fave_GetPages_Request, options ...Option) (resp Fave_GetPages_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.getPages", ctx, values, &resp)
	return
}

// Fave_GetTags ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.getTags
func (vk *VK) Fave_GetTags(ctx context.Context, options ...Option) (resp Fave_GetTags_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.getTags", ctx, values, &resp)
	return
}

// Fave_MarkSeen ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.markSeen
func (vk *VK) Fave_MarkSeen(ctx context.Context, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.markSeen", ctx, values, &resp)
	return
}

type Fave_RemoveArticle_Request struct {
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	ArticleId int
}

func (r Fave_RemoveArticle_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "article_id", r.ArticleId)
	return
}

// Fave_RemoveArticle ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removeArticle
func (vk *VK) Fave_RemoveArticle(ctx context.Context, req Fave_RemoveArticle_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removeArticle", ctx, values, &resp)
	return
}

type Fave_RemoveLink_Request struct {
	// Link ID (can be obtained by [vk.com/dev/faves.getLinks|faves.getLinks] method).
	LinkId *string
	// Link URL
	Link *string
}

func (r Fave_RemoveLink_Request) fillIn(values url.Values) (err error) {
	if r.LinkId != nil {
		setString(values, "link_id", *r.LinkId)
	}
	if r.Link != nil {
		setString(values, "link", *r.Link)
	}
	return
}

// Fave_RemoveLink Removes link from the user's faves.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removeLink
func (vk *VK) Fave_RemoveLink(ctx context.Context, req Fave_RemoveLink_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removeLink", ctx, values, &resp)
	return
}

type Fave_RemovePage_Request struct {
	//  Format: int64
	UserId *int
	//  Format: int64
	GroupId *int
}

func (r Fave_RemovePage_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Fave_RemovePage ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removePage
func (vk *VK) Fave_RemovePage(ctx context.Context, req Fave_RemovePage_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removePage", ctx, values, &resp)
	return
}

type Fave_RemovePost_Request struct {
	//  Format: int64
	OwnerId int
	Id      int
}

func (r Fave_RemovePost_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	return
}

// Fave_RemovePost ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removePost
func (vk *VK) Fave_RemovePost(ctx context.Context, req Fave_RemovePost_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removePost", ctx, values, &resp)
	return
}

type Fave_RemoveProduct_Request struct {
	//  Format: int64
	OwnerId int
	Id      int
}

func (r Fave_RemoveProduct_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	return
}

// Fave_RemoveProduct ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removeProduct
func (vk *VK) Fave_RemoveProduct(ctx context.Context, req Fave_RemoveProduct_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removeProduct", ctx, values, &resp)
	return
}

type Fave_RemoveTag_Request struct {
	Id int
}

func (r Fave_RemoveTag_Request) fillIn(values url.Values) (err error) {
	setInt(values, "id", r.Id)
	return
}

// Fave_RemoveTag ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removeTag
func (vk *VK) Fave_RemoveTag(ctx context.Context, req Fave_RemoveTag_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removeTag", ctx, values, &resp)
	return
}

type Fave_RemoveVideo_Request struct {
	//  Format: int64
	OwnerId int
	Id      int
}

func (r Fave_RemoveVideo_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "id", r.Id)
	return
}

// Fave_RemoveVideo ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.removeVideo
func (vk *VK) Fave_RemoveVideo(ctx context.Context, req Fave_RemoveVideo_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.removeVideo", ctx, values, &resp)
	return
}

type Fave_ReorderTags_Request struct {
	Ids *[]int
}

func (r Fave_ReorderTags_Request) fillIn(values url.Values) (err error) {
	if r.Ids != nil {
		setInts(values, "ids", *r.Ids)
	}
	return
}

// Fave_ReorderTags ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.reorderTags
func (vk *VK) Fave_ReorderTags(ctx context.Context, req Fave_ReorderTags_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.reorderTags", ctx, values, &resp)
	return
}

type Fave_SetPageTags_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	TagIds  *[]int
}

func (r Fave_SetPageTags_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.TagIds != nil {
		setInts(values, "tag_ids", *r.TagIds)
	}
	return
}

// Fave_SetPageTags ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/fave.setPageTags
func (vk *VK) Fave_SetPageTags(ctx context.Context, req Fave_SetPageTags_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.setPageTags", ctx, values, &resp)
	return
}

type Fave_SetTags_ItemType string

const (
	Fave_SetTags_ItemType_Article      Fave_SetTags_ItemType = "article"
	Fave_SetTags_ItemType_Clip         Fave_SetTags_ItemType = "clip"
	Fave_SetTags_ItemType_Link         Fave_SetTags_ItemType = "link"
	Fave_SetTags_ItemType_Narrative    Fave_SetTags_ItemType = "narrative"
	Fave_SetTags_ItemType_Page         Fave_SetTags_ItemType = "page"
	Fave_SetTags_ItemType_Podcast      Fave_SetTags_ItemType = "podcast"
	Fave_SetTags_ItemType_Post         Fave_SetTags_ItemType = "post"
	Fave_SetTags_ItemType_Product      Fave_SetTags_ItemType = "product"
	Fave_SetTags_ItemType_Video        Fave_SetTags_ItemType = "video"
	Fave_SetTags_ItemType_YoulaProduct Fave_SetTags_ItemType = "youla_product"
)

type Fave_SetTags_Request struct {
	ItemType *Fave_SetTags_ItemType
	//  Format: int64
	ItemOwnerId *int
	ItemId      *int
	TagIds      *[]int
	LinkId      *string
	LinkUrl     *string
}

func (r Fave_SetTags_Request) fillIn(values url.Values) (err error) {
	if r.ItemType != nil {
		setString(values, "item_type", string(*r.ItemType))
	}
	if r.ItemOwnerId != nil {
		setInt(values, "item_owner_id", *r.ItemOwnerId)
	}
	if r.ItemId != nil {
		setInt(values, "item_id", *r.ItemId)
	}
	if r.TagIds != nil {
		setInts(values, "tag_ids", *r.TagIds)
	}
	if r.LinkId != nil {
		setString(values, "link_id", *r.LinkId)
	}
	if r.LinkUrl != nil {
		setString(values, "link_url", *r.LinkUrl)
	}
	return
}

// Fave_SetTags ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound, Error_FaveAliexpressTag ]
//
// https://dev.vk.com/method/fave.setTags
func (vk *VK) Fave_SetTags(ctx context.Context, req Fave_SetTags_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.setTags", ctx, values, &resp)
	return
}

type Fave_TrackPageInteraction_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Fave_TrackPageInteraction_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Fave_TrackPageInteraction ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/fave.trackPageInteraction
func (vk *VK) Fave_TrackPageInteraction(ctx context.Context, req Fave_TrackPageInteraction_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("fave.trackPageInteraction", ctx, values, &resp)
	return
}

type Friends_Add_Request struct {
	// ID of the user whose friend request will be approved or to whom a friend request will be sent.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Text of the message (up to 500 characters) for the friend request, if any.
	Text *string
	// '1' to pass an incoming request to followers list.
	Follow *bool
}

func (r Friends_Add_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	if r.Follow != nil {
		setBool(values, "follow", *r.Follow)
	}
	return
}

// Friends_Add Approves or creates a friend request.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_FriendsAddInEnemy, Error_FriendsAddEnemy, Error_FriendsAddYourself, Error_FriendsAddNotFound ]
//
// https://dev.vk.com/method/friends.add
func (vk *VK) Friends_Add(ctx context.Context, req Friends_Add_Request, options ...Option) (resp Friends_Add_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.add", ctx, values, &resp)
	return
}

type Friends_AddList_Request struct {
	// Name of the friend list.
	Name string
	//  Format: int64
	//  Minimum: 0
	UserIds *[]int
}

func (r Friends_AddList_Request) fillIn(values url.Values) (err error) {
	setString(values, "name", r.Name)
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	return
}

// Friends_AddList Creates a new friend list for the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_FriendsListLimit ]
//
// https://dev.vk.com/method/friends.addList
func (vk *VK) Friends_AddList(ctx context.Context, req Friends_AddList_Request, options ...Option) (resp Friends_AddList_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.addList", ctx, values, &resp)
	return
}

type Friends_AreFriends_Request struct {
	//  Format: int64
	//  MaxItems: 1000
	UserIds *[]int
	// '1' — to return 'sign' field. 'sign' is md5("{id}_{user_id}_{friends_status}_{application_secret}"), where id is current user ID. This field allows to check that data has not been modified by the client. By default: '0'.
	NeedSign *bool
}

func (r Friends_AreFriends_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.NeedSign != nil {
		setBool(values, "need_sign", *r.NeedSign)
	}
	return
}

// Friends_AreFriends Checks the current user's friendship status with other specified users.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.areFriends
func (vk *VK) Friends_AreFriends(ctx context.Context, req Friends_AreFriends_Request, options ...Option) (resp Friends_AreFriends_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.areFriends", ctx, values, &resp)
	return
}

// Friends_AreFriendsExtended Checks the current user's friendship status with other specified users.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.areFriends
func (vk *VK) Friends_AreFriendsExtended(ctx context.Context, req Friends_AreFriends_Request, options ...Option) (resp Friends_AreFriendsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.areFriends", ctx, values, &resp)
	return
}

type Friends_Delete_Request struct {
	// ID of the user whose friend request is to be declined or who is to be deleted from the current user's friend list.
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Friends_Delete_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Friends_Delete Declines a friend request or deletes a user from the current user's friend list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.delete
func (vk *VK) Friends_Delete(ctx context.Context, req Friends_Delete_Request, options ...Option) (resp Friends_Delete_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.delete", ctx, values, &resp)
	return
}

// Friends_DeleteAllRequests Marks all incoming friend requests as viewed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.deleteAllRequests
func (vk *VK) Friends_DeleteAllRequests(ctx context.Context, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.deleteAllRequests", ctx, values, &resp)
	return
}

type Friends_DeleteList_Request struct {
	// ID of the friend list to delete.
	//  Minimum: 0
	//  Maximum: 24
	ListId int
}

func (r Friends_DeleteList_Request) fillIn(values url.Values) (err error) {
	setInt(values, "list_id", r.ListId)
	return
}

// Friends_DeleteList Deletes a friend list of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_FriendsListId ]
//
// https://dev.vk.com/method/friends.deleteList
func (vk *VK) Friends_DeleteList(ctx context.Context, req Friends_DeleteList_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.deleteList", ctx, values, &resp)
	return
}

type Friends_Edit_Request struct {
	// ID of the user whose friend list is to be edited.
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  Minimum: 0
	ListIds *[]int
}

func (r Friends_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	if r.ListIds != nil {
		setInts(values, "list_ids", *r.ListIds)
	}
	return
}

// Friends_Edit Edits the friend lists of the selected user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.edit
func (vk *VK) Friends_Edit(ctx context.Context, req Friends_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.edit", ctx, values, &resp)
	return
}

type Friends_EditList_Request struct {
	// Name of the friend list.
	Name *string
	// Friend list ID.
	//  Minimum: 0
	ListId int
	//  Format: int64
	//  Minimum: 0
	UserIds *[]int
	//  Format: int64
	//  Minimum: 0
	AddUserIds *[]int
	//  Format: int64
	//  Minimum: 0
	DeleteUserIds *[]int
}

func (r Friends_EditList_Request) fillIn(values url.Values) (err error) {
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	setInt(values, "list_id", r.ListId)
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.AddUserIds != nil {
		setInts(values, "add_user_ids", *r.AddUserIds)
	}
	if r.DeleteUserIds != nil {
		setInts(values, "delete_user_ids", *r.DeleteUserIds)
	}
	return
}

// Friends_EditList Edits a friend list of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_FriendsListId ]
//
// https://dev.vk.com/method/friends.editList
func (vk *VK) Friends_EditList(ctx context.Context, req Friends_EditList_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.editList", ctx, values, &resp)
	return
}

type Friends_Get_Order string

const (
	Friends_Get_Order_Hints  Friends_Get_Order = "hints"
	Friends_Get_Order_Random Friends_Get_Order = "random"
	Friends_Get_Order_Mobile Friends_Get_Order = "mobile"
	Friends_Get_Order_Name   Friends_Get_Order = "name"
	Friends_Get_Order_Smart  Friends_Get_Order = "smart"
)

type Friends_Get_NameCase string

const (
	Friends_Get_NameCase_Nominative    Friends_Get_NameCase = "nom"
	Friends_Get_NameCase_Genitive      Friends_Get_NameCase = "gen"
	Friends_Get_NameCase_Dative        Friends_Get_NameCase = "dat"
	Friends_Get_NameCase_Accusative    Friends_Get_NameCase = "acc"
	Friends_Get_NameCase_Instrumental  Friends_Get_NameCase = "ins"
	Friends_Get_NameCase_Prepositional Friends_Get_NameCase = "abl"
)

type Friends_Get_Request struct {
	// User ID. By default, the current user ID.
	//  Format: int64
	UserId *int
	// Sort order: , 'name' — by name (enabled only if the 'fields' parameter is used), 'hints' — by rating, similar to how friends are sorted in My friends section, , This parameter is available only for [vk.com/dev/standalone|desktop applications].
	Order *Friends_Get_Order
	// ID of the friend list returned by the [vk.com/dev/friends.getLists|friends.getLists] method to be used as the source. This parameter is taken into account only when the uid parameter is set to the current user ID. This parameter is available only for [vk.com/dev/standalone|desktop applications].
	//  Minimum: 0
	ListId *int
	// Number of friends to return.
	//  Default: 5000
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of friends.
	//  Minimum: 0
	Offset *int
	Fields *[]Users_Fields
	// Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Friends_Get_NameCase
	//  MaxLength: 255
	Ref *string
}

func (r Friends_Get_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Order != nil {
		setString(values, "order", string(*r.Order))
	}
	if r.ListId != nil {
		setInt(values, "list_id", *r.ListId)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	if r.Ref != nil {
		setString(values, "ref", *r.Ref)
	}
	return
}

// Friends_Get Returns a list of user IDs or detailed information about a user's friends.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.get
func (vk *VK) Friends_Get(ctx context.Context, req Friends_Get_Request, options ...Option) (resp Friends_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.get", ctx, values, &resp)
	return
}

// Friends_GetAppUsers Returns a list of IDs of the current user's friends who installed the application.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getAppUsers
func (vk *VK) Friends_GetAppUsers(ctx context.Context, options ...Option) (resp Friends_GetAppUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getAppUsers", ctx, values, &resp)
	return
}

type Friends_GetByPhones_Request struct {
	Phones *[]string
	Fields *[]Users_Fields
}

func (r Friends_GetByPhones_Request) fillIn(values url.Values) (err error) {
	if r.Phones != nil {
		setStrings(values, "phones", *r.Phones)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Friends_GetByPhones Returns a list of the current user's friends whose phone numbers, validated or specified in a profile, are in a given list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getByPhones
func (vk *VK) Friends_GetByPhones(ctx context.Context, req Friends_GetByPhones_Request, options ...Option) (resp Friends_GetByPhones_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getByPhones", ctx, values, &resp)
	return
}

type Friends_GetLists_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// '1' — to return system friend lists. By default: '0'.
	ReturnSystem *bool
}

func (r Friends_GetLists_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.ReturnSystem != nil {
		setBool(values, "return_system", *r.ReturnSystem)
	}
	return
}

// Friends_GetLists Returns a list of the user's friend lists.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getLists
func (vk *VK) Friends_GetLists(ctx context.Context, req Friends_GetLists_Request, options ...Option) (resp Friends_GetLists_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getLists", ctx, values, &resp)
	return
}

type Friends_GetMutual_Request struct {
	// ID of the user whose friends will be checked against the friends of the user specified in 'target_uid'.
	//  Format: int64
	//  Minimum: 0
	SourceUid *int
	// ID of the user whose friends will be checked against the friends of the user specified in 'source_uid'.
	//  Format: int64
	//  Minimum: 0
	TargetUid *int
	// Sort order: 'random' — random order
	Order *string
	// Number of mutual friends to return.
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of mutual friends.
	//  Minimum: 0
	Offset *int
}

func (r Friends_GetMutual_Request) fillIn(values url.Values) (err error) {
	if r.SourceUid != nil {
		setInt(values, "source_uid", *r.SourceUid)
	}
	if r.TargetUid != nil {
		setInt(values, "target_uid", *r.TargetUid)
	}
	if r.Order != nil {
		setString(values, "order", *r.Order)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Friends_GetMutual Returns a list of user IDs of the mutual friends of two users.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getMutual
func (vk *VK) Friends_GetMutual(ctx context.Context, req Friends_GetMutual_Request, options ...Option) (resp Friends_GetMutual_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getMutual", ctx, values, &resp)
	return
}

type Friends_GetMutualTargetUIDs_Request struct {
	// ID of the user whose friends will be checked against the friends of the user specified in 'target_uid'.
	//  Format: int64
	//  Minimum: 0
	SourceUid *int
	//  Format: int64
	//  MaxItems: 100
	//  Minimum: 0
	TargetUids *[]int
	// Sort order: 'random' — random order
	Order *string
	// Number of mutual friends to return.
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of mutual friends.
	//  Minimum: 0
	Offset *int
}

func (r Friends_GetMutualTargetUIDs_Request) fillIn(values url.Values) (err error) {
	if r.SourceUid != nil {
		setInt(values, "source_uid", *r.SourceUid)
	}
	if r.TargetUids != nil {
		setInts(values, "target_uids", *r.TargetUids)
	}
	if r.Order != nil {
		setString(values, "order", *r.Order)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Friends_GetMutualTargetUIDs Returns a list of user IDs of the mutual friends of two users.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getMutual
func (vk *VK) Friends_GetMutualTargetUIDs(ctx context.Context, req Friends_GetMutualTargetUIDs_Request, options ...Option) (resp Friends_GetMutualTargetUids_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getMutual", ctx, values, &resp)
	return
}

type Friends_GetOnline_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Friend list ID. If this parameter is not set, information about all online friends is returned.
	//  Minimum: 0
	ListId *int
	// Sort order: 'random' — random order
	Order *string
	// Number of friends to return.
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of friends.
	//  Minimum: 0
	Offset *int
}

func (r Friends_GetOnline_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.ListId != nil {
		setInt(values, "list_id", *r.ListId)
	}
	if r.Order != nil {
		setString(values, "order", *r.Order)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Friends_GetOnline Returns a list of user IDs of a user's friends who are online.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getOnline
func (vk *VK) Friends_GetOnline(ctx context.Context, req Friends_GetOnline_Request, options ...Option) (resp Friends_GetOnline_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "online_mobile", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getOnline", ctx, values, &resp)
	return
}

// Friends_GetOnlineOnlineMobile Returns a list of user IDs of a user's friends who are online.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getOnline
func (vk *VK) Friends_GetOnlineOnlineMobile(ctx context.Context, req Friends_GetOnline_Request, options ...Option) (resp Friends_GetOnlineOnlineMobile_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "online_mobile", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getOnline", ctx, values, &resp)
	return
}

type Friends_GetRecent_Request struct {
	// Number of recently added friends to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Friends_GetRecent_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Friends_GetRecent Returns a list of user IDs of the current user's recently added friends.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getRecent
func (vk *VK) Friends_GetRecent(ctx context.Context, req Friends_GetRecent_Request, options ...Option) (resp Friends_GetRecent_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getRecent", ctx, values, &resp)
	return
}

type Friends_GetRequests_Sort int

const (
	Friends_GetRequests_Sort_Date   Friends_GetRequests_Sort = 0
	Friends_GetRequests_Sort_Mutual Friends_GetRequests_Sort = 1
	Friends_GetRequests_Sort_Rotate Friends_GetRequests_Sort = 2
)

type Friends_GetRequests_Request struct {
	// Offset needed to return a specific subset of friend requests.
	//  Minimum: 0
	Offset *int
	// Number of friend requests to return (default 100, maximum 1000).
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// '1' — to return a list of mutual friends (up to 20), if any
	NeedMutual *bool
	// '1' — to return outgoing requests, '0' — to return incoming requests (default)
	Out *bool
	// Sort order: '1' — by number of mutual friends, '0' — by date
	//  Minimum: 0
	Sort *Friends_GetRequests_Sort
	//  Default: 0
	NeedViewed *bool
	// '1' — to return a list of suggested friends, '0' — to return friend requests (default)
	Suggested *bool
	//  MaxLength: 255
	Ref    *string
	Fields *[]Users_Fields
}

func (r Friends_GetRequests_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.NeedMutual != nil {
		setBool(values, "need_mutual", *r.NeedMutual)
	}
	if r.Out != nil {
		setBool(values, "out", *r.Out)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.NeedViewed != nil {
		setBool(values, "need_viewed", *r.NeedViewed)
	}
	if r.Suggested != nil {
		setBool(values, "suggested", *r.Suggested)
	}
	if r.Ref != nil {
		setString(values, "ref", *r.Ref)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Friends_GetRequests Returns information about the current user's incoming and outgoing friend requests.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getRequests
func (vk *VK) Friends_GetRequests(ctx context.Context, req Friends_GetRequests_Request, options ...Option) (resp Friends_GetRequests_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getRequests", ctx, values, &resp)
	return
}

// Friends_GetRequestsExtended Returns information about the current user's incoming and outgoing friend requests.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getRequests
func (vk *VK) Friends_GetRequestsExtended(ctx context.Context, req Friends_GetRequests_Request, options ...Option) (resp Friends_GetRequestsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getRequests", ctx, values, &resp)
	return
}

type Friends_GetSuggestions_Filter string

const (
	Friends_GetSuggestions_Filter_Mutual         Friends_GetSuggestions_Filter = "mutual"
	Friends_GetSuggestions_Filter_Contacts       Friends_GetSuggestions_Filter = "contacts"
	Friends_GetSuggestions_Filter_MutualContacts Friends_GetSuggestions_Filter = "mutual_contacts"
)

type Friends_GetSuggestions_NameCase string

const (
	Friends_GetSuggestions_NameCase_Nominative    Friends_GetSuggestions_NameCase = "nom"
	Friends_GetSuggestions_NameCase_Genitive      Friends_GetSuggestions_NameCase = "gen"
	Friends_GetSuggestions_NameCase_Dative        Friends_GetSuggestions_NameCase = "dat"
	Friends_GetSuggestions_NameCase_Accusative    Friends_GetSuggestions_NameCase = "acc"
	Friends_GetSuggestions_NameCase_Instrumental  Friends_GetSuggestions_NameCase = "ins"
	Friends_GetSuggestions_NameCase_Prepositional Friends_GetSuggestions_NameCase = "abl"
)

type Friends_GetSuggestions_Request struct {
	Filter *[]Friends_GetSuggestions_Filter
	// Number of suggestions to return.
	//  Default: 500
	//  Minimum: 0
	//  Maximum: 500
	Count *int
	// Offset needed to return a specific subset of suggestions.
	//  Minimum: 0
	Offset *int
	Fields *[]Users_Fields
	// Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Friends_GetSuggestions_NameCase
}

func (r Friends_GetSuggestions_Request) fillIn(values url.Values) (err error) {
	if r.Filter != nil {
		vs := make([]string, len(*r.Filter))
		for i, v := range *r.Filter {
			vs[i] = string(v)
		}
		setStrings(values, "filter", vs)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Friends_GetSuggestions Returns a list of profiles of users whom the current user may know.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.getSuggestions
func (vk *VK) Friends_GetSuggestions(ctx context.Context, req Friends_GetSuggestions_Request, options ...Option) (resp Friends_GetSuggestions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.getSuggestions", ctx, values, &resp)
	return
}

type Friends_Search_NameCase string

const (
	Friends_Search_NameCase_Nominative    Friends_Search_NameCase = "Nom"
	Friends_Search_NameCase_Genitive      Friends_Search_NameCase = "Gen"
	Friends_Search_NameCase_Dative        Friends_Search_NameCase = "Dat"
	Friends_Search_NameCase_Accusative    Friends_Search_NameCase = "Acc"
	Friends_Search_NameCase_Instrumental  Friends_Search_NameCase = "Ins"
	Friends_Search_NameCase_Prepositional Friends_Search_NameCase = "Abl"
)

type Friends_Search_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId *int
	// Search query string (e.g., 'Vasya Babich').
	Q      *string
	Fields *[]Users_Fields
	// Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	//  Default: Nom
	NameCase *Friends_Search_NameCase
	// Offset needed to return a specific subset of friends.
	//  Minimum: 0
	Offset *int
	// Number of friends to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Friends_Search_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Friends_Search Returns a list of friends matching the search criteria.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/friends.search
func (vk *VK) Friends_Search(ctx context.Context, req Friends_Search_Request, options ...Option) (resp Friends_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("friends.search", ctx, values, &resp)
	return
}

type Gifts_Get_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Number of gifts to return.
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
}

func (r Gifts_Get_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Gifts_Get Returns a list of user gifts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/gifts.get
func (vk *VK) Gifts_Get(ctx context.Context, req Gifts_Get_Request, options ...Option) (resp Gifts_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("gifts.get", ctx, values, &resp)
	return
}

type Groups_AddAddress_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  MaxLength: 255
	Title string
	//  MaxLength: 255
	Address string
	//  MaxLength: 400
	AdditionalAddress *string
	//  Minimum: 1
	CountryId int
	//  Minimum: 1
	CityId int
	//  Minimum: 0
	MetroId *int
	//  Minimum: -90
	//  Maximum: 90
	Latitude float64
	//  Minimum: -180
	//  Maximum: 180
	Longitude float64
	Phone     *string
	//  Default: no_information
	WorkInfoStatus *Groups_AddressWorkInfoStatus
	Timetable      *string
	IsMainAddress  *bool
}

func (r Groups_AddAddress_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "title", r.Title)
	setString(values, "address", r.Address)
	if r.AdditionalAddress != nil {
		setString(values, "additional_address", *r.AdditionalAddress)
	}
	setInt(values, "country_id", r.CountryId)
	setInt(values, "city_id", r.CityId)
	if r.MetroId != nil {
		setInt(values, "metro_id", *r.MetroId)
	}
	setFloat(values, "latitude", r.Latitude)
	setFloat(values, "longitude", r.Longitude)
	if r.Phone != nil {
		setString(values, "phone", *r.Phone)
	}
	if r.WorkInfoStatus != nil {
		setString(values, "work_info_status", string(*r.WorkInfoStatus))
	}
	if r.Timetable != nil {
		setString(values, "timetable", *r.Timetable)
	}
	if r.IsMainAddress != nil {
		setBool(values, "is_main_address", *r.IsMainAddress)
	}
	return
}

// Groups_AddAddress ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessGroups, Error_NotFound, Error_GroupTooManyAddresses ]
//
// https://dev.vk.com/method/groups.addAddress
func (vk *VK) Groups_AddAddress(ctx context.Context, req Groups_AddAddress_Request, options ...Option) (resp Groups_AddAddress_Response, apiErr ApiError, err error) {
	values := make(url.Values, 15+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.addAddress", ctx, values, &resp)
	return
}

type Groups_AddCallbackServer_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	Url     string
	//  MaxLength: 14
	Title string
	//  MaxLength: 50
	SecretKey *string
}

func (r Groups_AddCallbackServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "url", r.Url)
	setString(values, "title", r.Title)
	if r.SecretKey != nil {
		setString(values, "secret_key", *r.SecretKey)
	}
	return
}

// Groups_AddCallbackServer ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_CallbackApiServersLimit ]
//
// https://dev.vk.com/method/groups.addCallbackServer
func (vk *VK) Groups_AddCallbackServer(ctx context.Context, req Groups_AddCallbackServer_Request, options ...Option) (resp Groups_AddCallbackServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.addCallbackServer", ctx, values, &resp)
	return
}

type Groups_AddLink_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Link URL.
	Link string
	// Description text for the link.
	Text *string
}

func (r Groups_AddLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "link", r.Link)
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	return
}

// Groups_AddLink Allows to add a link to the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.addLink
func (vk *VK) Groups_AddLink(ctx context.Context, req Groups_AddLink_Request, options ...Option) (resp Groups_AddLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.addLink", ctx, values, &resp)
	return
}

type Groups_ApproveRequest_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Groups_ApproveRequest_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	return
}

// Groups_ApproveRequest Allows to approve join request to the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits ]
//
// https://dev.vk.com/method/groups.approveRequest
func (vk *VK) Groups_ApproveRequest(ctx context.Context, req Groups_ApproveRequest_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.approveRequest", ctx, values, &resp)
	return
}

type Groups_Ban_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Format: int64
	OwnerId *int
	//  Minimum: 0
	EndDate *int
	//  Minimum: 0
	Reason         *int
	Comment        *string
	CommentVisible *bool
}

func (r Groups_Ban_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.EndDate != nil {
		setInt(values, "end_date", *r.EndDate)
	}
	if r.Reason != nil {
		setInt(values, "reason", *r.Reason)
	}
	if r.Comment != nil {
		setString(values, "comment", *r.Comment)
	}
	if r.CommentVisible != nil {
		setBool(values, "comment_visible", *r.CommentVisible)
	}
	return
}

// Groups_Ban ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.ban
func (vk *VK) Groups_Ban(ctx context.Context, req Groups_Ban_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.ban", ctx, values, &resp)
	return
}

type Groups_Create_Type string

const (
	Groups_Create_Type_Event  Groups_Create_Type = "event"
	Groups_Create_Type_Group  Groups_Create_Type = "group"
	Groups_Create_Type_Public Groups_Create_Type = "public"
)

type Groups_Create_Subtype int

const (
	Groups_Create_Subtype_PlaceOrBusiness  Groups_Create_Subtype = 1
	Groups_Create_Subtype_CompanyOrWebsite Groups_Create_Subtype = 2
	Groups_Create_Subtype_PersonOrGroup    Groups_Create_Subtype = 3
	Groups_Create_Subtype_ProductOrArt     Groups_Create_Subtype = 4
)

type Groups_Create_Request struct {
	// Community title.
	Title string
	// Community description (ignored for 'type' = 'public').
	Description *string
	// Community type. Possible values: *'group' - group,, *'event' - event,, *'public' - public page
	//  Default: group
	Type *Groups_Create_Type
	// Category ID (for 'type' = 'public' only).
	//  Minimum: 0
	PublicCategory *int
	// Public page subcategory ID.
	//  Minimum: 0
	PublicSubcategory *int
	// Public page subtype. Possible values: *'1' - place or small business,, *'2' - company, organization or website,, *'3' - famous person or group of people,, *'4' - product or work of art.
	//  Minimum: 0
	Subtype *Groups_Create_Subtype
}

func (r Groups_Create_Request) fillIn(values url.Values) (err error) {
	setString(values, "title", r.Title)
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.PublicCategory != nil {
		setInt(values, "public_category", *r.PublicCategory)
	}
	if r.PublicSubcategory != nil {
		setInt(values, "public_subcategory", *r.PublicSubcategory)
	}
	if r.Subtype != nil {
		setInt(values, "subtype", int(*r.Subtype))
	}
	return
}

// Groups_Create Creates a new community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits ]
//
// https://dev.vk.com/method/groups.create
func (vk *VK) Groups_Create(ctx context.Context, req Groups_Create_Request, options ...Option) (resp Groups_Create_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.create", ctx, values, &resp)
	return
}

type Groups_DeleteAddress_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	AddressId int
}

func (r Groups_DeleteAddress_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "address_id", r.AddressId)
	return
}

// Groups_DeleteAddress ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessGroups, Error_NotFound ]
//
// https://dev.vk.com/method/groups.deleteAddress
func (vk *VK) Groups_DeleteAddress(ctx context.Context, req Groups_DeleteAddress_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.deleteAddress", ctx, values, &resp)
	return
}

type Groups_DeleteCallbackServer_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	ServerId int
}

func (r Groups_DeleteCallbackServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "server_id", r.ServerId)
	return
}

// Groups_DeleteCallbackServer ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/groups.deleteCallbackServer
func (vk *VK) Groups_DeleteCallbackServer(ctx context.Context, req Groups_DeleteCallbackServer_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.deleteCallbackServer", ctx, values, &resp)
	return
}

type Groups_DeleteLink_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Link ID.
	//  Minimum: 0
	LinkId int
}

func (r Groups_DeleteLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "link_id", r.LinkId)
	return
}

// Groups_DeleteLink Allows to delete a link from the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.deleteLink
func (vk *VK) Groups_DeleteLink(ctx context.Context, req Groups_DeleteLink_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.deleteLink", ctx, values, &resp)
	return
}

type Groups_DisableOnline_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_DisableOnline_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_DisableOnline ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.disableOnline
func (vk *VK) Groups_DisableOnline(ctx context.Context, req Groups_DisableOnline_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.disableOnline", ctx, values, &resp)
	return
}

type Groups_Edit_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Community title.
	Title *string
	// Community description.
	Description *string
	// Community screen name.
	ScreenName *string
	// Community type. Possible values: *'0' - open,, *'1' - closed,, *'2' - private.
	//  Minimum: 0
	Access *Groups_GroupAccess
	// Website that will be displayed in the community information field.
	Website *string
	// Community subject. Possible values: , *'1' - auto/moto,, *'2' - activity holidays,, *'3' - business,, *'4' - pets,, *'5' - health,, *'6' - dating and communication, , *'7' - games,, *'8' - IT (computers and software),, *'9' - cinema,, *'10' - beauty and fashion,, *'11' - cooking,, *'12' - art and culture,, *'13' - literature,, *'14' - mobile services and internet,, *'15' - music,, *'16' - science and technology,, *'17' - real estate,, *'18' - news and media,, *'19' - security,, *'20' - education,, *'21' - home and renovations,, *'22' - politics,, *'23' - food,, *'24' - industry,, *'25' - travel,, *'26' - work,, *'27' - entertainment,, *'28' - religion,, *'29' - family,, *'30' - sports,, *'31' - insurance,, *'32' - television,, *'33' - goods and services,, *'34' - hobbies,, *'35' - finance,, *'36' - photo,, *'37' - esoterics,, *'38' - electronics and appliances,, *'39' - erotic,, *'40' - humor,, *'41' - society, humanities,, *'42' - design and graphics.
	Subject *Groups_GroupSubject
	// Organizer email (for events).
	Email *string
	// Organizer phone number (for events).
	Phone *string
	// RSS feed address for import (available only to communities with special permission. Contact vk.com/support to get it.
	Rss *string
	// Event start date in Unixtime format.
	//  Minimum: 0
	EventStartDate *int
	// Event finish date in Unixtime format.
	//  Minimum: 0
	EventFinishDate *int
	// Organizer community ID (for events only).
	//  Format: int64
	//  Minimum: 0
	EventGroupId *int
	// Public page category ID.
	//  Minimum: 0
	PublicCategory *int
	// Public page subcategory ID.
	//  Minimum: 0
	PublicSubcategory *int
	// Founding date of a company or organization owning the community in "dd.mm.YYYY" format.
	PublicDate *string
	// Wall settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (groups and events only),, *'3' - closed (groups and events only).
	//  Minimum: 0
	Wall *Groups_GroupWall
	// Board topics settings. Possbile values: , *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Topics *Groups_GroupTopics
	// Photos settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Photos *Groups_GroupPhotos
	// Video settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Video *Groups_GroupVideo
	// Audio settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Audio *Groups_GroupAudio
	// Links settings (for public pages only). Possible values: *'0' - disabled,, *'1' - enabled.
	Links *bool
	// Events settings (for public pages only). Possible values: *'0' - disabled,, *'1' - enabled.
	Events *bool
	// Places settings (for public pages only). Possible values: *'0' - disabled,, *'1' - enabled.
	Places *bool
	// Contacts settings (for public pages only). Possible values: *'0' - disabled,, *'1' - enabled.
	Contacts *bool
	// Documents settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Docs *Groups_GroupDocs
	// Wiki pages settings. Possible values: *'0' - disabled,, *'1' - open,, *'2' - limited (for groups and events only).
	//  Minimum: 0
	Wiki *Groups_GroupWiki
	// Community messages. Possible values: *'0' — disabled,, *'1' — enabled.
	Messages  *bool
	Articles  *bool
	Addresses *bool
	// Community age limits. Possible values: *'1' — no limits,, *'2' — 16+,, *'3' — 18+.
	//  Default: 1
	//  Minimum: 0
	AgeLimits *Groups_GroupAgeLimits
	// Market settings. Possible values: *'0' - disabled,, *'1' - enabled.
	Market *bool
	// market comments settings. Possible values: *'0' - disabled,, *'1' - enabled.
	MarketComments *bool
	//  MaxItems: 10
	MarketCountry *[]int
	//  MaxItems: 10
	//  Minimum: 0
	MarketCity *[]int
	// Market currency settings. Possbile values: , *'643' - Russian rubles,, *'980' - Ukrainian hryvnia,, *'398' - Kazakh tenge,, *'978' - Euro,, *'840' - US dollars
	//  Minimum: 0
	MarketCurrency *Groups_GroupMarketCurrency
	// Seller contact for market. Set '0' for community messages.
	//  Minimum: 0
	MarketContact *int
	// ID of a wiki page with market description.
	//  Minimum: 0
	MarketWiki *int
	// Obscene expressions filter in comments. Possible values: , *'0' - disabled,, *'1' - enabled.
	ObsceneFilter *bool
	// Stopwords filter in comments. Possible values: , *'0' - disabled,, *'1' - enabled.
	ObsceneStopwords *bool
	ObsceneWords     *[]string
	//  Minimum: 0
	MainSection *int
	//  Minimum: 0
	SecondarySection *int
	// Country of the community.
	//  Minimum: 0
	Country *int
	// City of the community.
	//  Minimum: 0
	City *int
}

func (r Groups_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.ScreenName != nil {
		setString(values, "screen_name", *r.ScreenName)
	}
	if r.Access != nil {
		setInt(values, "access", int(*r.Access))
	}
	if r.Website != nil {
		setString(values, "website", *r.Website)
	}
	if r.Subject != nil {
		setInt(values, "subject", int(*r.Subject))
	}
	if r.Email != nil {
		setString(values, "email", *r.Email)
	}
	if r.Phone != nil {
		setString(values, "phone", *r.Phone)
	}
	if r.Rss != nil {
		setString(values, "rss", *r.Rss)
	}
	if r.EventStartDate != nil {
		setInt(values, "event_start_date", *r.EventStartDate)
	}
	if r.EventFinishDate != nil {
		setInt(values, "event_finish_date", *r.EventFinishDate)
	}
	if r.EventGroupId != nil {
		setInt(values, "event_group_id", *r.EventGroupId)
	}
	if r.PublicCategory != nil {
		setInt(values, "public_category", *r.PublicCategory)
	}
	if r.PublicSubcategory != nil {
		setInt(values, "public_subcategory", *r.PublicSubcategory)
	}
	if r.PublicDate != nil {
		setString(values, "public_date", *r.PublicDate)
	}
	if r.Wall != nil {
		setInt(values, "wall", int(*r.Wall))
	}
	if r.Topics != nil {
		setInt(values, "topics", int(*r.Topics))
	}
	if r.Photos != nil {
		setInt(values, "photos", int(*r.Photos))
	}
	if r.Video != nil {
		setInt(values, "video", int(*r.Video))
	}
	if r.Audio != nil {
		setInt(values, "audio", int(*r.Audio))
	}
	if r.Links != nil {
		setBool(values, "links", *r.Links)
	}
	if r.Events != nil {
		setBool(values, "events", *r.Events)
	}
	if r.Places != nil {
		setBool(values, "places", *r.Places)
	}
	if r.Contacts != nil {
		setBool(values, "contacts", *r.Contacts)
	}
	if r.Docs != nil {
		setInt(values, "docs", int(*r.Docs))
	}
	if r.Wiki != nil {
		setInt(values, "wiki", int(*r.Wiki))
	}
	if r.Messages != nil {
		setBool(values, "messages", *r.Messages)
	}
	if r.Articles != nil {
		setBool(values, "articles", *r.Articles)
	}
	if r.Addresses != nil {
		setBool(values, "addresses", *r.Addresses)
	}
	if r.AgeLimits != nil {
		setInt(values, "age_limits", int(*r.AgeLimits))
	}
	if r.Market != nil {
		setBool(values, "market", *r.Market)
	}
	if r.MarketComments != nil {
		setBool(values, "market_comments", *r.MarketComments)
	}
	if r.MarketCountry != nil {
		setInts(values, "market_country", *r.MarketCountry)
	}
	if r.MarketCity != nil {
		setInts(values, "market_city", *r.MarketCity)
	}
	if r.MarketCurrency != nil {
		setInt(values, "market_currency", int(*r.MarketCurrency))
	}
	if r.MarketContact != nil {
		setInt(values, "market_contact", *r.MarketContact)
	}
	if r.MarketWiki != nil {
		setInt(values, "market_wiki", *r.MarketWiki)
	}
	if r.ObsceneFilter != nil {
		setBool(values, "obscene_filter", *r.ObsceneFilter)
	}
	if r.ObsceneStopwords != nil {
		setBool(values, "obscene_stopwords", *r.ObsceneStopwords)
	}
	if r.ObsceneWords != nil {
		setStrings(values, "obscene_words", *r.ObsceneWords)
	}
	if r.MainSection != nil {
		setInt(values, "main_section", *r.MainSection)
	}
	if r.SecondarySection != nil {
		setInt(values, "secondary_section", *r.SecondarySection)
	}
	if r.Country != nil {
		setInt(values, "country", *r.Country)
	}
	if r.City != nil {
		setInt(values, "city", *r.City)
	}
	return
}

// Groups_Edit Edits a community.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_InvalidAddress ]
//
// https://dev.vk.com/method/groups.edit
func (vk *VK) Groups_Edit(ctx context.Context, req Groups_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 47+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.edit", ctx, values, &resp)
	return
}

type Groups_EditAddress_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	AddressId int
	//  MaxLength: 255
	Title *string
	//  MaxLength: 255
	Address *string
	//  MaxLength: 400
	AdditionalAddress *string
	//  Minimum: 0
	CountryId *int
	//  Minimum: 0
	CityId *int
	//  Minimum: 0
	MetroId *int
	//  Minimum: -90
	//  Maximum: 90
	Latitude *float64
	//  Minimum: -180
	//  Maximum: 180
	Longitude      *float64
	Phone          *string
	WorkInfoStatus *Groups_AddressWorkInfoStatus
	Timetable      *string
	IsMainAddress  *bool
}

func (r Groups_EditAddress_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "address_id", r.AddressId)
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Address != nil {
		setString(values, "address", *r.Address)
	}
	if r.AdditionalAddress != nil {
		setString(values, "additional_address", *r.AdditionalAddress)
	}
	if r.CountryId != nil {
		setInt(values, "country_id", *r.CountryId)
	}
	if r.CityId != nil {
		setInt(values, "city_id", *r.CityId)
	}
	if r.MetroId != nil {
		setInt(values, "metro_id", *r.MetroId)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.Phone != nil {
		setString(values, "phone", *r.Phone)
	}
	if r.WorkInfoStatus != nil {
		setString(values, "work_info_status", string(*r.WorkInfoStatus))
	}
	if r.Timetable != nil {
		setString(values, "timetable", *r.Timetable)
	}
	if r.IsMainAddress != nil {
		setBool(values, "is_main_address", *r.IsMainAddress)
	}
	return
}

// Groups_EditAddress ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessGroups, Error_NotFound, Error_GroupTooManyAddresses ]
//
// https://dev.vk.com/method/groups.editAddress
func (vk *VK) Groups_EditAddress(ctx context.Context, req Groups_EditAddress_Request, options ...Option) (resp Groups_EditAddress_Response, apiErr ApiError, err error) {
	values := make(url.Values, 16+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.editAddress", ctx, values, &resp)
	return
}

type Groups_EditCallbackServer_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	ServerId int
	Url      string
	//  MaxLength: 14
	Title string
	//  MaxLength: 50
	SecretKey *string
}

func (r Groups_EditCallbackServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "server_id", r.ServerId)
	setString(values, "url", r.Url)
	setString(values, "title", r.Title)
	if r.SecretKey != nil {
		setString(values, "secret_key", *r.SecretKey)
	}
	return
}

// Groups_EditCallbackServer ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/groups.editCallbackServer
func (vk *VK) Groups_EditCallbackServer(ctx context.Context, req Groups_EditCallbackServer_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.editCallbackServer", ctx, values, &resp)
	return
}

type Groups_EditLink_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Link ID.
	//  Minimum: 0
	LinkId int
	// New description text for the link.
	Text *string
}

func (r Groups_EditLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "link_id", r.LinkId)
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	return
}

// Groups_EditLink Allows to edit a link in the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.editLink
func (vk *VK) Groups_EditLink(ctx context.Context, req Groups_EditLink_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.editLink", ctx, values, &resp)
	return
}

type Groups_EditManager_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId int
	// Manager role. Possible values: *'moderator',, *'editor',, *'administrator',, *'advertiser'.
	Role *Groups_GroupRole
	// '1' — to show the manager in Contacts block of the community.
	IsContact *bool
	// Position to show in Contacts block.
	ContactPosition *string
	// Contact phone.
	ContactPhone *string
	// Contact e-mail.
	ContactEmail *string
}

func (r Groups_EditManager_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	if r.Role != nil {
		setString(values, "role", string(*r.Role))
	}
	if r.IsContact != nil {
		setBool(values, "is_contact", *r.IsContact)
	}
	if r.ContactPosition != nil {
		setString(values, "contact_position", *r.ContactPosition)
	}
	if r.ContactPhone != nil {
		setString(values, "contact_phone", *r.ContactPhone)
	}
	if r.ContactEmail != nil {
		setString(values, "contact_email", *r.ContactEmail)
	}
	return
}

// Groups_EditManager Allows to add, remove or edit the community manager.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_GroupChangeCreator, Error_GroupNotInClub, Error_GroupTooManyOfficers, Error_GroupNeed2fa, Error_GroupHostNeed2fa ]
//
// https://dev.vk.com/method/groups.editManager
func (vk *VK) Groups_EditManager(ctx context.Context, req Groups_EditManager_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.editManager", ctx, values, &resp)
	return
}

type Groups_EnableOnline_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_EnableOnline_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_EnableOnline ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.enableOnline
func (vk *VK) Groups_EnableOnline(ctx context.Context, req Groups_EnableOnline_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.enableOnline", ctx, values, &resp)
	return
}

type Groups_Get_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId *int
	Filter *[]Groups_Filter
	Fields *[]Groups_Fields
	// Offset needed to return a specific subset of communities.
	//  Minimum: 0
	Offset *int
	// Number of communities to return.
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Groups_Get_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Filter != nil {
		vs := make([]string, len(*r.Filter))
		for i, v := range *r.Filter {
			vs[i] = string(v)
		}
		setStrings(values, "filter", vs)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Groups_Get Returns a list of the communities to which a user belongs.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessGroups ]
//
// https://dev.vk.com/method/groups.get
func (vk *VK) Groups_Get(ctx context.Context, req Groups_Get_Request, options ...Option) (resp Groups_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.get", ctx, values, &resp)
	return
}

// Groups_GetExtended Returns a list of the communities to which a user belongs.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessGroups ]
//
// https://dev.vk.com/method/groups.get
func (vk *VK) Groups_GetExtended(ctx context.Context, req Groups_Get_Request, options ...Option) (resp Groups_GetObjectExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.get", ctx, values, &resp)
	return
}

type Groups_GetAddresses_Request struct {
	// ID or screen name of the community.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  MaxItems: 100
	//  Minimum: 0
	AddressIds *[]int
	// Latitude of  the user geo position.
	//  Minimum: -90
	//  Maximum: 90
	Latitude *float64
	// Longitude of the user geo position.
	//  Minimum: -180
	//  Maximum: 180
	Longitude *float64
	// Offset needed to return a specific subset of community addresses.
	//  Minimum: 0
	Offset *int
	// Number of community addresses to return.
	//  Default: 10
	//  Minimum: 0
	Count  *int
	Fields *[]Addresses_Fields
}

func (r Groups_GetAddresses_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.AddressIds != nil {
		setInts(values, "address_ids", *r.AddressIds)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Groups_GetAddresses Returns a list of community addresses.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamGroupId, Error_AccessGroups ]
//
// https://dev.vk.com/method/groups.getAddresses
func (vk *VK) Groups_GetAddresses(ctx context.Context, req Groups_GetAddresses_Request, options ...Option) (resp Groups_GetAddresses_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getAddresses", ctx, values, &resp)
	return
}

type Groups_GetBanned_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Offset needed to return a specific subset of users.
	//  Minimum: 0
	Offset *int
	// Number of users to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count  *int
	Fields *[]Base_UserGroupFields
	//  Format: int64
	OwnerId *int
}

func (r Groups_GetBanned_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Groups_GetBanned Returns a list of users on a community blacklist.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/groups.getBanned
func (vk *VK) Groups_GetBanned(ctx context.Context, req Groups_GetBanned_Request, options ...Option) (resp Groups_GetBanned_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getBanned", ctx, values, &resp)
	return
}

type Groups_GetById_Request struct {
	//  Format: int64
	GroupIds *[]string
	// ID or screen name of the community.
	//  Format: int64
	GroupId *string
	Fields  *[]Groups_Fields
}

func (r Groups_GetById_Request) fillIn(values url.Values) (err error) {
	if r.GroupIds != nil {
		setStrings(values, "group_ids", *r.GroupIds)
	}
	if r.GroupId != nil {
		setString(values, "group_id", *r.GroupId)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Groups_GetById Returns information about communities by their IDs.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getById
func (vk *VK) Groups_GetById(ctx context.Context, req Groups_GetById_Request, options ...Option) (resp Groups_GetByIdObjectLegacy_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getById", ctx, values, &resp)
	return
}

type Groups_GetCallbackConfirmationCode_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_GetCallbackConfirmationCode_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_GetCallbackConfirmationCode Returns Callback API confirmation code for the community.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getCallbackConfirmationCode
func (vk *VK) Groups_GetCallbackConfirmationCode(ctx context.Context, req Groups_GetCallbackConfirmationCode_Request, options ...Option) (resp Groups_GetCallbackConfirmationCode_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCallbackConfirmationCode", ctx, values, &resp)
	return
}

type Groups_GetCallbackServers_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	ServerIds *[]int
}

func (r Groups_GetCallbackServers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.ServerIds != nil {
		setInts(values, "server_ids", *r.ServerIds)
	}
	return
}

// Groups_GetCallbackServers ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getCallbackServers
func (vk *VK) Groups_GetCallbackServers(ctx context.Context, req Groups_GetCallbackServers_Request, options ...Option) (resp Groups_GetCallbackServers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCallbackServers", ctx, values, &resp)
	return
}

type Groups_GetCallbackSettings_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Server ID.
	//  Minimum: 0
	ServerId *int
}

func (r Groups_GetCallbackSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.ServerId != nil {
		setInt(values, "server_id", *r.ServerId)
	}
	return
}

// Groups_GetCallbackSettings Returns [vk.com/dev/callback_api|Callback API] notifications settings.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/groups.getCallbackSettings
func (vk *VK) Groups_GetCallbackSettings(ctx context.Context, req Groups_GetCallbackSettings_Request, options ...Option) (resp Groups_GetCallbackSettings_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCallbackSettings", ctx, values, &resp)
	return
}

type Groups_GetCatalog_Request struct {
	// Category id received from [vk.com/dev/groups.getCatalogInfo|groups.getCatalogInfo].
	//  Minimum: 0
	CategoryId *int
	// Subcategory id received from [vk.com/dev/groups.getCatalogInfo|groups.getCatalogInfo].
	//  Minimum: 0
	//  Maximum: 99
	SubcategoryId *int
}

func (r Groups_GetCatalog_Request) fillIn(values url.Values) (err error) {
	if r.CategoryId != nil {
		setInt(values, "category_id", *r.CategoryId)
	}
	if r.SubcategoryId != nil {
		setInt(values, "subcategory_id", *r.SubcategoryId)
	}
	return
}

// Groups_GetCatalog Returns communities list for a catalog category.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_CommunitiesCatalogDisabled, Error_CommunitiesCategoriesDisabled ]
//
// https://dev.vk.com/method/groups.getCatalog
func (vk *VK) Groups_GetCatalog(ctx context.Context, req Groups_GetCatalog_Request, options ...Option) (resp Groups_GetCatalog_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCatalog", ctx, values, &resp)
	return
}

type Groups_GetCatalogInfo_Request struct {
	// 1 - to return subcategories info. By default: 0.
	//  Default: 0
	Subcategories *bool
}

func (r Groups_GetCatalogInfo_Request) fillIn(values url.Values) (err error) {
	if r.Subcategories != nil {
		setBool(values, "subcategories", *r.Subcategories)
	}
	return
}

// Groups_GetCatalogInfo Returns categories list for communities catalog
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getCatalogInfo
func (vk *VK) Groups_GetCatalogInfo(ctx context.Context, req Groups_GetCatalogInfo_Request, options ...Option) (resp Groups_GetCatalogInfo_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCatalogInfo", ctx, values, &resp)
	return
}

// Groups_GetCatalogInfoExtended Returns categories list for communities catalog
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getCatalogInfo
func (vk *VK) Groups_GetCatalogInfoExtended(ctx context.Context, req Groups_GetCatalogInfo_Request, options ...Option) (resp Groups_GetCatalogInfoExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getCatalogInfo", ctx, values, &resp)
	return
}

type Groups_GetInvitedUsers_NameCase string

const (
	Groups_GetInvitedUsers_NameCase_Nominative    Groups_GetInvitedUsers_NameCase = "nom"
	Groups_GetInvitedUsers_NameCase_Genitive      Groups_GetInvitedUsers_NameCase = "gen"
	Groups_GetInvitedUsers_NameCase_Dative        Groups_GetInvitedUsers_NameCase = "dat"
	Groups_GetInvitedUsers_NameCase_Accusative    Groups_GetInvitedUsers_NameCase = "acc"
	Groups_GetInvitedUsers_NameCase_Instrumental  Groups_GetInvitedUsers_NameCase = "ins"
	Groups_GetInvitedUsers_NameCase_Prepositional Groups_GetInvitedUsers_NameCase = "abl"
)

type Groups_GetInvitedUsers_Request struct {
	// Group ID to return invited users for.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of results to return.
	//  Default: 20
	//  Minimum: 0
	Count  *int
	Fields *[]Users_Fields
	// Case for declension of user name and surname. Possible values: *'nom' — nominative (default),, *'gen' — genitive,, *'dat' — dative,, *'acc' — accusative, , *'ins' — instrumental,, *'abl' — prepositional.
	NameCase *Groups_GetInvitedUsers_NameCase
}

func (r Groups_GetInvitedUsers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Groups_GetInvitedUsers Returns invited users list of a community
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getInvitedUsers
func (vk *VK) Groups_GetInvitedUsers(ctx context.Context, req Groups_GetInvitedUsers_Request, options ...Option) (resp Groups_GetInvitedUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getInvitedUsers", ctx, values, &resp)
	return
}

type Groups_GetInvites_Request struct {
	// Offset needed to return a specific subset of invitations.
	//  Minimum: 0
	Offset *int
	// Number of invitations to return.
	//  Default: 20
	//  Minimum: 0
	Count *int
}

func (r Groups_GetInvites_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Groups_GetInvites Returns a list of invitations to join communities and events.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getInvites
func (vk *VK) Groups_GetInvites(ctx context.Context, req Groups_GetInvites_Request, options ...Option) (resp Groups_GetInvites_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getInvites", ctx, values, &resp)
	return
}

// Groups_GetInvitesExtended Returns a list of invitations to join communities and events.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getInvites
func (vk *VK) Groups_GetInvitesExtended(ctx context.Context, req Groups_GetInvites_Request, options ...Option) (resp Groups_GetInvitesExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getInvites", ctx, values, &resp)
	return
}

type Groups_GetLongPollServer_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_GetLongPollServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_GetLongPollServer Returns the data needed to query a Long Poll server for events
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getLongPollServer
func (vk *VK) Groups_GetLongPollServer(ctx context.Context, req Groups_GetLongPollServer_Request, options ...Option) (resp Groups_GetLongPollServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getLongPollServer", ctx, values, &resp)
	return
}

type Groups_GetLongPollSettings_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_GetLongPollSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_GetLongPollSettings Returns Long Poll notification settings
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getLongPollSettings
func (vk *VK) Groups_GetLongPollSettings(ctx context.Context, req Groups_GetLongPollSettings_Request, options ...Option) (resp Groups_GetLongPollSettings_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getLongPollSettings", ctx, values, &resp)
	return
}

type Groups_GetMembers_Sort string

const (
	Groups_GetMembers_Sort_IdAsc    Groups_GetMembers_Sort = "id_asc"
	Groups_GetMembers_Sort_IdDesc   Groups_GetMembers_Sort = "id_desc"
	Groups_GetMembers_Sort_TimeAsc  Groups_GetMembers_Sort = "time_asc"
	Groups_GetMembers_Sort_TimeDesc Groups_GetMembers_Sort = "time_desc"
)

type Groups_GetMembers_Filter string

const (
	Groups_GetMembers_Filter_Friends  Groups_GetMembers_Filter = "friends"
	Groups_GetMembers_Filter_Unsure   Groups_GetMembers_Filter = "unsure"
	Groups_GetMembers_Filter_Managers Groups_GetMembers_Filter = "managers"
	Groups_GetMembers_Filter_Donut    Groups_GetMembers_Filter = "donut"
)

type Groups_GetMembers_Request struct {
	// ID or screen name of the community.
	GroupId *string
	// Sort order. Available values: 'id_asc', 'id_desc', 'time_asc', 'time_desc'. 'time_asc' and 'time_desc' are availavle only if the method is called by the group's 'moderator'.
	//  Default: id_asc
	Sort *Groups_GetMembers_Sort
	// Offset needed to return a specific subset of community members.
	//  Minimum: 0
	Offset *int
	// Number of community members to return.
	//  Default: 1000
	//  Minimum: 0
	Count  *int
	Fields *[]Users_Fields
	// *'friends' - only friends in this community will be returned,, *'unsure' - only those who pressed 'I may attend' will be returned (if it's an event).
	Filter *Groups_GetMembers_Filter
}

func (r Groups_GetMembers_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setString(values, "group_id", *r.GroupId)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.Filter != nil {
		setString(values, "filter", string(*r.Filter))
	}
	return
}

// Groups_GetMembers Returns a list of community members.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamGroupId ]
//
// https://dev.vk.com/method/groups.getMembers
func (vk *VK) Groups_GetMembers(ctx context.Context, req Groups_GetMembers_Request, options ...Option) (resp Groups_GetMembers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getMembers", ctx, values, &resp)
	return
}

type Groups_GetRequests_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of results to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count  *int
	Fields *[]Users_Fields
}

func (r Groups_GetRequests_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Groups_GetRequests Returns a list of requests to the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getRequests
func (vk *VK) Groups_GetRequests(ctx context.Context, req Groups_GetRequests_Request, options ...Option) (resp Groups_GetRequests_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getRequests", ctx, values, &resp)
	return
}

type Groups_GetSettings_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_GetSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_GetSettings Returns community settings.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getSettings
func (vk *VK) Groups_GetSettings(ctx context.Context, req Groups_GetSettings_Request, options ...Option) (resp Groups_GetSettings_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getSettings", ctx, values, &resp)
	return
}

type Groups_GetTagList_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_GetTagList_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_GetTagList List of group's tags
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getTagList
func (vk *VK) Groups_GetTagList(ctx context.Context, req Groups_GetTagList_Request, options ...Option) (resp Groups_GetTagList_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getTagList", ctx, values, &resp)
	return
}

// Groups_GetTokenPermissions ...
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.getTokenPermissions
func (vk *VK) Groups_GetTokenPermissions(ctx context.Context, options ...Option) (resp Groups_GetTokenPermissions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.getTokenPermissions", ctx, values, &resp)
	return
}

type Groups_Invite_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Groups_Invite_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	return
}

// Groups_Invite Allows to invite friends to the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits ]
//
// https://dev.vk.com/method/groups.invite
func (vk *VK) Groups_Invite(ctx context.Context, req Groups_Invite_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.invite", ctx, values, &resp)
	return
}

type Groups_IsMember_Request struct {
	// ID or screen name of the community.
	GroupId string
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Groups_IsMember_Request) fillIn(values url.Values) (err error) {
	setString(values, "group_id", r.GroupId)
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Groups_IsMember Returns information specifying whether a user is a member of a community.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.isMember
func (vk *VK) Groups_IsMember(ctx context.Context, req Groups_IsMember_Request, options ...Option) (resp Groups_IsMember_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.isMember", ctx, values, &resp)
	return
}

// Groups_IsMemberExtended Returns information specifying whether a user is a member of a community.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.isMember
func (vk *VK) Groups_IsMemberExtended(ctx context.Context, req Groups_IsMember_Request, options ...Option) (resp Groups_IsMemberExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.isMember", ctx, values, &resp)
	return
}

type Groups_IsMemberUserIDs_Request struct {
	// ID or screen name of the community.
	GroupId string
	//  Format: int64
	//  Minimum: 1
	UserIds *[]int
}

func (r Groups_IsMemberUserIDs_Request) fillIn(values url.Values) (err error) {
	setString(values, "group_id", r.GroupId)
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	return
}

// Groups_IsMemberUserIDs Returns information specifying whether a user is a member of a community.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.isMember
func (vk *VK) Groups_IsMemberUserIDs(ctx context.Context, req Groups_IsMemberUserIDs_Request, options ...Option) (resp Groups_IsMemberUserIds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.isMember", ctx, values, &resp)
	return
}

// Groups_IsMemberExtendedUserIDs Returns information specifying whether a user is a member of a community.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.isMember
func (vk *VK) Groups_IsMemberExtendedUserIDs(ctx context.Context, req Groups_IsMemberUserIDs_Request, options ...Option) (resp Groups_IsMemberUserIdsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.isMember", ctx, values, &resp)
	return
}

type Groups_Join_Request struct {
	// ID or screen name of the community.
	//  Format: int64
	//  Minimum: 1
	GroupId *int
	// Optional parameter which is taken into account when 'gid' belongs to the event: '1' — Perhaps I will attend, '0' — I will be there for sure (default), ,
	NotSure *string
}

func (r Groups_Join_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.NotSure != nil {
		setString(values, "not_sure", *r.NotSure)
	}
	return
}

// Groups_Join With this method you can join the group or public page, and also confirm your participation in an event.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits, Error_GroupInviteLinksNotValid ]
//
// https://dev.vk.com/method/groups.join
func (vk *VK) Groups_Join(ctx context.Context, req Groups_Join_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.join", ctx, values, &resp)
	return
}

type Groups_Leave_Request struct {
	// ID or screen name of the community.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Groups_Leave_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Groups_Leave With this method you can leave a group, public page, or event.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ClientUpdateNeeded ]
//
// https://dev.vk.com/method/groups.leave
func (vk *VK) Groups_Leave(ctx context.Context, req Groups_Leave_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.leave", ctx, values, &resp)
	return
}

type Groups_RemoveUser_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Groups_RemoveUser_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	return
}

// Groups_RemoveUser Removes a user from the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.removeUser
func (vk *VK) Groups_RemoveUser(ctx context.Context, req Groups_RemoveUser_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.removeUser", ctx, values, &resp)
	return
}

type Groups_ReorderLink_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Link ID.
	//  Minimum: 0
	LinkId int
	// ID of the link after which to place the link with 'link_id'.
	//  Minimum: 0
	After *int
}

func (r Groups_ReorderLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "link_id", r.LinkId)
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Groups_ReorderLink Allows to reorder links in the community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.reorderLink
func (vk *VK) Groups_ReorderLink(ctx context.Context, req Groups_ReorderLink_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.reorderLink", ctx, values, &resp)
	return
}

type Groups_Search_Type string

const (
	Groups_Search_Type_Group Groups_Search_Type = "group"
	Groups_Search_Type_Page  Groups_Search_Type = "page"
	Groups_Search_Type_Event Groups_Search_Type = "event"
)

type Groups_Search_Sort int

const (
	Groups_Search_Sort_Default    Groups_Search_Sort = 0
	Groups_Search_Sort_Growth     Groups_Search_Sort = 1
	Groups_Search_Sort_Attendance Groups_Search_Sort = 2
	Groups_Search_Sort_Likes      Groups_Search_Sort = 3
	Groups_Search_Sort_Comments   Groups_Search_Sort = 4
	Groups_Search_Sort_Entries    Groups_Search_Sort = 5
)

type Groups_Search_Request struct {
	// Search query string.
	Q string
	// Community type. Possible values: 'group, page, event.'
	Type *Groups_Search_Type
	// Country ID.
	//  Minimum: 0
	CountryId *int
	// City ID. If this parameter is transmitted, country_id is ignored.
	//  Minimum: 0
	CityId *int
	// '1' — to return only upcoming events. Works with the 'type' = 'event' only.
	Future *bool
	// '1' — to return communities with enabled market only.
	Market *bool
	// Sort order. Possible values: *'0' — default sorting (similar the full version of the site),, *'1' — by growth speed,, *'2'— by the "day attendance/members number" ratio,, *'3' — by the "Likes number/members number" ratio,, *'4' — by the "comments number/members number" ratio,, *'5' — by the "boards entries number/members number" ratio.
	Sort *Groups_Search_Sort
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of communities to return. "Note that you can not receive more than first thousand of results, regardless of 'count' and 'offset' values."
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Groups_Search_Request) fillIn(values url.Values) (err error) {
	setString(values, "q", r.Q)
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.CountryId != nil {
		setInt(values, "country_id", *r.CountryId)
	}
	if r.CityId != nil {
		setInt(values, "city_id", *r.CityId)
	}
	if r.Future != nil {
		setBool(values, "future", *r.Future)
	}
	if r.Market != nil {
		setBool(values, "market", *r.Market)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Groups_Search Returns a list of communities matching the search criteria.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.search
func (vk *VK) Groups_Search(ctx context.Context, req Groups_Search_Request, options ...Option) (resp Groups_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.search", ctx, values, &resp)
	return
}

type Groups_SetCallbackSettings_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Server ID.
	//  Minimum: 0
	ServerId   *int
	ApiVersion *string
	// A new incoming message has been received ('0' — disabled, '1' — enabled).
	MessageNew *bool
	// A new outcoming message has been received ('0' — disabled, '1' — enabled).
	MessageReply *bool
	// Allowed messages notifications ('0' — disabled, '1' — enabled).
	MessageAllow *bool
	MessageEdit  *bool
	// Denied messages notifications ('0' — disabled, '1' — enabled).
	MessageDeny        *bool
	MessageTypingState *bool
	// New photos notifications ('0' — disabled, '1' — enabled).
	PhotoNew *bool
	// New audios notifications ('0' — disabled, '1' — enabled).
	AudioNew *bool
	// New videos notifications ('0' — disabled, '1' — enabled).
	VideoNew *bool
	// New wall replies notifications ('0' — disabled, '1' — enabled).
	WallReplyNew *bool
	// Wall replies edited notifications ('0' — disabled, '1' — enabled).
	WallReplyEdit *bool
	// A wall comment has been deleted ('0' — disabled, '1' — enabled).
	WallReplyDelete *bool
	// A wall comment has been restored ('0' — disabled, '1' — enabled).
	WallReplyRestore *bool
	// New wall posts notifications ('0' — disabled, '1' — enabled).
	WallPostNew *bool
	// New wall posts notifications ('0' — disabled, '1' — enabled).
	WallRepost *bool
	// New board posts notifications ('0' — disabled, '1' — enabled).
	BoardPostNew *bool
	// Board posts edited notifications ('0' — disabled, '1' — enabled).
	BoardPostEdit *bool
	// Board posts restored notifications ('0' — disabled, '1' — enabled).
	BoardPostRestore *bool
	// Board posts deleted notifications ('0' — disabled, '1' — enabled).
	BoardPostDelete *bool
	// New comment to photo notifications ('0' — disabled, '1' — enabled).
	PhotoCommentNew *bool
	// A photo comment has been edited ('0' — disabled, '1' — enabled).
	PhotoCommentEdit *bool
	// A photo comment has been deleted ('0' — disabled, '1' — enabled).
	PhotoCommentDelete *bool
	// A photo comment has been restored ('0' — disabled, '1' — enabled).
	PhotoCommentRestore *bool
	// New comment to video notifications ('0' — disabled, '1' — enabled).
	VideoCommentNew *bool
	// A video comment has been edited ('0' — disabled, '1' — enabled).
	VideoCommentEdit *bool
	// A video comment has been deleted ('0' — disabled, '1' — enabled).
	VideoCommentDelete *bool
	// A video comment has been restored ('0' — disabled, '1' — enabled).
	VideoCommentRestore *bool
	// New comment to market item notifications ('0' — disabled, '1' — enabled).
	MarketCommentNew *bool
	// A market comment has been edited ('0' — disabled, '1' — enabled).
	MarketCommentEdit *bool
	// A market comment has been deleted ('0' — disabled, '1' — enabled).
	MarketCommentDelete *bool
	// A market comment has been restored ('0' — disabled, '1' — enabled).
	MarketCommentRestore *bool
	MarketOrderNew       *bool
	MarketOrderEdit      *bool
	// A vote in a public poll has been added ('0' — disabled, '1' — enabled).
	PollVoteNew *bool
	// Joined community notifications ('0' — disabled, '1' — enabled).
	GroupJoin *bool
	// Left community notifications ('0' — disabled, '1' — enabled).
	GroupLeave          *bool
	GroupChangeSettings *bool
	GroupChangePhoto    *bool
	GroupOfficersEdit   *bool
	// User added to community blacklist
	UserBlock *bool
	// User removed from community blacklist
	UserUnblock *bool
	// New form in lead forms
	LeadFormsNew                  *bool
	LikeAdd                       *bool
	LikeRemove                    *bool
	MessageEvent                  *bool
	DonutSubscriptionCreate       *bool
	DonutSubscriptionProlonged    *bool
	DonutSubscriptionCancelled    *bool
	DonutSubscriptionPriceChanged *bool
	DonutSubscriptionExpired      *bool
	DonutMoneyWithdraw            *bool
	DonutMoneyWithdrawError       *bool
}

func (r Groups_SetCallbackSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.ServerId != nil {
		setInt(values, "server_id", *r.ServerId)
	}
	if r.ApiVersion != nil {
		setString(values, "api_version", *r.ApiVersion)
	}
	if r.MessageNew != nil {
		setBool(values, "message_new", *r.MessageNew)
	}
	if r.MessageReply != nil {
		setBool(values, "message_reply", *r.MessageReply)
	}
	if r.MessageAllow != nil {
		setBool(values, "message_allow", *r.MessageAllow)
	}
	if r.MessageEdit != nil {
		setBool(values, "message_edit", *r.MessageEdit)
	}
	if r.MessageDeny != nil {
		setBool(values, "message_deny", *r.MessageDeny)
	}
	if r.MessageTypingState != nil {
		setBool(values, "message_typing_state", *r.MessageTypingState)
	}
	if r.PhotoNew != nil {
		setBool(values, "photo_new", *r.PhotoNew)
	}
	if r.AudioNew != nil {
		setBool(values, "audio_new", *r.AudioNew)
	}
	if r.VideoNew != nil {
		setBool(values, "video_new", *r.VideoNew)
	}
	if r.WallReplyNew != nil {
		setBool(values, "wall_reply_new", *r.WallReplyNew)
	}
	if r.WallReplyEdit != nil {
		setBool(values, "wall_reply_edit", *r.WallReplyEdit)
	}
	if r.WallReplyDelete != nil {
		setBool(values, "wall_reply_delete", *r.WallReplyDelete)
	}
	if r.WallReplyRestore != nil {
		setBool(values, "wall_reply_restore", *r.WallReplyRestore)
	}
	if r.WallPostNew != nil {
		setBool(values, "wall_post_new", *r.WallPostNew)
	}
	if r.WallRepost != nil {
		setBool(values, "wall_repost", *r.WallRepost)
	}
	if r.BoardPostNew != nil {
		setBool(values, "board_post_new", *r.BoardPostNew)
	}
	if r.BoardPostEdit != nil {
		setBool(values, "board_post_edit", *r.BoardPostEdit)
	}
	if r.BoardPostRestore != nil {
		setBool(values, "board_post_restore", *r.BoardPostRestore)
	}
	if r.BoardPostDelete != nil {
		setBool(values, "board_post_delete", *r.BoardPostDelete)
	}
	if r.PhotoCommentNew != nil {
		setBool(values, "photo_comment_new", *r.PhotoCommentNew)
	}
	if r.PhotoCommentEdit != nil {
		setBool(values, "photo_comment_edit", *r.PhotoCommentEdit)
	}
	if r.PhotoCommentDelete != nil {
		setBool(values, "photo_comment_delete", *r.PhotoCommentDelete)
	}
	if r.PhotoCommentRestore != nil {
		setBool(values, "photo_comment_restore", *r.PhotoCommentRestore)
	}
	if r.VideoCommentNew != nil {
		setBool(values, "video_comment_new", *r.VideoCommentNew)
	}
	if r.VideoCommentEdit != nil {
		setBool(values, "video_comment_edit", *r.VideoCommentEdit)
	}
	if r.VideoCommentDelete != nil {
		setBool(values, "video_comment_delete", *r.VideoCommentDelete)
	}
	if r.VideoCommentRestore != nil {
		setBool(values, "video_comment_restore", *r.VideoCommentRestore)
	}
	if r.MarketCommentNew != nil {
		setBool(values, "market_comment_new", *r.MarketCommentNew)
	}
	if r.MarketCommentEdit != nil {
		setBool(values, "market_comment_edit", *r.MarketCommentEdit)
	}
	if r.MarketCommentDelete != nil {
		setBool(values, "market_comment_delete", *r.MarketCommentDelete)
	}
	if r.MarketCommentRestore != nil {
		setBool(values, "market_comment_restore", *r.MarketCommentRestore)
	}
	if r.MarketOrderNew != nil {
		setBool(values, "market_order_new", *r.MarketOrderNew)
	}
	if r.MarketOrderEdit != nil {
		setBool(values, "market_order_edit", *r.MarketOrderEdit)
	}
	if r.PollVoteNew != nil {
		setBool(values, "poll_vote_new", *r.PollVoteNew)
	}
	if r.GroupJoin != nil {
		setBool(values, "group_join", *r.GroupJoin)
	}
	if r.GroupLeave != nil {
		setBool(values, "group_leave", *r.GroupLeave)
	}
	if r.GroupChangeSettings != nil {
		setBool(values, "group_change_settings", *r.GroupChangeSettings)
	}
	if r.GroupChangePhoto != nil {
		setBool(values, "group_change_photo", *r.GroupChangePhoto)
	}
	if r.GroupOfficersEdit != nil {
		setBool(values, "group_officers_edit", *r.GroupOfficersEdit)
	}
	if r.UserBlock != nil {
		setBool(values, "user_block", *r.UserBlock)
	}
	if r.UserUnblock != nil {
		setBool(values, "user_unblock", *r.UserUnblock)
	}
	if r.LeadFormsNew != nil {
		setBool(values, "lead_forms_new", *r.LeadFormsNew)
	}
	if r.LikeAdd != nil {
		setBool(values, "like_add", *r.LikeAdd)
	}
	if r.LikeRemove != nil {
		setBool(values, "like_remove", *r.LikeRemove)
	}
	if r.MessageEvent != nil {
		setBool(values, "message_event", *r.MessageEvent)
	}
	if r.DonutSubscriptionCreate != nil {
		setBool(values, "donut_subscription_create", *r.DonutSubscriptionCreate)
	}
	if r.DonutSubscriptionProlonged != nil {
		setBool(values, "donut_subscription_prolonged", *r.DonutSubscriptionProlonged)
	}
	if r.DonutSubscriptionCancelled != nil {
		setBool(values, "donut_subscription_cancelled", *r.DonutSubscriptionCancelled)
	}
	if r.DonutSubscriptionPriceChanged != nil {
		setBool(values, "donut_subscription_price_changed", *r.DonutSubscriptionPriceChanged)
	}
	if r.DonutSubscriptionExpired != nil {
		setBool(values, "donut_subscription_expired", *r.DonutSubscriptionExpired)
	}
	if r.DonutMoneyWithdraw != nil {
		setBool(values, "donut_money_withdraw", *r.DonutMoneyWithdraw)
	}
	if r.DonutMoneyWithdrawError != nil {
		setBool(values, "donut_money_withdraw_error", *r.DonutMoneyWithdrawError)
	}
	return
}

// Groups_SetCallbackSettings Allow to set notifications settings for group.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/groups.setCallbackSettings
func (vk *VK) Groups_SetCallbackSettings(ctx context.Context, req Groups_SetCallbackSettings_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 57+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.setCallbackSettings", ctx, values, &resp)
	return
}

type Groups_SetLongPollSettings_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Sets whether Long Poll is enabled ('0' — disabled, '1' — enabled).
	Enabled    *bool
	ApiVersion *string
	// A new incoming message has been received ('0' — disabled, '1' — enabled).
	MessageNew *bool
	// A new outcoming message has been received ('0' — disabled, '1' — enabled).
	MessageReply *bool
	// Allowed messages notifications ('0' — disabled, '1' — enabled).
	MessageAllow *bool
	// Denied messages notifications ('0' — disabled, '1' — enabled).
	MessageDeny *bool
	// A message has been edited ('0' — disabled, '1' — enabled).
	MessageEdit        *bool
	MessageTypingState *bool
	// New photos notifications ('0' — disabled, '1' — enabled).
	PhotoNew *bool
	// New audios notifications ('0' — disabled, '1' — enabled).
	AudioNew *bool
	// New videos notifications ('0' — disabled, '1' — enabled).
	VideoNew *bool
	// New wall replies notifications ('0' — disabled, '1' — enabled).
	WallReplyNew *bool
	// Wall replies edited notifications ('0' — disabled, '1' — enabled).
	WallReplyEdit *bool
	// A wall comment has been deleted ('0' — disabled, '1' — enabled).
	WallReplyDelete *bool
	// A wall comment has been restored ('0' — disabled, '1' — enabled).
	WallReplyRestore *bool
	// New wall posts notifications ('0' — disabled, '1' — enabled).
	WallPostNew *bool
	// New wall posts notifications ('0' — disabled, '1' — enabled).
	WallRepost *bool
	// New board posts notifications ('0' — disabled, '1' — enabled).
	BoardPostNew *bool
	// Board posts edited notifications ('0' — disabled, '1' — enabled).
	BoardPostEdit *bool
	// Board posts restored notifications ('0' — disabled, '1' — enabled).
	BoardPostRestore *bool
	// Board posts deleted notifications ('0' — disabled, '1' — enabled).
	BoardPostDelete *bool
	// New comment to photo notifications ('0' — disabled, '1' — enabled).
	PhotoCommentNew *bool
	// A photo comment has been edited ('0' — disabled, '1' — enabled).
	PhotoCommentEdit *bool
	// A photo comment has been deleted ('0' — disabled, '1' — enabled).
	PhotoCommentDelete *bool
	// A photo comment has been restored ('0' — disabled, '1' — enabled).
	PhotoCommentRestore *bool
	// New comment to video notifications ('0' — disabled, '1' — enabled).
	VideoCommentNew *bool
	// A video comment has been edited ('0' — disabled, '1' — enabled).
	VideoCommentEdit *bool
	// A video comment has been deleted ('0' — disabled, '1' — enabled).
	VideoCommentDelete *bool
	// A video comment has been restored ('0' — disabled, '1' — enabled).
	VideoCommentRestore *bool
	// New comment to market item notifications ('0' — disabled, '1' — enabled).
	MarketCommentNew *bool
	// A market comment has been edited ('0' — disabled, '1' — enabled).
	MarketCommentEdit *bool
	// A market comment has been deleted ('0' — disabled, '1' — enabled).
	MarketCommentDelete *bool
	// A market comment has been restored ('0' — disabled, '1' — enabled).
	MarketCommentRestore *bool
	// A vote in a public poll has been added ('0' — disabled, '1' — enabled).
	PollVoteNew *bool
	// Joined community notifications ('0' — disabled, '1' — enabled).
	GroupJoin *bool
	// Left community notifications ('0' — disabled, '1' — enabled).
	GroupLeave          *bool
	GroupChangeSettings *bool
	GroupChangePhoto    *bool
	GroupOfficersEdit   *bool
	// User added to community blacklist
	UserBlock *bool
	// User removed from community blacklist
	UserUnblock                   *bool
	LikeAdd                       *bool
	LikeRemove                    *bool
	MessageEvent                  *bool
	DonutSubscriptionCreate       *bool
	DonutSubscriptionProlonged    *bool
	DonutSubscriptionCancelled    *bool
	DonutSubscriptionPriceChanged *bool
	DonutSubscriptionExpired      *bool
	DonutMoneyWithdraw            *bool
	DonutMoneyWithdrawError       *bool
}

func (r Groups_SetLongPollSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Enabled != nil {
		setBool(values, "enabled", *r.Enabled)
	}
	if r.ApiVersion != nil {
		setString(values, "api_version", *r.ApiVersion)
	}
	if r.MessageNew != nil {
		setBool(values, "message_new", *r.MessageNew)
	}
	if r.MessageReply != nil {
		setBool(values, "message_reply", *r.MessageReply)
	}
	if r.MessageAllow != nil {
		setBool(values, "message_allow", *r.MessageAllow)
	}
	if r.MessageDeny != nil {
		setBool(values, "message_deny", *r.MessageDeny)
	}
	if r.MessageEdit != nil {
		setBool(values, "message_edit", *r.MessageEdit)
	}
	if r.MessageTypingState != nil {
		setBool(values, "message_typing_state", *r.MessageTypingState)
	}
	if r.PhotoNew != nil {
		setBool(values, "photo_new", *r.PhotoNew)
	}
	if r.AudioNew != nil {
		setBool(values, "audio_new", *r.AudioNew)
	}
	if r.VideoNew != nil {
		setBool(values, "video_new", *r.VideoNew)
	}
	if r.WallReplyNew != nil {
		setBool(values, "wall_reply_new", *r.WallReplyNew)
	}
	if r.WallReplyEdit != nil {
		setBool(values, "wall_reply_edit", *r.WallReplyEdit)
	}
	if r.WallReplyDelete != nil {
		setBool(values, "wall_reply_delete", *r.WallReplyDelete)
	}
	if r.WallReplyRestore != nil {
		setBool(values, "wall_reply_restore", *r.WallReplyRestore)
	}
	if r.WallPostNew != nil {
		setBool(values, "wall_post_new", *r.WallPostNew)
	}
	if r.WallRepost != nil {
		setBool(values, "wall_repost", *r.WallRepost)
	}
	if r.BoardPostNew != nil {
		setBool(values, "board_post_new", *r.BoardPostNew)
	}
	if r.BoardPostEdit != nil {
		setBool(values, "board_post_edit", *r.BoardPostEdit)
	}
	if r.BoardPostRestore != nil {
		setBool(values, "board_post_restore", *r.BoardPostRestore)
	}
	if r.BoardPostDelete != nil {
		setBool(values, "board_post_delete", *r.BoardPostDelete)
	}
	if r.PhotoCommentNew != nil {
		setBool(values, "photo_comment_new", *r.PhotoCommentNew)
	}
	if r.PhotoCommentEdit != nil {
		setBool(values, "photo_comment_edit", *r.PhotoCommentEdit)
	}
	if r.PhotoCommentDelete != nil {
		setBool(values, "photo_comment_delete", *r.PhotoCommentDelete)
	}
	if r.PhotoCommentRestore != nil {
		setBool(values, "photo_comment_restore", *r.PhotoCommentRestore)
	}
	if r.VideoCommentNew != nil {
		setBool(values, "video_comment_new", *r.VideoCommentNew)
	}
	if r.VideoCommentEdit != nil {
		setBool(values, "video_comment_edit", *r.VideoCommentEdit)
	}
	if r.VideoCommentDelete != nil {
		setBool(values, "video_comment_delete", *r.VideoCommentDelete)
	}
	if r.VideoCommentRestore != nil {
		setBool(values, "video_comment_restore", *r.VideoCommentRestore)
	}
	if r.MarketCommentNew != nil {
		setBool(values, "market_comment_new", *r.MarketCommentNew)
	}
	if r.MarketCommentEdit != nil {
		setBool(values, "market_comment_edit", *r.MarketCommentEdit)
	}
	if r.MarketCommentDelete != nil {
		setBool(values, "market_comment_delete", *r.MarketCommentDelete)
	}
	if r.MarketCommentRestore != nil {
		setBool(values, "market_comment_restore", *r.MarketCommentRestore)
	}
	if r.PollVoteNew != nil {
		setBool(values, "poll_vote_new", *r.PollVoteNew)
	}
	if r.GroupJoin != nil {
		setBool(values, "group_join", *r.GroupJoin)
	}
	if r.GroupLeave != nil {
		setBool(values, "group_leave", *r.GroupLeave)
	}
	if r.GroupChangeSettings != nil {
		setBool(values, "group_change_settings", *r.GroupChangeSettings)
	}
	if r.GroupChangePhoto != nil {
		setBool(values, "group_change_photo", *r.GroupChangePhoto)
	}
	if r.GroupOfficersEdit != nil {
		setBool(values, "group_officers_edit", *r.GroupOfficersEdit)
	}
	if r.UserBlock != nil {
		setBool(values, "user_block", *r.UserBlock)
	}
	if r.UserUnblock != nil {
		setBool(values, "user_unblock", *r.UserUnblock)
	}
	if r.LikeAdd != nil {
		setBool(values, "like_add", *r.LikeAdd)
	}
	if r.LikeRemove != nil {
		setBool(values, "like_remove", *r.LikeRemove)
	}
	if r.MessageEvent != nil {
		setBool(values, "message_event", *r.MessageEvent)
	}
	if r.DonutSubscriptionCreate != nil {
		setBool(values, "donut_subscription_create", *r.DonutSubscriptionCreate)
	}
	if r.DonutSubscriptionProlonged != nil {
		setBool(values, "donut_subscription_prolonged", *r.DonutSubscriptionProlonged)
	}
	if r.DonutSubscriptionCancelled != nil {
		setBool(values, "donut_subscription_cancelled", *r.DonutSubscriptionCancelled)
	}
	if r.DonutSubscriptionPriceChanged != nil {
		setBool(values, "donut_subscription_price_changed", *r.DonutSubscriptionPriceChanged)
	}
	if r.DonutSubscriptionExpired != nil {
		setBool(values, "donut_subscription_expired", *r.DonutSubscriptionExpired)
	}
	if r.DonutMoneyWithdraw != nil {
		setBool(values, "donut_money_withdraw", *r.DonutMoneyWithdraw)
	}
	if r.DonutMoneyWithdrawError != nil {
		setBool(values, "donut_money_withdraw_error", *r.DonutMoneyWithdrawError)
	}
	return
}

// Groups_SetLongPollSettings Sets Long Poll notification settings
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.setLongPollSettings
func (vk *VK) Groups_SetLongPollSettings(ctx context.Context, req Groups_SetLongPollSettings_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 54+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.setLongPollSettings", ctx, values, &resp)
	return
}

type Groups_SetSettings_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId          int
	Messages         *bool
	BotsCapabilities *bool
	BotsStartButton  *bool
	BotsAddToChat    *bool
}

func (r Groups_SetSettings_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Messages != nil {
		setBool(values, "messages", *r.Messages)
	}
	if r.BotsCapabilities != nil {
		setBool(values, "bots_capabilities", *r.BotsCapabilities)
	}
	if r.BotsStartButton != nil {
		setBool(values, "bots_start_button", *r.BotsStartButton)
	}
	if r.BotsAddToChat != nil {
		setBool(values, "bots_add_to_chat", *r.BotsAddToChat)
	}
	return
}

// Groups_SetSettings ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.setSettings
func (vk *VK) Groups_SetSettings(ctx context.Context, req Groups_SetSettings_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.setSettings", ctx, values, &resp)
	return
}

type Groups_SetUserNote_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Format: int64
	//  Minimum: 1
	UserId int
	// Note body
	//  MaxLength: 96
	Note *string
}

func (r Groups_SetUserNote_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	if r.Note != nil {
		setString(values, "note", *r.Note)
	}
	return
}

// Groups_SetUserNote In order to save note about group participant
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.setUserNote
func (vk *VK) Groups_SetUserNote(ctx context.Context, req Groups_SetUserNote_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.setUserNote", ctx, values, &resp)
	return
}

type Groups_TagAdd_TagColor string

const (
	Groups_TagAdd_TagColor_454647 Groups_TagAdd_TagColor = "454647"
	Groups_TagAdd_TagColor_45678f Groups_TagAdd_TagColor = "45678f"
	Groups_TagAdd_TagColor_4bb34b Groups_TagAdd_TagColor = "4bb34b"
	Groups_TagAdd_TagColor_5181b8 Groups_TagAdd_TagColor = "5181b8"
	Groups_TagAdd_TagColor_539b9c Groups_TagAdd_TagColor = "539b9c"
	Groups_TagAdd_TagColor_5c9ce6 Groups_TagAdd_TagColor = "5c9ce6"
	Groups_TagAdd_TagColor_63b9ba Groups_TagAdd_TagColor = "63b9ba"
	Groups_TagAdd_TagColor_6bc76b Groups_TagAdd_TagColor = "6bc76b"
	Groups_TagAdd_TagColor_76787a Groups_TagAdd_TagColor = "76787a"
	Groups_TagAdd_TagColor_792ec0 Groups_TagAdd_TagColor = "792ec0"
	Groups_TagAdd_TagColor_7a6c4f Groups_TagAdd_TagColor = "7a6c4f"
	Groups_TagAdd_TagColor_7ececf Groups_TagAdd_TagColor = "7ececf"
	Groups_TagAdd_TagColor_9e8d6b Groups_TagAdd_TagColor = "9e8d6b"
	Groups_TagAdd_TagColor_A162de Groups_TagAdd_TagColor = "a162de"
	Groups_TagAdd_TagColor_Aaaeb3 Groups_TagAdd_TagColor = "aaaeb3"
	Groups_TagAdd_TagColor_Bbaa84 Groups_TagAdd_TagColor = "bbaa84"
	Groups_TagAdd_TagColor_E64646 Groups_TagAdd_TagColor = "e64646"
	Groups_TagAdd_TagColor_Ff5c5c Groups_TagAdd_TagColor = "ff5c5c"
	Groups_TagAdd_TagColor_Ffa000 Groups_TagAdd_TagColor = "ffa000"
	Groups_TagAdd_TagColor_Ffc107 Groups_TagAdd_TagColor = "ffc107"
)

type Groups_TagAdd_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  MaxLength: 20
	TagName  string
	TagColor *Groups_TagAdd_TagColor
}

func (r Groups_TagAdd_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "tag_name", r.TagName)
	if r.TagColor != nil {
		setString(values, "tag_color", string(*r.TagColor))
	}
	return
}

// Groups_TagAdd Add new group's tag
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.tagAdd
func (vk *VK) Groups_TagAdd(ctx context.Context, req Groups_TagAdd_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.tagAdd", ctx, values, &resp)
	return
}

type Groups_TagBind_Act string

const (
	Groups_TagBind_Act_Bind   Groups_TagBind_Act = "bind"
	Groups_TagBind_Act_Unbind Groups_TagBind_Act = "unbind"
)

type Groups_TagBind_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	TagId int
	//  Format: int64
	//  Minimum: 1
	//  Maximum: 2e+09
	UserId int
	// Describe the action
	Act Groups_TagBind_Act
}

func (r Groups_TagBind_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "tag_id", r.TagId)
	setInt(values, "user_id", r.UserId)
	setString(values, "act", string(r.Act))
	return
}

// Groups_TagBind Bind or unbind group's tag to user
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.tagBind
func (vk *VK) Groups_TagBind(ctx context.Context, req Groups_TagBind_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.tagBind", ctx, values, &resp)
	return
}

type Groups_TagDelete_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	TagId int
}

func (r Groups_TagDelete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "tag_id", r.TagId)
	return
}

// Groups_TagDelete Delete group's tag
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.tagDelete
func (vk *VK) Groups_TagDelete(ctx context.Context, req Groups_TagDelete_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.tagDelete", ctx, values, &resp)
	return
}

type Groups_TagUpdate_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Minimum: 0
	TagId int
	//  MaxLength: 20
	TagName string
}

func (r Groups_TagUpdate_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "tag_id", r.TagId)
	setString(values, "tag_name", r.TagName)
	return
}

// Groups_TagUpdate Update group's tag
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.tagUpdate
func (vk *VK) Groups_TagUpdate(ctx context.Context, req Groups_TagUpdate_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.tagUpdate", ctx, values, &resp)
	return
}

type Groups_ToggleMarket_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	State   Groups_MarketState
	Ref     *string
}

func (r Groups_ToggleMarket_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "state", string(r.State))
	if r.Ref != nil {
		setString(values, "ref", *r.Ref)
	}
	return
}

// Groups_ToggleMarket ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketShopAlreadyEnabled, Error_MarketShopAlreadyDisabled ]
//
// https://dev.vk.com/method/groups.toggleMarket
func (vk *VK) Groups_ToggleMarket(ctx context.Context, req Groups_ToggleMarket_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.toggleMarket", ctx, values, &resp)
	return
}

type Groups_Unban_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Format: int64
	OwnerId *int
}

func (r Groups_Unban_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Groups_Unban ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/groups.unban
func (vk *VK) Groups_Unban(ctx context.Context, req Groups_Unban_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("groups.unban", ctx, values, &resp)
	return
}

type LeadForms_Create_Request struct {
	GroupId int
	//  MaxLength: 100
	Name string
	//  MaxLength: 60
	Title string
	//  MaxLength: 600
	Description string
	Questions   string
	//  MaxLength: 200
	PolicyLinkUrl string
	Photo         *string
	//  MaxLength: 300
	Confirmation *string
	//  MaxLength: 200
	SiteLinkUrl *string
	//  Default: 0
	Active *bool
	//  Default: 0
	OncePerUser *bool
	PixelCode   *string
	//  Minimum: 0
	NotifyAdmins *[]int
	NotifyEmails *[]string
}

func (r LeadForms_Create_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "name", r.Name)
	setString(values, "title", r.Title)
	setString(values, "description", r.Description)
	setString(values, "questions", r.Questions)
	setString(values, "policy_link_url", r.PolicyLinkUrl)
	if r.Photo != nil {
		setString(values, "photo", *r.Photo)
	}
	if r.Confirmation != nil {
		setString(values, "confirmation", *r.Confirmation)
	}
	if r.SiteLinkUrl != nil {
		setString(values, "site_link_url", *r.SiteLinkUrl)
	}
	if r.Active != nil {
		setBool(values, "active", *r.Active)
	}
	if r.OncePerUser != nil {
		setBool(values, "once_per_user", *r.OncePerUser)
	}
	if r.PixelCode != nil {
		setString(values, "pixel_code", *r.PixelCode)
	}
	if r.NotifyAdmins != nil {
		setInts(values, "notify_admins", *r.NotifyAdmins)
	}
	if r.NotifyEmails != nil {
		setStrings(values, "notify_emails", *r.NotifyEmails)
	}
	return
}

// LeadForms_Create ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/leadForms.create
func (vk *VK) LeadForms_Create(ctx context.Context, req LeadForms_Create_Request, options ...Option) (resp LeadForms_Create_Response, apiErr ApiError, err error) {
	values := make(url.Values, 16+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.create", ctx, values, &resp)
	return
}

type LeadForms_Delete_Request struct {
	GroupId int
	FormId  int
}

func (r LeadForms_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "form_id", r.FormId)
	return
}

// LeadForms_Delete ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/leadForms.delete
func (vk *VK) LeadForms_Delete(ctx context.Context, req LeadForms_Delete_Request, options ...Option) (resp LeadForms_Delete_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.delete", ctx, values, &resp)
	return
}

type LeadForms_Get_Request struct {
	GroupId int
	FormId  int
}

func (r LeadForms_Get_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "form_id", r.FormId)
	return
}

// LeadForms_Get ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/leadForms.get
func (vk *VK) LeadForms_Get(ctx context.Context, req LeadForms_Get_Request, options ...Option) (resp LeadForms_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.get", ctx, values, &resp)
	return
}

type LeadForms_GetLeads_Request struct {
	GroupId int
	FormId  int
	//  Default: 10
	//  Minimum: 1
	//  Maximum: 1000
	Limit         *int
	NextPageToken *string
}

func (r LeadForms_GetLeads_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "form_id", r.FormId)
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.NextPageToken != nil {
		setString(values, "next_page_token", *r.NextPageToken)
	}
	return
}

// LeadForms_GetLeads ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/leadForms.getLeads
func (vk *VK) LeadForms_GetLeads(ctx context.Context, req LeadForms_GetLeads_Request, options ...Option) (resp LeadForms_GetLeads_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.getLeads", ctx, values, &resp)
	return
}

// LeadForms_GetUploadURL ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/leadForms.getUploadURL
func (vk *VK) LeadForms_GetUploadURL(ctx context.Context, options ...Option) (resp LeadForms_UploadUrl_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.getUploadURL", ctx, values, &resp)
	return
}

type LeadForms_List_Request struct {
	GroupId int
}

func (r LeadForms_List_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// LeadForms_List ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/leadForms.list
func (vk *VK) LeadForms_List(ctx context.Context, req LeadForms_List_Request, options ...Option) (resp LeadForms_List_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.list", ctx, values, &resp)
	return
}

type LeadForms_Update_Request struct {
	GroupId int
	FormId  int
	//  MaxLength: 100
	Name string
	//  MaxLength: 60
	Title string
	//  MaxLength: 600
	Description string
	Questions   string
	//  MaxLength: 200
	PolicyLinkUrl string
	Photo         *string
	//  MaxLength: 300
	Confirmation *string
	//  MaxLength: 200
	SiteLinkUrl *string
	//  Default: 0
	Active *bool
	//  Default: 0
	OncePerUser *bool
	PixelCode   *string
	//  Minimum: 0
	NotifyAdmins *[]int
	NotifyEmails *[]string
}

func (r LeadForms_Update_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "form_id", r.FormId)
	setString(values, "name", r.Name)
	setString(values, "title", r.Title)
	setString(values, "description", r.Description)
	setString(values, "questions", r.Questions)
	setString(values, "policy_link_url", r.PolicyLinkUrl)
	if r.Photo != nil {
		setString(values, "photo", *r.Photo)
	}
	if r.Confirmation != nil {
		setString(values, "confirmation", *r.Confirmation)
	}
	if r.SiteLinkUrl != nil {
		setString(values, "site_link_url", *r.SiteLinkUrl)
	}
	if r.Active != nil {
		setBool(values, "active", *r.Active)
	}
	if r.OncePerUser != nil {
		setBool(values, "once_per_user", *r.OncePerUser)
	}
	if r.PixelCode != nil {
		setString(values, "pixel_code", *r.PixelCode)
	}
	if r.NotifyAdmins != nil {
		setInts(values, "notify_admins", *r.NotifyAdmins)
	}
	if r.NotifyEmails != nil {
		setStrings(values, "notify_emails", *r.NotifyEmails)
	}
	return
}

// LeadForms_Update ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/leadForms.update
func (vk *VK) LeadForms_Update(ctx context.Context, req LeadForms_Update_Request, options ...Option) (resp LeadForms_Create_Response, apiErr ApiError, err error) {
	values := make(url.Values, 17+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("leadForms.update", ctx, values, &resp)
	return
}

type Likes_Add_Request struct {
	// Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	Type Likes_Type
	// ID of the user or community that owns the object.
	//  Format: int64
	OwnerId *int
	// Object ID.
	//  Minimum: 0
	ItemId int
	// Access key required for an object owned by a private entity.
	AccessKey *string
}

func (r Likes_Add_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "item_id", r.ItemId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Likes_Add Adds the specified object to the 'Likes' list of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_LikesReactionCanNotBeApplied ]
//
// https://dev.vk.com/method/likes.add
func (vk *VK) Likes_Add(ctx context.Context, req Likes_Add_Request, options ...Option) (resp Likes_Add_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("likes.add", ctx, values, &resp)
	return
}

type Likes_Delete_Request struct {
	// Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	Type Likes_Type
	// ID of the user or community that owns the object.
	//  Format: int64
	OwnerId *int
	// Object ID.
	//  Minimum: 0
	ItemId int
	// Access key required for an object owned by a private entity.
	AccessKey *string
}

func (r Likes_Delete_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "item_id", r.ItemId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Likes_Delete Deletes the specified object from the 'Likes' list of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/likes.delete
func (vk *VK) Likes_Delete(ctx context.Context, req Likes_Delete_Request, options ...Option) (resp Likes_Delete_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("likes.delete", ctx, values, &resp)
	return
}

type Likes_GetList_Filter string

const (
	Likes_GetList_Filter_Likes  Likes_GetList_Filter = "likes"
	Likes_GetList_Filter_Copies Likes_GetList_Filter = "copies"
)

type Likes_GetList_FriendsOnly int

const (
	Likes_GetList_FriendsOnly_0 Likes_GetList_FriendsOnly = 0
	Likes_GetList_FriendsOnly_1 Likes_GetList_FriendsOnly = 1
	Likes_GetList_FriendsOnly_2 Likes_GetList_FriendsOnly = 2
	Likes_GetList_FriendsOnly_3 Likes_GetList_FriendsOnly = 3
)

type Likes_GetList_Request struct {
	// , Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion, 'sitepage' — page of the site where the [vk.com/dev/Like|Like widget] is installed
	Type Likes_Type
	// ID of the user, community, or application that owns the object. If the 'type' parameter is set as 'sitepage', the application ID is passed as 'owner_id'. Use negative value for a community id. If the 'type' parameter is not set, the 'owner_id' is assumed to be either the current user or the same application ID as if the 'type' parameter was set to 'sitepage'.
	//  Format: int64
	OwnerId *int
	// Object ID. If 'type' is set as 'sitepage', 'item_id' can include the 'page_id' parameter value used during initialization of the [vk.com/dev/Like|Like widget].
	ItemId *int
	// URL of the page where the [vk.com/dev/Like|Like widget] is installed. Used instead of the 'item_id' parameter.
	PageUrl *string
	// Filters to apply: 'likes' — returns information about all users who liked the object (default), 'copies' — returns information only about users who told their friends about the object
	Filter *Likes_GetList_Filter
	// Specifies which users are returned: '1' — to return only the current user's friends, '0' — to return all users (default)
	//  Default: 0
	FriendsOnly *Likes_GetList_FriendsOnly
	// Offset needed to select a specific subset of users.
	//  Minimum: 0
	Offset *int
	// Number of user IDs to return (maximum '1000'). Default is '100' if 'friends_only' is set to '0', otherwise, the default is '10' if 'friends_only' is set to '1'.
	//  Minimum: 0
	//  Maximum: 1000
	Count   *int
	SkipOwn *bool
}

func (r Likes_GetList_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.ItemId != nil {
		setInt(values, "item_id", *r.ItemId)
	}
	if r.PageUrl != nil {
		setString(values, "page_url", *r.PageUrl)
	}
	if r.Filter != nil {
		setString(values, "filter", string(*r.Filter))
	}
	if r.FriendsOnly != nil {
		setInt(values, "friends_only", int(*r.FriendsOnly))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.SkipOwn != nil {
		setBool(values, "skip_own", *r.SkipOwn)
	}
	return
}

// Likes_GetList Returns a list of IDs of users who added the specified object to their 'Likes' list.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_LikesReactionCanNotBeApplied ]
//
// https://dev.vk.com/method/likes.getList
func (vk *VK) Likes_GetList(ctx context.Context, req Likes_GetList_Request, options ...Option) (resp Likes_GetList_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("likes.getList", ctx, values, &resp)
	return
}

// Likes_GetListExtended Returns a list of IDs of users who added the specified object to their 'Likes' list.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_LikesReactionCanNotBeApplied ]
//
// https://dev.vk.com/method/likes.getList
func (vk *VK) Likes_GetListExtended(ctx context.Context, req Likes_GetList_Request, options ...Option) (resp Likes_GetListExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("likes.getList", ctx, values, &resp)
	return
}

type Likes_IsLiked_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Object type: 'post' — post on user or community wall, 'comment' — comment on a wall post, 'photo' — photo, 'audio' — audio, 'video' — video, 'note' — note, 'photo_comment' — comment on the photo, 'video_comment' — comment on the video, 'topic_comment' — comment in the discussion
	Type Likes_Type
	// ID of the user or community that owns the object.
	//  Format: int64
	OwnerId *int
	// Object ID.
	//  Minimum: 0
	ItemId int
}

func (r Likes_IsLiked_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "item_id", r.ItemId)
	return
}

// Likes_IsLiked Checks for the object in the 'Likes' list of the specified user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/likes.isLiked
func (vk *VK) Likes_IsLiked(ctx context.Context, req Likes_IsLiked_Request, options ...Option) (resp Likes_IsLiked_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("likes.isLiked", ctx, values, &resp)
	return
}

type Market_Add_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item name.
	//  MinLength: 4
	//  MaxLength: 100
	Name string
	// Item description.
	//  MinLength: 10
	Description string
	// Item category ID.
	//  Minimum: 0
	CategoryId int
	// Item price.
	//  Minimum: 0
	Price *float64
	//  Minimum: 0.01
	OldPrice *float64
	// Item status ('1' — deleted, '0' — not deleted).
	Deleted *bool
	// Cover photo ID.
	//  Minimum: 0
	MainPhotoId *int
	//  MaxItems: 4
	//  Minimum: 0
	PhotoIds *[]int
	// Url for button in market item.
	//  MinLength: 0
	//  MaxLength: 320
	Url *string
	//  Minimum: 0
	//  Maximum: 100000
	DimensionWidth *int
	//  Minimum: 0
	//  Maximum: 100000
	DimensionHeight *int
	//  Minimum: 0
	//  Maximum: 100000
	DimensionLength *int
	//  Minimum: 0
	//  Maximum: 1e+08
	Weight *int
	//  MaxLength: 50
	Sku *string
}

func (r Market_Add_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setString(values, "name", r.Name)
	setString(values, "description", r.Description)
	setInt(values, "category_id", r.CategoryId)
	if r.Price != nil {
		setFloat(values, "price", *r.Price)
	}
	if r.OldPrice != nil {
		setFloat(values, "old_price", *r.OldPrice)
	}
	if r.Deleted != nil {
		setBool(values, "deleted", *r.Deleted)
	}
	if r.MainPhotoId != nil {
		setInt(values, "main_photo_id", *r.MainPhotoId)
	}
	if r.PhotoIds != nil {
		setInts(values, "photo_ids", *r.PhotoIds)
	}
	if r.Url != nil {
		setString(values, "url", *r.Url)
	}
	if r.DimensionWidth != nil {
		setInt(values, "dimension_width", *r.DimensionWidth)
	}
	if r.DimensionHeight != nil {
		setInt(values, "dimension_height", *r.DimensionHeight)
	}
	if r.DimensionLength != nil {
		setInt(values, "dimension_length", *r.DimensionLength)
	}
	if r.Weight != nil {
		setInt(values, "weight", *r.Weight)
	}
	if r.Sku != nil {
		setString(values, "sku", *r.Sku)
	}
	return
}

// Market_Add Ads a new item to the market.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketTooManyItems, Error_MarketItemHasBadLinks, Error_MarketVariantNotFound, Error_MarketPropertyNotFound, Error_MarketGroupingItemsMustHaveDistinctProperties, Error_MarketGroupingMustContainMoreThanOneItem, Error_MarketPhotosCropInvalidFormat, Error_MarketPhotosCropOverflow, Error_MarketPhotosCropSizeTooLow, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.add
func (vk *VK) Market_Add(ctx context.Context, req Market_Add_Request, options ...Option) (resp Market_Add_Response, apiErr ApiError, err error) {
	values := make(url.Values, 17+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.add", ctx, values, &resp)
	return
}

type Market_AddAlbum_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Collection title.
	//  MaxLength: 128
	Title string
	// Cover photo ID.
	//  Minimum: 0
	PhotoId *int
	// Set as main ('1' - set, '0' - no).
	MainAlbum *bool
	// Set as hidden
	IsHidden *bool
}

func (r Market_AddAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setString(values, "title", r.Title)
	if r.PhotoId != nil {
		setInt(values, "photo_id", *r.PhotoId)
	}
	if r.MainAlbum != nil {
		setBool(values, "main_album", *r.MainAlbum)
	}
	if r.IsHidden != nil {
		setBool(values, "is_hidden", *r.IsHidden)
	}
	return
}

// Market_AddAlbum Creates new collection of items
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketTooManyAlbums, Error_MarketNotEnabled, Error_MarketAlbumMainHidden ]
//
// https://dev.vk.com/method/market.addAlbum
func (vk *VK) Market_AddAlbum(ctx context.Context, req Market_AddAlbum_Request, options ...Option) (resp Market_AddAlbum_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.addAlbum", ctx, values, &resp)
	return
}

type Market_AddToAlbum_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	ItemIds *[]int
	//  Minimum: 0
	AlbumIds *[]int
}

func (r Market_AddToAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.ItemIds != nil {
		setInts(values, "item_ids", *r.ItemIds)
	}
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	return
}

// Market_AddToAlbum Adds an item to one or multiple collections.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketAlbumNotFound, Error_MarketNotEnabled, Error_MarketItemNotFound, Error_MarketTooManyItemsInAlbum, Error_MarketItemAlreadyAdded ]
//
// https://dev.vk.com/method/market.addToAlbum
func (vk *VK) Market_AddToAlbum(ctx context.Context, req Market_AddToAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.addToAlbum", ctx, values, &resp)
	return
}

type Market_CreateComment_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
	// Comment text (required if 'attachments' parameter is not specified)
	Message     *string
	Attachments *[]string
	// '1' - comment will be published on behalf of a community, '0' - on behalf of a user (by default).
	FromGroup *bool
	// ID of a comment to reply with current comment to.
	//  Minimum: 0
	ReplyToComment *int
	// Sticker ID.
	//  Minimum: 0
	StickerId *int
	// Random value to avoid resending one comment.
	Guid *string
}

func (r Market_CreateComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.ReplyToComment != nil {
		setInt(values, "reply_to_comment", *r.ReplyToComment)
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Market_CreateComment Creates a new comment for an item.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.createComment
func (vk *VK) Market_CreateComment(ctx context.Context, req Market_CreateComment_Request, options ...Option) (resp Market_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.createComment", ctx, values, &resp)
	return
}

type Market_Delete_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
}

func (r Market_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	return
}

// Market_Delete Deletes an item.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.delete
func (vk *VK) Market_Delete(ctx context.Context, req Market_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.delete", ctx, values, &resp)
	return
}

type Market_DeleteAlbum_Request struct {
	// ID of an collection owner community.
	//  Format: int64
	OwnerId int
	// Collection ID.
	//  Minimum: 0
	AlbumId int
}

func (r Market_DeleteAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "album_id", r.AlbumId)
	return
}

// Market_DeleteAlbum Deletes a collection of items.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketAlbumNotFound, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.deleteAlbum
func (vk *VK) Market_DeleteAlbum(ctx context.Context, req Market_DeleteAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.deleteAlbum", ctx, values, &resp)
	return
}

type Market_DeleteComment_Request struct {
	// identifier of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	//  Format: int64
	OwnerId int
	// comment id
	//  Minimum: 0
	CommentId int
}

func (r Market_DeleteComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	return
}

// Market_DeleteComment Deletes an item's comment
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.deleteComment
func (vk *VK) Market_DeleteComment(ctx context.Context, req Market_DeleteComment_Request, options ...Option) (resp Market_DeleteComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.deleteComment", ctx, values, &resp)
	return
}

type Market_Edit_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
	// Item name.
	//  MinLength: 4
	//  MaxLength: 100
	Name *string
	// Item description.
	//  MinLength: 10
	Description *string
	// Item category ID.
	//  Minimum: 0
	CategoryId *int
	// Item price.
	//  Minimum: 0
	Price *float64
	//  Minimum: 0.01
	OldPrice *float64
	// Item status ('1' — deleted, '0' — not deleted).
	Deleted *bool
	// Cover photo ID.
	//  Minimum: 0
	MainPhotoId *int
	//  MaxItems: 4
	//  Minimum: 0
	PhotoIds *[]int
	// Url for button in market item.
	//  MinLength: 0
	//  MaxLength: 320
	Url *string
	//  Minimum: 0
	//  Maximum: 100000
	DimensionWidth *int
	//  Minimum: 0
	//  Maximum: 100000
	DimensionHeight *int
	//  Minimum: 0
	//  Maximum: 100000
	DimensionLength *int
	//  Minimum: 0
	//  Maximum: 1e+08
	Weight *int
	//  MaxLength: 50
	Sku *string
}

func (r Market_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.CategoryId != nil {
		setInt(values, "category_id", *r.CategoryId)
	}
	if r.Price != nil {
		setFloat(values, "price", *r.Price)
	}
	if r.OldPrice != nil {
		setFloat(values, "old_price", *r.OldPrice)
	}
	if r.Deleted != nil {
		setBool(values, "deleted", *r.Deleted)
	}
	if r.MainPhotoId != nil {
		setInt(values, "main_photo_id", *r.MainPhotoId)
	}
	if r.PhotoIds != nil {
		setInts(values, "photo_ids", *r.PhotoIds)
	}
	if r.Url != nil {
		setString(values, "url", *r.Url)
	}
	if r.DimensionWidth != nil {
		setInt(values, "dimension_width", *r.DimensionWidth)
	}
	if r.DimensionHeight != nil {
		setInt(values, "dimension_height", *r.DimensionHeight)
	}
	if r.DimensionLength != nil {
		setInt(values, "dimension_length", *r.DimensionLength)
	}
	if r.Weight != nil {
		setInt(values, "weight", *r.Weight)
	}
	if r.Sku != nil {
		setString(values, "sku", *r.Sku)
	}
	return
}

// Market_Edit Edits an item.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketItemNotFound, Error_MarketItemHasBadLinks, Error_MarketGroupingItemsWithDifferentProperties, Error_MarketGroupingAlreadyHasSuchVariant, Error_MarketPhotosCropInvalidFormat, Error_MarketPhotosCropOverflow, Error_MarketPhotosCropSizeTooLow, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.edit
func (vk *VK) Market_Edit(ctx context.Context, req Market_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 18+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.edit", ctx, values, &resp)
	return
}

type Market_EditAlbum_Request struct {
	// ID of an collection owner community.
	//  Format: int64
	OwnerId int
	// Collection ID.
	//  Minimum: 0
	AlbumId int
	// Collection title.
	//  MaxLength: 128
	Title string
	// Cover photo id
	//  Minimum: 0
	PhotoId *int
	// Set as main ('1' - set, '0' - no).
	MainAlbum *bool
	// Set as hidden
	IsHidden *bool
}

func (r Market_EditAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "album_id", r.AlbumId)
	setString(values, "title", r.Title)
	if r.PhotoId != nil {
		setInt(values, "photo_id", *r.PhotoId)
	}
	if r.MainAlbum != nil {
		setBool(values, "main_album", *r.MainAlbum)
	}
	if r.IsHidden != nil {
		setBool(values, "is_hidden", *r.IsHidden)
	}
	return
}

// Market_EditAlbum Edits a collection of items
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketAlbumNotFound, Error_MarketNotEnabled, Error_MarketAlbumMainHidden ]
//
// https://dev.vk.com/method/market.editAlbum
func (vk *VK) Market_EditAlbum(ctx context.Context, req Market_EditAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.editAlbum", ctx, values, &resp)
	return
}

type Market_EditComment_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// New comment text (required if 'attachments' are not specified), , 2048 symbols maximum.
	Message     *string
	Attachments *[]string
}

func (r Market_EditComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Market_EditComment Chages item comment's text
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.editComment
func (vk *VK) Market_EditComment(ctx context.Context, req Market_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.editComment", ctx, values, &resp)
	return
}

type Market_EditOrder_PaymentStatus string

const (
	Market_EditOrder_PaymentStatus_NotPaid  Market_EditOrder_PaymentStatus = "not_paid"
	Market_EditOrder_PaymentStatus_Paid     Market_EditOrder_PaymentStatus = "paid"
	Market_EditOrder_PaymentStatus_Returned Market_EditOrder_PaymentStatus = "returned"
)

type Market_EditOrder_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  Minimum: 0
	OrderId int
	//  MaxLength: 800
	MerchantComment *string
	//  Minimum: 0
	Status *int
	//  MaxLength: 60
	TrackNumber   *string
	PaymentStatus *Market_EditOrder_PaymentStatus
	//  Minimum: 0
	DeliveryPrice *int
	//  Minimum: 0
	//  Maximum: 100000
	Width *int
	//  Minimum: 0
	//  Maximum: 100000
	Length *int
	//  Minimum: 0
	//  Maximum: 100000
	Height *int
	//  Minimum: 0
	//  Maximum: 1e+08
	Weight *int
}

func (r Market_EditOrder_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setInt(values, "order_id", r.OrderId)
	if r.MerchantComment != nil {
		setString(values, "merchant_comment", *r.MerchantComment)
	}
	if r.Status != nil {
		setInt(values, "status", *r.Status)
	}
	if r.TrackNumber != nil {
		setString(values, "track_number", *r.TrackNumber)
	}
	if r.PaymentStatus != nil {
		setString(values, "payment_status", string(*r.PaymentStatus))
	}
	if r.DeliveryPrice != nil {
		setInt(values, "delivery_price", *r.DeliveryPrice)
	}
	if r.Width != nil {
		setInt(values, "width", *r.Width)
	}
	if r.Length != nil {
		setInt(values, "length", *r.Length)
	}
	if r.Height != nil {
		setInt(values, "height", *r.Height)
	}
	if r.Weight != nil {
		setInt(values, "weight", *r.Weight)
	}
	return
}

// Market_EditOrder Edit order
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketOrdersNoCartItems, Error_MarketInvalidDimensions, Error_MarketCantChangeVkpayStatus ]
//
// https://dev.vk.com/method/market.editOrder
func (vk *VK) Market_EditOrder(ctx context.Context, req Market_EditOrder_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 13+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.editOrder", ctx, values, &resp)
	return
}

type Market_Get_Request struct {
	// ID of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	//  Format: int64
	OwnerId int
	//  Default: 0
	//  Format: int32
	//  Minimum: 0
	AlbumId *int
	// Number of items to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Items update date from (format: yyyy-mm-dd)
	DateFrom *string
	// Items update date to (format: yyyy-mm-dd)
	DateTo *string
	// Add variants to response if exist
	NeedVariants *bool
	// Add disabled items to response
	WithDisabled *bool
}

func (r Market_Get_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.DateFrom != nil {
		setString(values, "date_from", *r.DateFrom)
	}
	if r.DateTo != nil {
		setString(values, "date_to", *r.DateTo)
	}
	if r.NeedVariants != nil {
		setBool(values, "need_variants", *r.NeedVariants)
	}
	if r.WithDisabled != nil {
		setBool(values, "with_disabled", *r.WithDisabled)
	}
	return
}

// Market_Get Returns items list for a community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.get
func (vk *VK) Market_Get(ctx context.Context, req Market_Get_Request, options ...Option) (resp Market_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.get", ctx, values, &resp)
	return
}

// Market_GetExtended Returns items list for a community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.get
func (vk *VK) Market_GetExtended(ctx context.Context, req Market_Get_Request, options ...Option) (resp Market_GetExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.get", ctx, values, &resp)
	return
}

type Market_GetAlbumById_Request struct {
	// identifier of an album owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	AlbumIds *[]int
}

func (r Market_GetAlbumById_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	return
}

// Market_GetAlbumById Returns items album's data
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getAlbumById
func (vk *VK) Market_GetAlbumById(ctx context.Context, req Market_GetAlbumById_Request, options ...Option) (resp Market_GetAlbumById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getAlbumById", ctx, values, &resp)
	return
}

type Market_GetAlbums_Request struct {
	// ID of an items owner community.
	//  Format: int64
	OwnerId int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of items to return.
	//  Default: 50
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r Market_GetAlbums_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Market_GetAlbums Returns community's market collections list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getAlbums
func (vk *VK) Market_GetAlbums(ctx context.Context, req Market_GetAlbums_Request, options ...Option) (resp Market_GetAlbums_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getAlbums", ctx, values, &resp)
	return
}

type Market_GetById_Request struct {
	//  MaxItems: 100
	ItemIds *[]string
}

func (r Market_GetById_Request) fillIn(values url.Values) (err error) {
	if r.ItemIds != nil {
		setStrings(values, "item_ids", *r.ItemIds)
	}
	return
}

// Market_GetById Returns information about market items by their ids.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getById
func (vk *VK) Market_GetById(ctx context.Context, req Market_GetById_Request, options ...Option) (resp Market_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getById", ctx, values, &resp)
	return
}

// Market_GetByIdExtended Returns information about market items by their ids.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getById
func (vk *VK) Market_GetByIdExtended(ctx context.Context, req Market_GetById_Request, options ...Option) (resp Market_GetByIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getById", ctx, values, &resp)
	return
}

type Market_GetCategories_Request struct {
	// Number of results to return.
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
}

func (r Market_GetCategories_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Market_GetCategories Returns a list of market categories.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getCategories
func (vk *VK) Market_GetCategories(ctx context.Context, req Market_GetCategories_Request, options ...Option) (resp Market_GetCategories_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getCategories", ctx, values, &resp)
	return
}

type Market_GetComments_Sort string

const (
	Market_GetComments_Sort_OldToNew Market_GetComments_Sort = "asc"
	Market_GetComments_Sort_NewToOld Market_GetComments_Sort = "desc"
)

type Market_GetComments_Request struct {
	// ID of an item owner community
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
	// '1' — to return likes info.
	NeedLikes *bool
	// ID of a comment to start a list from (details below).
	//  Minimum: 0
	StartCommentId *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of results to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// Sort order ('asc' — from old to new, 'desc' — from new to old)
	//  Default: asc
	Sort *Market_GetComments_Sort
	// '1' — comments will be returned as numbered objects, in addition lists of 'profiles' and 'groups' objects will be returned.
	Extended *bool
	Fields   *[]Users_Fields
}

func (r Market_GetComments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.StartCommentId != nil {
		setInt(values, "start_comment_id", *r.StartCommentId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Market_GetComments Returns comments list for an item.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketCommentsClosed ]
//
// https://dev.vk.com/method/market.getComments
func (vk *VK) Market_GetComments(ctx context.Context, req Market_GetComments_Request, options ...Option) (resp Market_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getComments", ctx, values, &resp)
	return
}

type Market_GetGroupOrders_Request struct {
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 1
	//  Maximum: 50
	Count *int
}

func (r Market_GetGroupOrders_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Market_GetGroupOrders Get market orders
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketExtendedNotEnabled ]
//
// https://dev.vk.com/method/market.getGroupOrders
func (vk *VK) Market_GetGroupOrders(ctx context.Context, req Market_GetGroupOrders_Request, options ...Option) (resp Market_GetGroupOrders_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getGroupOrders", ctx, values, &resp)
	return
}

type Market_GetOrderById_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Minimum: 0
	OrderId  int
	Extended *bool
}

func (r Market_GetOrderById_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	setInt(values, "order_id", r.OrderId)
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Market_GetOrderById Get order
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getOrderById
func (vk *VK) Market_GetOrderById(ctx context.Context, req Market_GetOrderById_Request, options ...Option) (resp Market_GetOrderById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getOrderById", ctx, values, &resp)
	return
}

type Market_GetOrderItems_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Minimum: 0
	OrderId int
	//  Minimum: 0
	Offset *int
	//  Default: 50
	//  Minimum: 0
	Count *int
}

func (r Market_GetOrderItems_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	setInt(values, "order_id", r.OrderId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Market_GetOrderItems Get market items in the order
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getOrderItems
func (vk *VK) Market_GetOrderItems(ctx context.Context, req Market_GetOrderItems_Request, options ...Option) (resp Market_GetOrderItems_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getOrderItems", ctx, values, &resp)
	return
}

type Market_GetOrders_Request struct {
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 10
	Count *int
	// Orders status updated date from (format: yyyy-mm-dd)
	DateFrom *string
	// Orders status updated date to (format: yyyy-mm-dd)
	DateTo *string
}

func (r Market_GetOrders_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.DateFrom != nil {
		setString(values, "date_from", *r.DateFrom)
	}
	if r.DateTo != nil {
		setString(values, "date_to", *r.DateTo)
	}
	return
}

// Market_GetOrders ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getOrders
func (vk *VK) Market_GetOrders(ctx context.Context, req Market_GetOrders_Request, options ...Option) (resp Market_GetOrders_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getOrders", ctx, values, &resp)
	return
}

// Market_GetOrdersExtended ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.getOrders
func (vk *VK) Market_GetOrdersExtended(ctx context.Context, req Market_GetOrders_Request, options ...Option) (resp Market_GetOrdersExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.getOrders", ctx, values, &resp)
	return
}

type Market_RemoveFromAlbum_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
	//  Minimum: 0
	AlbumIds *[]int
}

func (r Market_RemoveFromAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	return
}

// Market_RemoveFromAlbum Removes an item from one or multiple collections.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketAlbumNotFound, Error_MarketItemNotFound, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.removeFromAlbum
func (vk *VK) Market_RemoveFromAlbum(ctx context.Context, req Market_RemoveFromAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.removeFromAlbum", ctx, values, &resp)
	return
}

type Market_ReorderAlbums_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Collection ID.
	AlbumId int
	// ID of a collection to place current collection before it.
	//  Minimum: 0
	Before *int
	// ID of a collection to place current collection after it.
	//  Minimum: 0
	After *int
}

func (r Market_ReorderAlbums_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "album_id", r.AlbumId)
	if r.Before != nil {
		setInt(values, "before", *r.Before)
	}
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Market_ReorderAlbums Reorders the collections list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketAlbumNotFound, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.reorderAlbums
func (vk *VK) Market_ReorderAlbums(ctx context.Context, req Market_ReorderAlbums_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.reorderAlbums", ctx, values, &resp)
	return
}

type Market_ReorderItems_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// ID of a collection to reorder items in. Set 0 to reorder full items list.
	AlbumId *int
	// Item ID.
	//  Minimum: 0
	ItemId int
	// ID of an item to place current item before it.
	//  Minimum: 0
	Before *int
	// ID of an item to place current item after it.
	//  Minimum: 0
	After *int
}

func (r Market_ReorderItems_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	setInt(values, "item_id", r.ItemId)
	if r.Before != nil {
		setInt(values, "before", *r.Before)
	}
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Market_ReorderItems Changes item place in a collection.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketAlbumNotFound, Error_MarketItemNotFound, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.reorderItems
func (vk *VK) Market_ReorderItems(ctx context.Context, req Market_ReorderItems_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.reorderItems", ctx, values, &resp)
	return
}

type Market_Report_Reason int

const (
	Market_Report_Reason_Spam             Market_Report_Reason = 0
	Market_Report_Reason_ChildPornography Market_Report_Reason = 1
	Market_Report_Reason_Extremism        Market_Report_Reason = 2
	Market_Report_Reason_Violence         Market_Report_Reason = 3
	Market_Report_Reason_DrugPropaganda   Market_Report_Reason = 4
	Market_Report_Reason_AdultMaterial    Market_Report_Reason = 5
	Market_Report_Reason_InsultAbuse      Market_Report_Reason = 6
)

type Market_Report_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Item ID.
	//  Minimum: 0
	ItemId int
	// Complaint reason. Possible values: *'0' — spam,, *'1' — child porn,, *'2' — extremism,, *'3' — violence,, *'4' — drugs propaganda,, *'5' — adult materials,, *'6' — insult.
	//  Default: 0
	//  Minimum: 0
	Reason *Market_Report_Reason
}

func (r Market_Report_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Market_Report Sends a complaint to the item.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.report
func (vk *VK) Market_Report(ctx context.Context, req Market_Report_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.report", ctx, values, &resp)
	return
}

type Market_ReportComment_Reason int

const (
	Market_ReportComment_Reason_Spam             Market_ReportComment_Reason = 0
	Market_ReportComment_Reason_ChildPornography Market_ReportComment_Reason = 1
	Market_ReportComment_Reason_Extremism        Market_ReportComment_Reason = 2
	Market_ReportComment_Reason_Violence         Market_ReportComment_Reason = 3
	Market_ReportComment_Reason_DrugPropaganda   Market_ReportComment_Reason = 4
	Market_ReportComment_Reason_AdultMaterial    Market_ReportComment_Reason = 5
	Market_ReportComment_Reason_InsultAbuse      Market_ReportComment_Reason = 6
)

type Market_ReportComment_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// Complaint reason. Possible values: *'0' — spam,, *'1' — child porn,, *'2' — extremism,, *'3' — violence,, *'4' — drugs propaganda,, *'5' — adult materials,, *'6' — insult.
	//  Minimum: 0
	Reason Market_ReportComment_Reason
}

func (r Market_ReportComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	setInt(values, "reason", int(r.Reason))
	return
}

// Market_ReportComment Sends a complaint to the item's comment.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.reportComment
func (vk *VK) Market_ReportComment(ctx context.Context, req Market_ReportComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.reportComment", ctx, values, &resp)
	return
}

type Market_Restore_Request struct {
	// ID of an item owner community.
	//  Format: int64
	OwnerId int
	// Deleted item ID.
	//  Minimum: 0
	ItemId int
}

func (r Market_Restore_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	return
}

// Market_Restore Restores recently deleted item
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessMarket, Error_MarketRestoreTooLate, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/market.restore
func (vk *VK) Market_Restore(ctx context.Context, req Market_Restore_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.restore", ctx, values, &resp)
	return
}

type Market_RestoreComment_Request struct {
	// identifier of an item owner community, "Note that community id in the 'owner_id' parameter should be negative number. For example 'owner_id'=-1 matches the [vk.com/apiclub|VK API] community "
	//  Format: int64
	OwnerId int
	// deleted comment id
	//  Minimum: 0
	CommentId int
}

func (r Market_RestoreComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	return
}

// Market_RestoreComment Restores a recently deleted comment
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.restoreComment
func (vk *VK) Market_RestoreComment(ctx context.Context, req Market_RestoreComment_Request, options ...Option) (resp Market_RestoreComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.restoreComment", ctx, values, &resp)
	return
}

type Market_Search_Sort int

const (
	Market_Search_Sort_Default   Market_Search_Sort = 0
	Market_Search_Sort_Date      Market_Search_Sort = 1
	Market_Search_Sort_Price     Market_Search_Sort = 2
	Market_Search_Sort_Relevance Market_Search_Sort = 3
)

type Market_Search_Rev int

const (
	Market_Search_Rev_Normal  Market_Search_Rev = 0
	Market_Search_Rev_Reverse Market_Search_Rev = 1
)

type Market_Search_Request struct {
	// ID of an items owner community.
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	AlbumId *int
	// Search query, for example "pink slippers".
	Q *string
	// Minimum item price value.
	//  Minimum: 0
	PriceFrom *int
	// Maximum item price value.
	//  Minimum: 0
	PriceTo *int
	//  Default: 0
	Sort *Market_Search_Sort
	// '0' — do not use reverse order, '1' — use reverse order
	//  Default: 1
	//  Minimum: 0
	Rev *Market_Search_Rev
	// Offset needed to return a specific subset of results.
	//  Minimum: 0
	Offset *int
	// Number of items to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	//  MaxItems: 2
	Status *[]int
	// Add variants to response if exist
	NeedVariants *bool
}

func (r Market_Search_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.PriceFrom != nil {
		setInt(values, "price_from", *r.PriceFrom)
	}
	if r.PriceTo != nil {
		setInt(values, "price_to", *r.PriceTo)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.Rev != nil {
		setInt(values, "rev", int(*r.Rev))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Status != nil {
		setInts(values, "status", *r.Status)
	}
	if r.NeedVariants != nil {
		setBool(values, "need_variants", *r.NeedVariants)
	}
	return
}

// Market_Search Searches market items in a community's catalog
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.search
func (vk *VK) Market_Search(ctx context.Context, req Market_Search_Request, options ...Option) (resp Market_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.search", ctx, values, &resp)
	return
}

// Market_SearchExtended Searches market items in a community's catalog
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.search
func (vk *VK) Market_SearchExtended(ctx context.Context, req Market_Search_Request, options ...Option) (resp Market_SearchExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("market.search", ctx, values, &resp)
	return
}

type Market_SearchItems_SortBy int

const (
	Market_SearchItems_SortBy_Date      Market_SearchItems_SortBy = 1
	Market_SearchItems_SortBy_Price     Market_SearchItems_SortBy = 2
	Market_SearchItems_SortBy_Relevance Market_SearchItems_SortBy = 3
)

type Market_SearchItems_SortDirection int

const (
	Market_SearchItems_SortDirection_0 Market_SearchItems_SortDirection = 0
	Market_SearchItems_SortDirection_1 Market_SearchItems_SortDirection = 1
)

type Market_SearchItems_Request struct {
	Q string
	//  Default: 0
	Offset *int
	//  Default: 30
	//  Minimum: 0
	//  Maximum: 300
	Count *int
	//  Minimum: 0
	CategoryId *int
	//  Minimum: 0
	PriceFrom *int
	//  Minimum: 0
	PriceTo *int
	//  Default: 3
	SortBy *Market_SearchItems_SortBy
	//  Default: 1
	SortDirection *Market_SearchItems_SortDirection
	//  Minimum: 0
	Country *int
	//  Minimum: 0
	City *int
}

func (r Market_SearchItems_Request) fillIn(values url.Values) (err error) {
	setString(values, "q", r.Q)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.CategoryId != nil {
		setInt(values, "category_id", *r.CategoryId)
	}
	if r.PriceFrom != nil {
		setInt(values, "price_from", *r.PriceFrom)
	}
	if r.PriceTo != nil {
		setInt(values, "price_to", *r.PriceTo)
	}
	if r.SortBy != nil {
		setInt(values, "sort_by", int(*r.SortBy))
	}
	if r.SortDirection != nil {
		setInt(values, "sort_direction", int(*r.SortDirection))
	}
	if r.Country != nil {
		setInt(values, "country", *r.Country)
	}
	if r.City != nil {
		setInt(values, "city", *r.City)
	}
	return
}

// Market_SearchItems ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/market.searchItems
func (vk *VK) Market_SearchItems(ctx context.Context, req Market_SearchItems_Request, options ...Option) (resp Market_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("market.searchItems", ctx, values, &resp)
	return
}

type Messages_AddChatUser_Request struct {
	// Chat ID.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId int
	// ID of the user to be added to the chat.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Minimum: 0
	//  Maximum: 1000
	VisibleMessagesCount *int
}

func (r Messages_AddChatUser_Request) fillIn(values url.Values) (err error) {
	setInt(values, "chat_id", r.ChatId)
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.VisibleMessagesCount != nil {
		setInt(values, "visible_messages_count", *r.VisibleMessagesCount)
	}
	return
}

// Messages_AddChatUser Adds a new user to a chat.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits, Error_MessagesChatNotAdmin, Error_MessagesMessageRequestAlreadySent, Error_MessagesContactNotFound, Error_MessagesChatDisabled, Error_MessagesMemberAccessToGroupDenied, Error_MessagesChatUnsupported, Error_MessagesGroupPeerAccess ]
//
// https://dev.vk.com/method/messages.addChatUser
func (vk *VK) Messages_AddChatUser(ctx context.Context, req Messages_AddChatUser_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.addChatUser", ctx, values, &resp)
	return
}

type Messages_AllowMessagesFromGroup_Request struct {
	// Group ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	//  MaxLength: 256
	Key *string
}

func (r Messages_AllowMessagesFromGroup_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.Key != nil {
		setString(values, "key", *r.Key)
	}
	return
}

// Messages_AllowMessagesFromGroup Allows sending messages from community to the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesIntentCantUse ]
//
// https://dev.vk.com/method/messages.allowMessagesFromGroup
func (vk *VK) Messages_AllowMessagesFromGroup(ctx context.Context, req Messages_AllowMessagesFromGroup_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.allowMessagesFromGroup", ctx, values, &resp)
	return
}

type Messages_CreateChat_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserIds *[]int
	// Chat title.
	Title *string
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_CreateChat_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_CreateChat Creates a chat with several participants.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.createChat
func (vk *VK) Messages_CreateChat(ctx context.Context, req Messages_CreateChat_Request, options ...Option) (resp Messages_CreateChat_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.createChat", ctx, values, &resp)
	return
}

type Messages_Delete_Request struct {
	//  MaxItems: 1000
	//  Minimum: 0
	MessageIds *[]int
	// '1' — to mark message as spam.
	Spam *bool
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// '1' — delete message for for all.
	//  Default: false
	DeleteForAll *bool
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	PeerId *int
	//  MaxItems: 100
	//  Minimum: 0
	Cmids *[]int
}

func (r Messages_Delete_Request) fillIn(values url.Values) (err error) {
	if r.MessageIds != nil {
		setInts(values, "message_ids", *r.MessageIds)
	}
	if r.Spam != nil {
		setBool(values, "spam", *r.Spam)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.DeleteForAll != nil {
		setBool(values, "delete_for_all", *r.DeleteForAll)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.Cmids != nil {
		setInts(values, "cmids", *r.Cmids)
	}
	return
}

// Messages_Delete Deletes one or more messages.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesCantDeleteForAll ]
//
// https://dev.vk.com/method/messages.delete
func (vk *VK) Messages_Delete(ctx context.Context, req Messages_Delete_Request, options ...Option) (resp Messages_Delete_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.delete", ctx, values, &resp)
	return
}

type Messages_DeleteChatPhoto_Request struct {
	// Chat ID.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_DeleteChatPhoto_Request) fillIn(values url.Values) (err error) {
	setInt(values, "chat_id", r.ChatId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_DeleteChatPhoto Deletes a chat's cover picture.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotAdmin, Error_MessagesChatDisabled ]
//
// https://dev.vk.com/method/messages.deleteChatPhoto
func (vk *VK) Messages_DeleteChatPhoto(ctx context.Context, req Messages_DeleteChatPhoto_Request, options ...Option) (resp Messages_DeleteChatPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.deleteChatPhoto", ctx, values, &resp)
	return
}

type Messages_DeleteConversation_Request struct {
	// User ID. To clear a chat history use 'chat_id'
	UserId *int
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	PeerId *int
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_DeleteConversation_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_DeleteConversation Deletes all private messages in a conversation.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.deleteConversation
func (vk *VK) Messages_DeleteConversation(ctx context.Context, req Messages_DeleteConversation_Request, options ...Option) (resp Messages_DeleteConversation_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.deleteConversation", ctx, values, &resp)
	return
}

type Messages_DenyMessagesFromGroup_Request struct {
	// Group ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Messages_DenyMessagesFromGroup_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Messages_DenyMessagesFromGroup Denies sending message from community to the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.denyMessagesFromGroup
func (vk *VK) Messages_DenyMessagesFromGroup(ctx context.Context, req Messages_DenyMessagesFromGroup_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.denyMessagesFromGroup", ctx, values, &resp)
	return
}

type Messages_Edit_Request struct {
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	//  Format: int32
	PeerId int
	// (Required if 'attachments' is not set.) Text of the message.
	//  MaxLength: 9000
	Message *string
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// (Required if 'message' is not set.) List of objects attached to the message, separated by commas, in the following format: "<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'wall' — wall post, '<owner_id>' — ID of the media attachment owner. '<media_id>' — media attachment ID. Example: "photo100172_166443618"
	Attachment *string
	// '1' — to keep forwarded, messages.
	KeepForwardMessages *bool
	// '1' — to keep attached snippets.
	KeepSnippets *bool
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	//  Default: false
	DontParseLinks *bool
	//  Default: false
	DisableMentions *bool
	//  Format: int32
	//  Minimum: 0
	MessageId *int
	//  Format: int32
	//  Minimum: 0
	ConversationMessageId *int
	Template              *string
	Keyboard              *string
}

func (r Messages_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.Attachment != nil {
		setString(values, "attachment", *r.Attachment)
	}
	if r.KeepForwardMessages != nil {
		setBool(values, "keep_forward_messages", *r.KeepForwardMessages)
	}
	if r.KeepSnippets != nil {
		setBool(values, "keep_snippets", *r.KeepSnippets)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.DontParseLinks != nil {
		setBool(values, "dont_parse_links", *r.DontParseLinks)
	}
	if r.DisableMentions != nil {
		setBool(values, "disable_mentions", *r.DisableMentions)
	}
	if r.MessageId != nil {
		setInt(values, "message_id", *r.MessageId)
	}
	if r.ConversationMessageId != nil {
		setInt(values, "conversation_message_id", *r.ConversationMessageId)
	}
	if r.Template != nil {
		setString(values, "template", *r.Template)
	}
	if r.Keyboard != nil {
		setString(values, "keyboard", *r.Keyboard)
	}
	return
}

// Messages_Edit Edits the message.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesDenySend, Error_MessagesEditExpired, Error_MessagesTooBig, Error_MessagesEditKindDisallowed, Error_MessagesTooLongMessage, Error_MessagesChatUserNoAccess, Error_MessagesKeyboardInvalid, Error_MessagesTooManyPosts, Error_MessagesChatUnsupported, Error_MessagesChatBotFeature, Error_MessagesCantEditPinnedYet ]
//
// https://dev.vk.com/method/messages.edit
func (vk *VK) Messages_Edit(ctx context.Context, req Messages_Edit_Request, options ...Option) (resp Messages_Edit_Response, apiErr ApiError, err error) {
	values := make(url.Values, 16+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.edit", ctx, values, &resp)
	return
}

type Messages_EditChat_Request struct {
	// Chat ID.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId int
	// New title of the chat.
	Title *string
}

func (r Messages_EditChat_Request) fillIn(values url.Values) (err error) {
	setInt(values, "chat_id", r.ChatId)
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	return
}

// Messages_EditChat Edits the title of a chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotAdmin, Error_MessagesChatDisabled, Error_MessagesChatUnsupported ]
//
// https://dev.vk.com/method/messages.editChat
func (vk *VK) Messages_EditChat(ctx context.Context, req Messages_EditChat_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.editChat", ctx, values, &resp)
	return
}

type Messages_GetByConversationMessageId_Request struct {
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	PeerId int
	//  MaxItems: 100
	//  Minimum: 0
	ConversationMessageIds *[]int
	Fields                 *[]Users_Fields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetByConversationMessageId_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.ConversationMessageIds != nil {
		setInts(values, "conversation_message_ids", *r.ConversationMessageIds)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetByConversationMessageId Returns messages by their IDs within the conversation.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getByConversationMessageId
func (vk *VK) Messages_GetByConversationMessageId(ctx context.Context, req Messages_GetByConversationMessageId_Request, options ...Option) (resp Messages_GetByConversationMessageId_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getByConversationMessageId", ctx, values, &resp)
	return
}

// Messages_GetByConversationMessageIdExtended Returns messages by their IDs within the conversation.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getByConversationMessageId
func (vk *VK) Messages_GetByConversationMessageIdExtended(ctx context.Context, req Messages_GetByConversationMessageId_Request, options ...Option) (resp Messages_GetByConversationMessageIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getByConversationMessageId", ctx, values, &resp)
	return
}

type Messages_GetById_Request struct {
	//  Format: int32
	//  MaxItems: 100
	//  Minimum: 0
	MessageIds *[]int
	// Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	//  Default: 0
	//  Minimum: 0
	PreviewLength *int
	Fields        *[]Users_Fields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetById_Request) fillIn(values url.Values) (err error) {
	if r.MessageIds != nil {
		setInts(values, "message_ids", *r.MessageIds)
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetById Returns messages by their IDs.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getById
func (vk *VK) Messages_GetById(ctx context.Context, req Messages_GetById_Request, options ...Option) (resp Messages_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getById", ctx, values, &resp)
	return
}

// Messages_GetByIdExtended Returns messages by their IDs.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getById
func (vk *VK) Messages_GetByIdExtended(ctx context.Context, req Messages_GetById_Request, options ...Option) (resp Messages_GetByIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getById", ctx, values, &resp)
	return
}

type Messages_GetChatPreview_Request struct {
	//  Minimum: 0
	PeerId *int
	// Invitation link.
	Link   *string
	Fields *[]Users_Fields
}

func (r Messages_GetChatPreview_Request) fillIn(values url.Values) (err error) {
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.Link != nil {
		setString(values, "link", *r.Link)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Messages_GetChatPreview ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatUserNoAccess ]
//
// https://dev.vk.com/method/messages.getChatPreview
func (vk *VK) Messages_GetChatPreview(ctx context.Context, req Messages_GetChatPreview_Request, options ...Option) (resp Messages_GetChatPreview_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getChatPreview", ctx, values, &resp)
	return
}

type Messages_GetConversationMembers_Request struct {
	// Peer ID.
	//  Format: int32
	PeerId int
	Fields *[]Users_Fields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetConversationMembers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetConversationMembers Returns a list of IDs of users participating in a chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatUserNoAccess ]
//
// https://dev.vk.com/method/messages.getConversationMembers
func (vk *VK) Messages_GetConversationMembers(ctx context.Context, req Messages_GetConversationMembers_Request, options ...Option) (resp Messages_GetConversationMembers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getConversationMembers", ctx, values, &resp)
	return
}

type Messages_GetConversations_Filter string

const (
	Messages_GetConversations_Filter_All        Messages_GetConversations_Filter = "all"
	Messages_GetConversations_Filter_Archive    Messages_GetConversations_Filter = "archive"
	Messages_GetConversations_Filter_Important  Messages_GetConversations_Filter = "important"
	Messages_GetConversations_Filter_Unanswered Messages_GetConversations_Filter = "unanswered"
	Messages_GetConversations_Filter_Unread     Messages_GetConversations_Filter = "unread"
)

type Messages_GetConversations_Request struct {
	// Offset needed to return a specific subset of conversations.
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of conversations to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// Filter to apply: 'all' — all conversations, 'unread' — conversations with unread messages, 'important' — conversations, marked as important (only for community messages), 'unanswered' — conversations, marked as unanswered (only for community messages)
	//  Default: all
	Filter *Messages_GetConversations_Filter
	// '1' — return extra information about users and communities
	Extended *bool
	// ID of the message from what to return dialogs.
	//  Minimum: 0
	StartMessageId *int
	Fields         *[]Base_UserGroupFields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetConversations_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Filter != nil {
		setString(values, "filter", string(*r.Filter))
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.StartMessageId != nil {
		setInt(values, "start_message_id", *r.StartMessageId)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetConversations Returns a list of the current user's conversations.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotExist, Error_MessagesContactNotFound, Error_MessagesChatUserNoAccess ]
//
// https://dev.vk.com/method/messages.getConversations
func (vk *VK) Messages_GetConversations(ctx context.Context, req Messages_GetConversations_Request, options ...Option) (resp Messages_GetConversations_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getConversations", ctx, values, &resp)
	return
}

type Messages_GetConversationsById_Request struct {
	//  MaxItems: 100
	PeerIds *[]int
	Fields  *[]Base_UserGroupFields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetConversationsById_Request) fillIn(values url.Values) (err error) {
	if r.PeerIds != nil {
		setInts(values, "peer_ids", *r.PeerIds)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetConversationsById Returns conversations by their IDs
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotExist, Error_MessagesChatUserNoAccess, Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.getConversationsById
func (vk *VK) Messages_GetConversationsById(ctx context.Context, req Messages_GetConversationsById_Request, options ...Option) (resp Messages_GetConversationsById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getConversationsById", ctx, values, &resp)
	return
}

// Messages_GetConversationsByIdExtended Returns conversations by their IDs
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotExist, Error_MessagesChatUserNoAccess, Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.getConversationsById
func (vk *VK) Messages_GetConversationsByIdExtended(ctx context.Context, req Messages_GetConversationsById_Request, options ...Option) (resp Messages_GetConversationsByIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getConversationsById", ctx, values, &resp)
	return
}

type Messages_GetHistory_Rev int

const (
	Messages_GetHistory_Rev_Chronological        Messages_GetHistory_Rev = 1
	Messages_GetHistory_Rev_ReverseChronological Messages_GetHistory_Rev = 0
)

type Messages_GetHistory_Request struct {
	// Offset needed to return a specific subset of messages.
	Offset *int
	// Number of messages to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// ID of the user whose message history you want to return.
	UserId *int
	//  Format: int32
	PeerId *int
	// Starting message ID from which to return history.
	StartMessageId *int
	// Sort order: '1' — return messages in chronological order. '0' — return messages in reverse chronological order.
	Rev    *Messages_GetHistory_Rev
	Fields *[]Users_Fields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetHistory_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.StartMessageId != nil {
		setInt(values, "start_message_id", *r.StartMessageId)
	}
	if r.Rev != nil {
		setInt(values, "rev", int(*r.Rev))
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetHistory Returns message history for the specified user or group chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.getHistory
func (vk *VK) Messages_GetHistory(ctx context.Context, req Messages_GetHistory_Request, options ...Option) (resp Messages_GetHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getHistory", ctx, values, &resp)
	return
}

// Messages_GetHistoryExtended Returns message history for the specified user or group chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.getHistory
func (vk *VK) Messages_GetHistoryExtended(ctx context.Context, req Messages_GetHistory_Request, options ...Option) (resp Messages_GetHistoryExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getHistory", ctx, values, &resp)
	return
}

type Messages_GetHistoryAttachments_MediaType string

const (
	Messages_GetHistoryAttachments_MediaType_Audio        Messages_GetHistoryAttachments_MediaType = "audio"
	Messages_GetHistoryAttachments_MediaType_AudioMessage Messages_GetHistoryAttachments_MediaType = "audio_message"
	Messages_GetHistoryAttachments_MediaType_Doc          Messages_GetHistoryAttachments_MediaType = "doc"
	Messages_GetHistoryAttachments_MediaType_Graffiti     Messages_GetHistoryAttachments_MediaType = "graffiti"
	Messages_GetHistoryAttachments_MediaType_Link         Messages_GetHistoryAttachments_MediaType = "link"
	Messages_GetHistoryAttachments_MediaType_Market       Messages_GetHistoryAttachments_MediaType = "market"
	Messages_GetHistoryAttachments_MediaType_Photo        Messages_GetHistoryAttachments_MediaType = "photo"
	Messages_GetHistoryAttachments_MediaType_Share        Messages_GetHistoryAttachments_MediaType = "share"
	Messages_GetHistoryAttachments_MediaType_Video        Messages_GetHistoryAttachments_MediaType = "video"
	Messages_GetHistoryAttachments_MediaType_Wall         Messages_GetHistoryAttachments_MediaType = "wall"
)

type Messages_GetHistoryAttachments_Request struct {
	// Peer ID. ", For group chat: '2000000000 + chat ID' , , For community: '-community ID'"
	PeerId int
	// Type of media files to return: *'photo',, *'video',, *'audio',, *'doc',, *'link'.,*'market'.,*'wall'.,*'share'
	//  Default: photo
	MediaType *Messages_GetHistoryAttachments_MediaType
	// Message ID to start return results from.
	StartFrom *string
	// Number of objects to return.
	//  Default: 30
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// '1' — to return photo sizes in a
	PhotoSizes *bool
	Fields     *[]Users_Fields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId       *int
	PreserveOrder *bool
	//  Default: 45
	//  Minimum: 0
	//  Maximum: 45
	MaxForwardsLevel *int
}

func (r Messages_GetHistoryAttachments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.MediaType != nil {
		setString(values, "media_type", string(*r.MediaType))
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.PhotoSizes != nil {
		setBool(values, "photo_sizes", *r.PhotoSizes)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.PreserveOrder != nil {
		setBool(values, "preserve_order", *r.PreserveOrder)
	}
	if r.MaxForwardsLevel != nil {
		setInt(values, "max_forwards_level", *r.MaxForwardsLevel)
	}
	return
}

// Messages_GetHistoryAttachments Returns media files from the dialog or group chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getHistoryAttachments
func (vk *VK) Messages_GetHistoryAttachments(ctx context.Context, req Messages_GetHistoryAttachments_Request, options ...Option) (resp Messages_GetHistoryAttachments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getHistoryAttachments", ctx, values, &resp)
	return
}

type Messages_GetImportantMessages_Request struct {
	// Amount of needed important messages.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	//  Minimum: 0
	Offset *int
	//  Minimum: 0
	StartMessageId *int
	// Maximum length of messages body.
	//  Minimum: 0
	PreviewLength *int
	Fields        *[]Base_UserGroupFields
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetImportantMessages_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.StartMessageId != nil {
		setInt(values, "start_message_id", *r.StartMessageId)
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetImportantMessages Returns a list of user's important messages.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getImportantMessages
func (vk *VK) Messages_GetImportantMessages(ctx context.Context, req Messages_GetImportantMessages_Request, options ...Option) (resp Messages_GetImportantMessages_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getImportantMessages", ctx, values, &resp)
	return
}

// Messages_GetImportantMessagesExtended Returns a list of user's important messages.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getImportantMessages
func (vk *VK) Messages_GetImportantMessagesExtended(ctx context.Context, req Messages_GetImportantMessages_Request, options ...Option) (resp Messages_GetImportantMessagesExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getImportantMessages", ctx, values, &resp)
	return
}

type Messages_GetIntentUsers_Intent string

const (
	Messages_GetIntentUsers_Intent_ConfirmedNotification Messages_GetIntentUsers_Intent = "confirmed_notification"
	Messages_GetIntentUsers_Intent_NonPromoNewsletter    Messages_GetIntentUsers_Intent = "non_promo_newsletter"
	Messages_GetIntentUsers_Intent_PromoNewsletter       Messages_GetIntentUsers_Intent = "promo_newsletter"
)

type Messages_GetIntentUsers_Request struct {
	Intent Messages_GetIntentUsers_Intent
	//  Minimum: 0
	//  Maximum: 100
	SubscribeId *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count    *int
	Extended *bool
	NameCase *[]string
	Fields   *[]string
}

func (r Messages_GetIntentUsers_Request) fillIn(values url.Values) (err error) {
	setString(values, "intent", string(r.Intent))
	if r.SubscribeId != nil {
		setInt(values, "subscribe_id", *r.SubscribeId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.NameCase != nil {
		setStrings(values, "name_case", *r.NameCase)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	return
}

// Messages_GetIntentUsers ...
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesIntentCantUse ]
//
// https://dev.vk.com/method/messages.getIntentUsers
func (vk *VK) Messages_GetIntentUsers(ctx context.Context, req Messages_GetIntentUsers_Request, options ...Option) (resp Messages_GetIntentUsers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getIntentUsers", ctx, values, &resp)
	return
}

type Messages_GetInviteLink_Request struct {
	// Destination ID.
	//  Minimum: 0
	PeerId int
	// 1 — to generate new link (revoke previous), 0 — to return previous link.
	//  Default: false
	Reset *bool
	// Group ID
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_GetInviteLink_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.Reset != nil {
		setBool(values, "reset", *r.Reset)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_GetInviteLink ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesCantSeeInviteLink, Error_MessagesCantChangeInviteLink ]
//
// https://dev.vk.com/method/messages.getInviteLink
func (vk *VK) Messages_GetInviteLink(ctx context.Context, req Messages_GetInviteLink_Request, options ...Option) (resp Messages_GetInviteLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getInviteLink", ctx, values, &resp)
	return
}

type Messages_GetLastActivity_Request struct {
	// User ID.
	//  Format: int64
	UserId int
}

func (r Messages_GetLastActivity_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	return
}

// Messages_GetLastActivity Returns a user's current status and date of last activity.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getLastActivity
func (vk *VK) Messages_GetLastActivity(ctx context.Context, req Messages_GetLastActivity_Request, options ...Option) (resp Messages_GetLastActivity_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getLastActivity", ctx, values, &resp)
	return
}

type Messages_GetLongPollHistory_Request struct {
	// Last value of the 'ts' parameter returned from the Long Poll server or by using [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	//  Minimum: 0
	Ts *int
	// Last value of 'pts' parameter returned from the Long Poll server or by using [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	//  Minimum: 0
	Pts *int
	// Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	//  Minimum: 0
	PreviewLength *int
	// '1' — to return history with online users only.
	Onlines *bool
	//  Default: photo,photo_medium_rec,sex,online,screen_name
	Fields *[]Users_Fields
	// Maximum number of events to return.
	//  Default: 1000
	//  Minimum: 1000
	EventsLimit *int
	// Maximum number of messages to return.
	//  Default: 200
	//  Minimum: 200
	MsgsLimit *int
	// Maximum ID of the message among existing ones in the local copy. Both messages received with API methods (for example, , ), and data received from a Long Poll server (events with code 4) are taken into account.
	//  Minimum: 0
	MaxMsgId *int
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	//  Minimum: 0
	LpVersion *int
	//  Default: 0
	//  Minimum: 0
	//  Maximum: 2000
	LastN       *int
	Credentials *bool
	//  Default: false
	Extended *bool
}

func (r Messages_GetLongPollHistory_Request) fillIn(values url.Values) (err error) {
	if r.Ts != nil {
		setInt(values, "ts", *r.Ts)
	}
	if r.Pts != nil {
		setInt(values, "pts", *r.Pts)
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	if r.Onlines != nil {
		setBool(values, "onlines", *r.Onlines)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.EventsLimit != nil {
		setInt(values, "events_limit", *r.EventsLimit)
	}
	if r.MsgsLimit != nil {
		setInt(values, "msgs_limit", *r.MsgsLimit)
	}
	if r.MaxMsgId != nil {
		setInt(values, "max_msg_id", *r.MaxMsgId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.LpVersion != nil {
		setInt(values, "lp_version", *r.LpVersion)
	}
	if r.LastN != nil {
		setInt(values, "last_n", *r.LastN)
	}
	if r.Credentials != nil {
		setBool(values, "credentials", *r.Credentials)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Messages_GetLongPollHistory Returns updates in user's private messages.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesTooOldPts, Error_MessagesTooNewPts, Error_Timeout ]
//
// https://dev.vk.com/method/messages.getLongPollHistory
func (vk *VK) Messages_GetLongPollHistory(ctx context.Context, req Messages_GetLongPollHistory_Request, options ...Option) (resp Messages_GetLongPollHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 15+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getLongPollHistory", ctx, values, &resp)
	return
}

type Messages_GetLongPollServer_Request struct {
	// '1' — to return the 'pts' field, needed for the [vk.com/dev/messages.getLongPollHistory|messages.getLongPollHistory] method.
	NeedPts *bool
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Long poll version
	//  Default: 0
	//  Minimum: 0
	LpVersion *int
}

func (r Messages_GetLongPollServer_Request) fillIn(values url.Values) (err error) {
	if r.NeedPts != nil {
		setBool(values, "need_pts", *r.NeedPts)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.LpVersion != nil {
		setInt(values, "lp_version", *r.LpVersion)
	}
	return
}

// Messages_GetLongPollServer Returns data required for connection to a Long Poll server.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.getLongPollServer
func (vk *VK) Messages_GetLongPollServer(ctx context.Context, req Messages_GetLongPollServer_Request, options ...Option) (resp Messages_GetLongPollServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.getLongPollServer", ctx, values, &resp)
	return
}

type Messages_IsMessagesFromGroupAllowed_Request struct {
	// Group ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// User ID.
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Messages_IsMessagesFromGroupAllowed_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setInt(values, "user_id", r.UserId)
	return
}

// Messages_IsMessagesFromGroupAllowed Returns information whether sending messages from the community to current user is allowed.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesIntentCantUse ]
//
// https://dev.vk.com/method/messages.isMessagesFromGroupAllowed
func (vk *VK) Messages_IsMessagesFromGroupAllowed(ctx context.Context, req Messages_IsMessagesFromGroupAllowed_Request, options ...Option) (resp Messages_IsMessagesFromGroupAllowed_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.isMessagesFromGroupAllowed", ctx, values, &resp)
	return
}

type Messages_JoinChatByInviteLink_Request struct {
	// Invitation link.
	Link string
}

func (r Messages_JoinChatByInviteLink_Request) fillIn(values url.Values) (err error) {
	setString(values, "link", r.Link)
	return
}

// Messages_JoinChatByInviteLink ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatUserNoAccess, Error_Limits ]
//
// https://dev.vk.com/method/messages.joinChatByInviteLink
func (vk *VK) Messages_JoinChatByInviteLink(ctx context.Context, req Messages_JoinChatByInviteLink_Request, options ...Option) (resp Messages_JoinChatByInviteLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.joinChatByInviteLink", ctx, values, &resp)
	return
}

type Messages_MarkAsAnsweredConversation_Request struct {
	// ID of conversation to mark as important.
	PeerId int
	// '1' — to mark as answered, '0' — to remove the mark
	//  Default: 1
	Answered *bool
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_MarkAsAnsweredConversation_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.Answered != nil {
		setBool(values, "answered", *r.Answered)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_MarkAsAnsweredConversation Marks and unmarks conversations as unanswered.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.markAsAnsweredConversation
func (vk *VK) Messages_MarkAsAnsweredConversation(ctx context.Context, req Messages_MarkAsAnsweredConversation_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.markAsAnsweredConversation", ctx, values, &resp)
	return
}

type Messages_MarkAsImportant_Request struct {
	//  Default: []
	//  Minimum: 0
	MessageIds *[]int
	// '1' — to add a star (mark as important), '0' — to remove the star
	//  Minimum: 0
	Important *int
}

func (r Messages_MarkAsImportant_Request) fillIn(values url.Values) (err error) {
	if r.MessageIds != nil {
		setInts(values, "message_ids", *r.MessageIds)
	}
	if r.Important != nil {
		setInt(values, "important", *r.Important)
	}
	return
}

// Messages_MarkAsImportant Marks and unmarks messages as important (starred).
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.markAsImportant
func (vk *VK) Messages_MarkAsImportant(ctx context.Context, req Messages_MarkAsImportant_Request, options ...Option) (resp Messages_MarkAsImportant_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.markAsImportant", ctx, values, &resp)
	return
}

type Messages_MarkAsImportantConversation_Request struct {
	// ID of conversation to mark as important.
	PeerId int
	// '1' — to add a star (mark as important), '0' — to remove the star
	//  Default: 1
	Important *bool
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_MarkAsImportantConversation_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.Important != nil {
		setBool(values, "important", *r.Important)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_MarkAsImportantConversation Marks and unmarks conversations as important.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.markAsImportantConversation
func (vk *VK) Messages_MarkAsImportantConversation(ctx context.Context, req Messages_MarkAsImportantConversation_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.markAsImportantConversation", ctx, values, &resp)
	return
}

type Messages_MarkAsRead_Request struct {
	//  Default: []
	//  Format: int32
	//  Minimum: 0
	MessageIds *[]int
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	PeerId *int
	// Message ID to start from.
	//  Minimum: 0
	StartMessageId *int
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId                *int
	MarkConversationAsRead *bool
}

func (r Messages_MarkAsRead_Request) fillIn(values url.Values) (err error) {
	if r.MessageIds != nil {
		setInts(values, "message_ids", *r.MessageIds)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.StartMessageId != nil {
		setInt(values, "start_message_id", *r.StartMessageId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.MarkConversationAsRead != nil {
		setBool(values, "mark_conversation_as_read", *r.MarkConversationAsRead)
	}
	return
}

// Messages_MarkAsRead Marks messages as read.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.markAsRead
func (vk *VK) Messages_MarkAsRead(ctx context.Context, req Messages_MarkAsRead_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.markAsRead", ctx, values, &resp)
	return
}

type Messages_Pin_Request struct {
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	PeerId int
	// Message ID
	//  Minimum: 0
	MessageId *int
	// Conversation message ID
	//  Minimum: 0
	ConversationMessageId *int
}

func (r Messages_Pin_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.MessageId != nil {
		setInt(values, "message_id", *r.MessageId)
	}
	if r.ConversationMessageId != nil {
		setInt(values, "conversation_message_id", *r.ConversationMessageId)
	}
	return
}

// Messages_Pin Pin a message.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotAdmin, Error_MessagesCantPinOneTimeStory, Error_MessagesCantPinExpiringMessage ]
//
// https://dev.vk.com/method/messages.pin
func (vk *VK) Messages_Pin(ctx context.Context, req Messages_Pin_Request, options ...Option) (resp Messages_Pin_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.pin", ctx, values, &resp)
	return
}

type Messages_RemoveChatUser_Request struct {
	// Chat ID.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId int
	// ID of the user to be removed from the chat.
	//  Format: int64
	UserId *int
	//  Format: int64
	MemberId *int
}

func (r Messages_RemoveChatUser_Request) fillIn(values url.Values) (err error) {
	setInt(values, "chat_id", r.ChatId)
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.MemberId != nil {
		setInt(values, "member_id", *r.MemberId)
	}
	return
}

// Messages_RemoveChatUser Allows the current user to leave a chat or, if the current user started the chat, allows the user to remove another user from the chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotAdmin, Error_MessagesChatUserNotInChat, Error_MessagesContactNotFound, Error_MessagesChatDisabled, Error_MessagesChatUnsupported ]
//
// https://dev.vk.com/method/messages.removeChatUser
func (vk *VK) Messages_RemoveChatUser(ctx context.Context, req Messages_RemoveChatUser_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.removeChatUser", ctx, values, &resp)
	return
}

type Messages_Restore_Request struct {
	// ID of a previously-deleted message to restore.
	//  Minimum: 0
	MessageId int
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_Restore_Request) fillIn(values url.Values) (err error) {
	setInt(values, "message_id", r.MessageId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_Restore Restores a deleted message.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.restore
func (vk *VK) Messages_Restore(ctx context.Context, req Messages_Restore_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.restore", ctx, values, &resp)
	return
}

type Messages_Search_Request struct {
	// Search query string.
	//  MaxLength: 9000
	Q *string
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	PeerId *int
	// Date to search message before in Unixtime.
	//  Minimum: 0
	Date *int
	// Number of characters after which to truncate a previewed message. To preview the full message, specify '0'. "NOTE: Messages are not truncated by default. Messages are truncated by words."
	//  Default: 0
	//  Minimum: 0
	PreviewLength *int
	// Offset needed to return a specific subset of messages.
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of messages to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count  *int
	Fields *[]string
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.Date != nil {
		setInt(values, "date", *r.Date)
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_Search Returns a list of the current user's private messages that match search criteria.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.search
func (vk *VK) Messages_Search(ctx context.Context, req Messages_Search_Request, options ...Option) (resp Messages_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.search", ctx, values, &resp)
	return
}

// Messages_SearchExtended Returns a list of the current user's private messages that match search criteria.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.search
func (vk *VK) Messages_SearchExtended(ctx context.Context, req Messages_Search_Request, options ...Option) (resp Messages_SearchExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.search", ctx, values, &resp)
	return
}

type Messages_SearchConversations_Request struct {
	// Search query string.
	Q *string
	// Maximum number of results.
	//  Default: 20
	//  Minimum: 1
	//  Maximum: 255
	Count  *int
	Fields *[]Users_Fields
	// Group ID (for group messages with user access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_SearchConversations_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_SearchConversations Returns a list of the current user's conversations that match search criteria.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.searchConversations
func (vk *VK) Messages_SearchConversations(ctx context.Context, req Messages_SearchConversations_Request, options ...Option) (resp Messages_SearchConversations_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.searchConversations", ctx, values, &resp)
	return
}

// Messages_SearchConversationsExtended Returns a list of the current user's conversations that match search criteria.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.searchConversations
func (vk *VK) Messages_SearchConversationsExtended(ctx context.Context, req Messages_SearchConversations_Request, options ...Option) (resp Messages_SearchConversationsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.searchConversations", ctx, values, &resp)
	return
}

type Messages_Send_Intent string

const (
	Messages_Send_Intent_AccountUpdate         Messages_Send_Intent = "account_update"
	Messages_Send_Intent_BotAdInvite           Messages_Send_Intent = "bot_ad_invite"
	Messages_Send_Intent_BotAdPromo            Messages_Send_Intent = "bot_ad_promo"
	Messages_Send_Intent_ConfirmedNotification Messages_Send_Intent = "confirmed_notification"
	Messages_Send_Intent_CustomerSupport       Messages_Send_Intent = "customer_support"
	Messages_Send_Intent_Default               Messages_Send_Intent = "default"
	Messages_Send_Intent_GameNotification      Messages_Send_Intent = "game_notification"
	Messages_Send_Intent_ModeratedNewsletter   Messages_Send_Intent = "moderated_newsletter"
	Messages_Send_Intent_NonPromoNewsletter    Messages_Send_Intent = "non_promo_newsletter"
	Messages_Send_Intent_PromoNewsletter       Messages_Send_Intent = "promo_newsletter"
	Messages_Send_Intent_PurchaseUpdate        Messages_Send_Intent = "purchase_update"
)

type Messages_Send_Request struct {
	// User ID (by default — current user).
	//  Format: int64
	UserId *int
	// Unique identifier to avoid resending the message.
	RandomId *int
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	//  Format: int32
	PeerId *int
	// User's short address (for example, 'illarionov').
	Domain *string
	// ID of conversation the message will relate to.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId *int
	//  Format: int64
	//  MaxItems: 100
	UserIds *[]int
	// (Required if 'attachments' is not set.) Text of the message.
	//  MaxLength: 9000
	Message *string
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// (Required if 'message' is not set.) List of objects attached to the message, separated by commas, in the following format: "<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'wall' — wall post, '<owner_id>' — ID of the media attachment owner. '<media_id>' — media attachment ID. Example: "photo100172_166443618"
	//  MaxLength: 9000
	Attachment *string
	ReplyTo    *int
	//  MaxItems: 1000
	ForwardMessages *[]int
	// JSON describing the forwarded message or reply
	//  Format: json
	Forward *Messages_Forward
	// Sticker id.
	//  Minimum: 0
	StickerId *int
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	//  Format: json
	Keyboard *Messages_Keyboard
	Template *string
	//  MaxLength: 1000
	Payload *string
	// JSON describing the content source in the message
	ContentSource *string
	//  Default: false
	DontParseLinks *bool
	//  Default: false
	DisableMentions *bool
	//  Default: default
	Intent *Messages_Send_Intent
	//  Minimum: 0
	//  Maximum: 100
	SubscribeId *int
}

func (r Messages_Send_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.RandomId != nil {
		setInt(values, "random_id", *r.RandomId)
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.Domain != nil {
		setString(values, "domain", *r.Domain)
	}
	if r.ChatId != nil {
		setInt(values, "chat_id", *r.ChatId)
	}
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.Attachment != nil {
		setString(values, "attachment", *r.Attachment)
	}
	if r.ReplyTo != nil {
		setInt(values, "reply_to", *r.ReplyTo)
	}
	if r.ForwardMessages != nil {
		setInts(values, "forward_messages", *r.ForwardMessages)
	}
	if r.Forward != nil {
		if err = setJSON(values, "forward", *r.Forward); err != nil {
			return
		}
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.Keyboard != nil {
		if err = setJSON(values, "keyboard", *r.Keyboard); err != nil {
			return
		}
	}
	if r.Template != nil {
		setString(values, "template", *r.Template)
	}
	if r.Payload != nil {
		setString(values, "payload", *r.Payload)
	}
	if r.ContentSource != nil {
		setString(values, "content_source", *r.ContentSource)
	}
	if r.DontParseLinks != nil {
		setBool(values, "dont_parse_links", *r.DontParseLinks)
	}
	if r.DisableMentions != nil {
		setBool(values, "disable_mentions", *r.DisableMentions)
	}
	if r.Intent != nil {
		setString(values, "intent", string(*r.Intent))
	}
	if r.SubscribeId != nil {
		setInt(values, "subscribe_id", *r.SubscribeId)
	}
	return
}

// Messages_Send Sends a message.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesUserBlocked, Error_MessagesDenySend, Error_MessagesPrivacy, Error_MessagesTooLongMessage, Error_MessagesTooLongForwards, Error_MessagesCantFwd, Error_MessagesChatUserNoAccess, Error_MessagesKeyboardInvalid, Error_MessagesChatBotFeature, Error_MessagesContactNotFound, Error_MessagesTooManyPosts, Error_MessagesIntentCantUse, Error_MessagesIntentLimitOverflow, Error_MessagesChatUnsupported, Error_MessagesChatDisabled, Error_MessagesChatNotAdmin, Error_MessagesPeerBlockedReasonByTime, Error_NotFound, Error_MessagesUserNotDon, Error_MessagesMessageCannotBeForwarded ]
//
// https://dev.vk.com/method/messages.send
func (vk *VK) Messages_Send(ctx context.Context, req Messages_Send_Request, options ...Option) (resp Messages_Send_Response, apiErr ApiError, err error) {
	values := make(url.Values, 25+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.send", ctx, values, &resp)
	return
}

type Messages_SendUserIDs_Intent string

const (
	Messages_SendUserIDs_Intent_AccountUpdate         Messages_SendUserIDs_Intent = "account_update"
	Messages_SendUserIDs_Intent_BotAdInvite           Messages_SendUserIDs_Intent = "bot_ad_invite"
	Messages_SendUserIDs_Intent_BotAdPromo            Messages_SendUserIDs_Intent = "bot_ad_promo"
	Messages_SendUserIDs_Intent_ConfirmedNotification Messages_SendUserIDs_Intent = "confirmed_notification"
	Messages_SendUserIDs_Intent_CustomerSupport       Messages_SendUserIDs_Intent = "customer_support"
	Messages_SendUserIDs_Intent_Default               Messages_SendUserIDs_Intent = "default"
	Messages_SendUserIDs_Intent_GameNotification      Messages_SendUserIDs_Intent = "game_notification"
	Messages_SendUserIDs_Intent_ModeratedNewsletter   Messages_SendUserIDs_Intent = "moderated_newsletter"
	Messages_SendUserIDs_Intent_NonPromoNewsletter    Messages_SendUserIDs_Intent = "non_promo_newsletter"
	Messages_SendUserIDs_Intent_PromoNewsletter       Messages_SendUserIDs_Intent = "promo_newsletter"
	Messages_SendUserIDs_Intent_PurchaseUpdate        Messages_SendUserIDs_Intent = "purchase_update"
)

type Messages_SendUserIDs_Request struct {
	// User ID (by default — current user).
	//  Format: int64
	UserId *int
	// Unique identifier to avoid resending the message.
	RandomId *int
	//  Format: int32
	//  MaxItems: 100
	PeerIds *[]int
	// User's short address (for example, 'illarionov').
	Domain *string
	// ID of conversation the message will relate to.
	//  Minimum: 0
	//  Maximum: 1e+08
	ChatId *int
	//  Format: int64
	//  MaxItems: 100
	UserIds *[]int
	// (Required if 'attachments' is not set.) Text of the message.
	//  MaxLength: 9000
	Message *string
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// (Required if 'message' is not set.) List of objects attached to the message, separated by commas, in the following format: "<owner_id>_<media_id>", '' — Type of media attachment: 'photo' — photo, 'video' — video, 'audio' — audio, 'doc' — document, 'wall' — wall post, '<owner_id>' — ID of the media attachment owner. '<media_id>' — media attachment ID. Example: "photo100172_166443618"
	//  MaxLength: 9000
	Attachment *string
	ReplyTo    *int
	//  MaxItems: 1000
	ForwardMessages *[]int
	// JSON describing the forwarded message or reply
	//  Format: json
	Forward *Messages_Forward
	// Sticker id.
	//  Minimum: 0
	StickerId *int
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	//  Format: json
	Keyboard *Messages_Keyboard
	Template *string
	//  MaxLength: 1000
	Payload *string
	// JSON describing the content source in the message
	ContentSource *string
	//  Default: false
	DontParseLinks *bool
	//  Default: false
	DisableMentions *bool
	//  Default: default
	Intent *Messages_SendUserIDs_Intent
	//  Minimum: 0
	//  Maximum: 100
	SubscribeId *int
}

func (r Messages_SendUserIDs_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.RandomId != nil {
		setInt(values, "random_id", *r.RandomId)
	}
	if r.PeerIds != nil {
		setInts(values, "peer_ids", *r.PeerIds)
	}
	if r.Domain != nil {
		setString(values, "domain", *r.Domain)
	}
	if r.ChatId != nil {
		setInt(values, "chat_id", *r.ChatId)
	}
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.Attachment != nil {
		setString(values, "attachment", *r.Attachment)
	}
	if r.ReplyTo != nil {
		setInt(values, "reply_to", *r.ReplyTo)
	}
	if r.ForwardMessages != nil {
		setInts(values, "forward_messages", *r.ForwardMessages)
	}
	if r.Forward != nil {
		if err = setJSON(values, "forward", *r.Forward); err != nil {
			return
		}
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.Keyboard != nil {
		if err = setJSON(values, "keyboard", *r.Keyboard); err != nil {
			return
		}
	}
	if r.Template != nil {
		setString(values, "template", *r.Template)
	}
	if r.Payload != nil {
		setString(values, "payload", *r.Payload)
	}
	if r.ContentSource != nil {
		setString(values, "content_source", *r.ContentSource)
	}
	if r.DontParseLinks != nil {
		setBool(values, "dont_parse_links", *r.DontParseLinks)
	}
	if r.DisableMentions != nil {
		setBool(values, "disable_mentions", *r.DisableMentions)
	}
	if r.Intent != nil {
		setString(values, "intent", string(*r.Intent))
	}
	if r.SubscribeId != nil {
		setInt(values, "subscribe_id", *r.SubscribeId)
	}
	return
}

// Messages_SendUserIDs Sends a message.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesUserBlocked, Error_MessagesDenySend, Error_MessagesPrivacy, Error_MessagesTooLongMessage, Error_MessagesTooLongForwards, Error_MessagesCantFwd, Error_MessagesChatUserNoAccess, Error_MessagesKeyboardInvalid, Error_MessagesChatBotFeature, Error_MessagesContactNotFound, Error_MessagesTooManyPosts, Error_MessagesIntentCantUse, Error_MessagesIntentLimitOverflow, Error_MessagesChatUnsupported, Error_MessagesChatDisabled, Error_MessagesChatNotAdmin, Error_MessagesPeerBlockedReasonByTime, Error_NotFound, Error_MessagesUserNotDon, Error_MessagesMessageCannotBeForwarded ]
//
// https://dev.vk.com/method/messages.send
func (vk *VK) Messages_SendUserIDs(ctx context.Context, req Messages_SendUserIDs_Request, options ...Option) (resp Messages_SendUserIds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 25+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.send", ctx, values, &resp)
	return
}

type Messages_SendMessageEventAnswer_Request struct {
	EventId string
	//  Format: int64
	UserId int
	PeerId int
	//  MaxLength: 1000
	EventData *string
}

func (r Messages_SendMessageEventAnswer_Request) fillIn(values url.Values) (err error) {
	setString(values, "event_id", r.EventId)
	setInt(values, "user_id", r.UserId)
	setInt(values, "peer_id", r.PeerId)
	if r.EventData != nil {
		setString(values, "event_data", *r.EventData)
	}
	return
}

// Messages_SendMessageEventAnswer ...
// May execute with listed access token types:
//    [ group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/messages.sendMessageEventAnswer
func (vk *VK) Messages_SendMessageEventAnswer(ctx context.Context, req Messages_SendMessageEventAnswer_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.sendMessageEventAnswer", ctx, values, &resp)
	return
}

type Messages_SetActivity_Type string

const (
	Messages_SetActivity_Type_Audiomessage Messages_SetActivity_Type = "audiomessage"
	Messages_SetActivity_Type_File         Messages_SetActivity_Type = "file"
	Messages_SetActivity_Type_Photo        Messages_SetActivity_Type = "photo"
	Messages_SetActivity_Type_Typing       Messages_SetActivity_Type = "typing"
	Messages_SetActivity_Type_Video        Messages_SetActivity_Type = "video"
)

type Messages_SetActivity_Request struct {
	// User ID.
	UserId *int
	// 'typing' — user has started to type.
	Type *Messages_SetActivity_Type
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'chat_id', e.g. '2000000001'. For community: '- community ID', e.g. '-12345'. "
	//  Format: int32
	PeerId *int
	// Group ID (for group messages with group access token)
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_SetActivity_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Type != nil {
		setString(values, "type", string(*r.Type))
	}
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_SetActivity Changes the status of a user as typing in a conversation.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesGroupPeerAccess, Error_MessagesChatUserNoAccess, Error_MessagesContactNotFound ]
//
// https://dev.vk.com/method/messages.setActivity
func (vk *VK) Messages_SetActivity(ctx context.Context, req Messages_SetActivity_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.setActivity", ctx, values, &resp)
	return
}

type Messages_SetChatPhoto_Request struct {
	// Upload URL from the 'response' field returned by the [vk.com/dev/photos.getChatUploadServer|photos.getChatUploadServer] method upon successfully uploading an image.
	File string
}

func (r Messages_SetChatPhoto_Request) fillIn(values url.Values) (err error) {
	setString(values, "file", r.File)
	return
}

// Messages_SetChatPhoto Sets a previously-uploaded picture as the cover picture of a chat.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Upload, Error_PhotoChanged, Error_MessagesChatNotAdmin ]
//
// https://dev.vk.com/method/messages.setChatPhoto
func (vk *VK) Messages_SetChatPhoto(ctx context.Context, req Messages_SetChatPhoto_Request, options ...Option) (resp Messages_SetChatPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.setChatPhoto", ctx, values, &resp)
	return
}

type Messages_Unpin_Request struct {
	PeerId int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Messages_Unpin_Request) fillIn(values url.Values) (err error) {
	setInt(values, "peer_id", r.PeerId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Messages_Unpin ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesChatNotAdmin ]
//
// https://dev.vk.com/method/messages.unpin
func (vk *VK) Messages_Unpin(ctx context.Context, req Messages_Unpin_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("messages.unpin", ctx, values, &resp)
	return
}

type Newsfeed_AddBan_Request struct {
	UserIds  *[]int
	GroupIds *[]int
}

func (r Newsfeed_AddBan_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.GroupIds != nil {
		setInts(values, "group_ids", *r.GroupIds)
	}
	return
}

// Newsfeed_AddBan Prevents news from specified users and communities from appearing in the current user's newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.addBan
func (vk *VK) Newsfeed_AddBan(ctx context.Context, req Newsfeed_AddBan_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.addBan", ctx, values, &resp)
	return
}

type Newsfeed_DeleteBan_Request struct {
	//  Minimum: 0
	UserIds *[]int
	//  Minimum: 0
	GroupIds *[]int
}

func (r Newsfeed_DeleteBan_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.GroupIds != nil {
		setInts(values, "group_ids", *r.GroupIds)
	}
	return
}

// Newsfeed_DeleteBan Allows news from previously banned users and communities to be shown in the current user's newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.deleteBan
func (vk *VK) Newsfeed_DeleteBan(ctx context.Context, req Newsfeed_DeleteBan_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.deleteBan", ctx, values, &resp)
	return
}

type Newsfeed_DeleteList_Request struct {
	//  Minimum: 0
	ListId int
}

func (r Newsfeed_DeleteList_Request) fillIn(values url.Values) (err error) {
	setInt(values, "list_id", r.ListId)
	return
}

// Newsfeed_DeleteList ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.deleteList
func (vk *VK) Newsfeed_DeleteList(ctx context.Context, req Newsfeed_DeleteList_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.deleteList", ctx, values, &resp)
	return
}

type Newsfeed_Get_Request struct {
	Filters *[]Newsfeed_NewsfeedItemType
	// '1' — to return news items from banned sources
	ReturnBanned *bool
	// Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	//  Minimum: 0
	StartTime *int
	// Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	//  Minimum: 0
	EndTime *int
	// Maximum number of photos to return. By default, '5'.
	//  Minimum: 0
	MaxPhotos *int
	// Sources to obtain news from, separated by commas. User IDs can be specified in formats '' or 'u' , where '' is the user's friend ID. Community IDs can be specified in formats '-' or 'g' , where '' is the community ID. If the parameter is not set, all of the user's friends and communities are returned, except for banned sources, which can be obtained with the [vk.com/dev/newsfeed.getBanned|newsfeed.getBanned] method.
	SourceIds *string
	// identifier required to get the next page of results. Value for this parameter is returned in 'next_from' field in a reply.
	StartFrom *string
	// Number of news items to return (default 50, maximum 100). For auto feed, you can use the 'new_offset' parameter returned by this method.
	//  Minimum: 0
	Count   *int
	Fields  *[]Base_UserGroupFields
	Section *string
}

func (r Newsfeed_Get_Request) fillIn(values url.Values) (err error) {
	if r.Filters != nil {
		vs := make([]string, len(*r.Filters))
		for i, v := range *r.Filters {
			vs[i] = string(v)
		}
		setStrings(values, "filters", vs)
	}
	if r.ReturnBanned != nil {
		setBool(values, "return_banned", *r.ReturnBanned)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.MaxPhotos != nil {
		setInt(values, "max_photos", *r.MaxPhotos)
	}
	if r.SourceIds != nil {
		setString(values, "source_ids", *r.SourceIds)
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.Section != nil {
		setString(values, "section", *r.Section)
	}
	return
}

// Newsfeed_Get Returns data required to show newsfeed for the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.get
func (vk *VK) Newsfeed_Get(ctx context.Context, req Newsfeed_Get_Request, options ...Option) (resp Newsfeed_Generic_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.get", ctx, values, &resp)
	return
}

type Newsfeed_GetBanned_NameCase string

const (
	Newsfeed_GetBanned_NameCase_Nominative    Newsfeed_GetBanned_NameCase = "nom"
	Newsfeed_GetBanned_NameCase_Genitive      Newsfeed_GetBanned_NameCase = "gen"
	Newsfeed_GetBanned_NameCase_Dative        Newsfeed_GetBanned_NameCase = "dat"
	Newsfeed_GetBanned_NameCase_Accusative    Newsfeed_GetBanned_NameCase = "acc"
	Newsfeed_GetBanned_NameCase_Instrumental  Newsfeed_GetBanned_NameCase = "ins"
	Newsfeed_GetBanned_NameCase_Prepositional Newsfeed_GetBanned_NameCase = "abl"
)

type Newsfeed_GetBanned_Request struct {
	Fields *[]Users_Fields
	// Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Newsfeed_GetBanned_NameCase
}

func (r Newsfeed_GetBanned_Request) fillIn(values url.Values) (err error) {
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Newsfeed_GetBanned Returns a list of users and communities banned from the current user's newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getBanned
func (vk *VK) Newsfeed_GetBanned(ctx context.Context, req Newsfeed_GetBanned_Request, options ...Option) (resp Newsfeed_GetBanned_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getBanned", ctx, values, &resp)
	return
}

// Newsfeed_GetBannedExtended Returns a list of users and communities banned from the current user's newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getBanned
func (vk *VK) Newsfeed_GetBannedExtended(ctx context.Context, req Newsfeed_GetBanned_Request, options ...Option) (resp Newsfeed_GetBannedExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getBanned", ctx, values, &resp)
	return
}

type Newsfeed_GetComments_Request struct {
	// Number of comments to return. For auto feed, you can use the 'new_offset' parameter returned by this method.
	//  Default: 30
	//  Minimum: 0
	//  Maximum: 100
	Count   *int
	Filters *[]Newsfeed_CommentsFilters
	// Object ID, comments on repost of which shall be returned, e.g. 'wall1_45486'. (If the parameter is set, the 'filters' parameter is optional.),
	Reposts *string
	// Earliest timestamp (in Unix time) of a comment to return. By default, 24 hours ago.
	//  Minimum: 0
	StartTime *int
	// Latest timestamp (in Unix time) of a comment to return. By default, the current time.
	//  Minimum: 0
	EndTime *int
	//  Default: 0
	//  Minimum: 0
	//  Maximum: 10
	LastCommentsCount *int
	// Identificator needed to return the next page with results. Value for this parameter returns in 'next_from' field.
	StartFrom *string
	Fields    *[]Base_UserGroupFields
}

func (r Newsfeed_GetComments_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Filters != nil {
		vs := make([]string, len(*r.Filters))
		for i, v := range *r.Filters {
			vs[i] = string(v)
		}
		setStrings(values, "filters", vs)
	}
	if r.Reposts != nil {
		setString(values, "reposts", *r.Reposts)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.LastCommentsCount != nil {
		setInt(values, "last_comments_count", *r.LastCommentsCount)
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Newsfeed_GetComments Returns a list of comments in the current user's newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getComments
func (vk *VK) Newsfeed_GetComments(ctx context.Context, req Newsfeed_GetComments_Request, options ...Option) (resp Newsfeed_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getComments", ctx, values, &resp)
	return
}

type Newsfeed_GetLists_Request struct {
	//  Minimum: 0
	ListIds *[]int
}

func (r Newsfeed_GetLists_Request) fillIn(values url.Values) (err error) {
	if r.ListIds != nil {
		setInts(values, "list_ids", *r.ListIds)
	}
	return
}

// Newsfeed_GetLists Returns a list of newsfeeds followed by the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getLists
func (vk *VK) Newsfeed_GetLists(ctx context.Context, req Newsfeed_GetLists_Request, options ...Option) (resp Newsfeed_GetLists_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getLists", ctx, values, &resp)
	return
}

// Newsfeed_GetListsExtended Returns a list of newsfeeds followed by the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getLists
func (vk *VK) Newsfeed_GetListsExtended(ctx context.Context, req Newsfeed_GetLists_Request, options ...Option) (resp Newsfeed_GetListsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getLists", ctx, values, &resp)
	return
}

type Newsfeed_GetMentions_Request struct {
	// Owner ID.
	//  Format: int64
	OwnerId *int
	// Earliest timestamp (in Unix time) of a post to return. By default, 24 hours ago.
	//  Minimum: 0
	StartTime *int
	// Latest timestamp (in Unix time) of a post to return. By default, the current time.
	//  Minimum: 0
	EndTime *int
	// Offset needed to return a specific subset of posts.
	//  Minimum: 0
	Offset *int
	// Number of posts to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 50
	Count *int
}

func (r Newsfeed_GetMentions_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Newsfeed_GetMentions Returns a list of posts on user walls in which the current user is mentioned.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getMentions
func (vk *VK) Newsfeed_GetMentions(ctx context.Context, req Newsfeed_GetMentions_Request, options ...Option) (resp Newsfeed_GetMentions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getMentions", ctx, values, &resp)
	return
}

type Newsfeed_GetRecommended_Request struct {
	// Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	//  Minimum: 0
	StartTime *int
	// Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	//  Minimum: 0
	EndTime *int
	// Maximum number of photos to return. By default, '5'.
	//  Minimum: 0
	MaxPhotos *int
	// 'new_from' value obtained in previous call.
	StartFrom *string
	// Number of news items to return.
	//  Minimum: 0
	Count  *int
	Fields *[]Base_UserGroupFields
}

func (r Newsfeed_GetRecommended_Request) fillIn(values url.Values) (err error) {
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.MaxPhotos != nil {
		setInt(values, "max_photos", *r.MaxPhotos)
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Newsfeed_GetRecommended , Returns a list of newsfeeds recommended to the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getRecommended
func (vk *VK) Newsfeed_GetRecommended(ctx context.Context, req Newsfeed_GetRecommended_Request, options ...Option) (resp Newsfeed_Generic_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getRecommended", ctx, values, &resp)
	return
}

type Newsfeed_GetSuggestedSources_Request struct {
	// offset required to choose a particular subset of communities or users.
	//  Minimum: 0
	Offset *int
	// amount of communities or users to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// shuffle the returned list or not.
	Shuffle *bool
	Fields  *[]Base_UserGroupFields
}

func (r Newsfeed_GetSuggestedSources_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Shuffle != nil {
		setBool(values, "shuffle", *r.Shuffle)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Newsfeed_GetSuggestedSources Returns communities and users that current user is suggested to follow.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.getSuggestedSources
func (vk *VK) Newsfeed_GetSuggestedSources(ctx context.Context, req Newsfeed_GetSuggestedSources_Request, options ...Option) (resp Newsfeed_GetSuggestedSources_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.getSuggestedSources", ctx, values, &resp)
	return
}

type Newsfeed_IgnoreItem_Request struct {
	// Item type. Possible values: *'wall' - post on the wall,, *'tag' - tag on a photo,, *'profilephoto' - profile photo,, *'video' - video,, *'audio' - audio.
	Type Newsfeed_IgnoreItemType
	// Item owner's identifier (user or community), "Note that community id must be negative. 'owner_id=1' - user , 'owner_id=-1' - community "
	//  Default: 0
	//  Format: int64
	OwnerId *int
	// Item identifier
	//  Default: 0
	//  Minimum: 0
	ItemId *int
}

func (r Newsfeed_IgnoreItem_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.ItemId != nil {
		setInt(values, "item_id", *r.ItemId)
	}
	return
}

// Newsfeed_IgnoreItem Hides an item from the newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.ignoreItem
func (vk *VK) Newsfeed_IgnoreItem(ctx context.Context, req Newsfeed_IgnoreItem_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.ignoreItem", ctx, values, &resp)
	return
}

type Newsfeed_SaveList_Request struct {
	// numeric list identifier (if not sent, will be set automatically).
	//  Minimum: 0
	ListId *int
	// list name.
	Title string
	//  Format: int64
	SourceIds *[]int
	// reposts display on and off ('1' is for off).
	NoReposts *bool
}

func (r Newsfeed_SaveList_Request) fillIn(values url.Values) (err error) {
	if r.ListId != nil {
		setInt(values, "list_id", *r.ListId)
	}
	setString(values, "title", r.Title)
	if r.SourceIds != nil {
		setInts(values, "source_ids", *r.SourceIds)
	}
	if r.NoReposts != nil {
		setBool(values, "no_reposts", *r.NoReposts)
	}
	return
}

// Newsfeed_SaveList Creates and edits user newsfeed lists
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_TooManyLists ]
//
// https://dev.vk.com/method/newsfeed.saveList
func (vk *VK) Newsfeed_SaveList(ctx context.Context, req Newsfeed_SaveList_Request, options ...Option) (resp Newsfeed_SaveList_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.saveList", ctx, values, &resp)
	return
}

type Newsfeed_Search_Request struct {
	// Search query string (e.g., 'New Year').
	Q *string
	// Number of posts to return.
	//  Default: 30
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// Geographical latitude point (in degrees, -90 to 90) within which to search.
	Latitude *float64
	// Geographical longitude point (in degrees, -180 to 180) within which to search.
	Longitude *float64
	// Earliest timestamp (in Unix time) of a news item to return. By default, 24 hours ago.
	//  Minimum: 0
	StartTime *int
	// Latest timestamp (in Unix time) of a news item to return. By default, the current time.
	//  Minimum: 0
	EndTime   *int
	StartFrom *string
	Fields    *[]Base_UserGroupFields
}

func (r Newsfeed_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Newsfeed_Search Returns search results by statuses.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.search
func (vk *VK) Newsfeed_Search(ctx context.Context, req Newsfeed_Search_Request, options ...Option) (resp Newsfeed_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.search", ctx, values, &resp)
	return
}

// Newsfeed_SearchExtended Returns search results by statuses.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.search
func (vk *VK) Newsfeed_SearchExtended(ctx context.Context, req Newsfeed_Search_Request, options ...Option) (resp Newsfeed_SearchExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.search", ctx, values, &resp)
	return
}

type Newsfeed_UnignoreItem_Request struct {
	// Item type. Possible values: *'wall' - post on the wall,, *'tag' - tag on a photo,, *'profilephoto' - profile photo,, *'video' - video,, *'audio' - audio.
	Type Newsfeed_IgnoreItemType
	// Item owner's identifier (user or community), "Note that community id must be negative. 'owner_id=1' - user , 'owner_id=-1' - community "
	//  Format: int64
	OwnerId int
	// Item identifier
	//  Minimum: 0
	ItemId int
	// Track code of unignored item
	TrackCode *string
}

func (r Newsfeed_UnignoreItem_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "item_id", r.ItemId)
	if r.TrackCode != nil {
		setString(values, "track_code", *r.TrackCode)
	}
	return
}

// Newsfeed_UnignoreItem Returns a hidden item to the newsfeed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.unignoreItem
func (vk *VK) Newsfeed_UnignoreItem(ctx context.Context, req Newsfeed_UnignoreItem_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.unignoreItem", ctx, values, &resp)
	return
}

type Newsfeed_Unsubscribe_Type string

const (
	Newsfeed_Unsubscribe_Type_Note  Newsfeed_Unsubscribe_Type = "note"
	Newsfeed_Unsubscribe_Type_Photo Newsfeed_Unsubscribe_Type = "photo"
	Newsfeed_Unsubscribe_Type_Post  Newsfeed_Unsubscribe_Type = "post"
	Newsfeed_Unsubscribe_Type_Topic Newsfeed_Unsubscribe_Type = "topic"
	Newsfeed_Unsubscribe_Type_Video Newsfeed_Unsubscribe_Type = "video"
)

type Newsfeed_Unsubscribe_Request struct {
	// Type of object from which to unsubscribe: 'note' — note, 'photo' — photo, 'post' — post on user wall or community wall, 'topic' — topic, 'video' — video
	Type Newsfeed_Unsubscribe_Type
	// Object owner ID.
	//  Format: int64
	OwnerId *int
	// Object ID.
	//  Minimum: 0
	ItemId int
}

func (r Newsfeed_Unsubscribe_Request) fillIn(values url.Values) (err error) {
	setString(values, "type", string(r.Type))
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "item_id", r.ItemId)
	return
}

// Newsfeed_Unsubscribe Unsubscribes the current user from specified newsfeeds.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/newsfeed.unsubscribe
func (vk *VK) Newsfeed_Unsubscribe(ctx context.Context, req Newsfeed_Unsubscribe_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("newsfeed.unsubscribe", ctx, values, &resp)
	return
}

type Notes_Add_Request struct {
	// Note title.
	Title string
	// Note text.
	Text string
	//  Default: all
	PrivacyView *[]string
	//  Default: all
	PrivacyComment *[]string
}

func (r Notes_Add_Request) fillIn(values url.Values) (err error) {
	setString(values, "title", r.Title)
	setString(values, "text", r.Text)
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	return
}

// Notes_Add Creates a new note for the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/notes.add
func (vk *VK) Notes_Add(ctx context.Context, req Notes_Add_Request, options ...Option) (resp Notes_Add_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.add", ctx, values, &resp)
	return
}

type Notes_CreateComment_Request struct {
	// Note ID.
	//  Minimum: 0
	NoteId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
	// ID of the user to whom the reply is addressed (if the comment is a reply to another comment).
	//  Minimum: 0
	ReplyTo *int
	// Comment text.
	Message string
	Guid    *string
}

func (r Notes_CreateComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "note_id", r.NoteId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.ReplyTo != nil {
		setInt(values, "reply_to", *r.ReplyTo)
	}
	setString(values, "message", r.Message)
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Notes_CreateComment Adds a new comment on a note.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessNote, Error_AccessNoteComment ]
//
// https://dev.vk.com/method/notes.createComment
func (vk *VK) Notes_CreateComment(ctx context.Context, req Notes_CreateComment_Request, options ...Option) (resp Notes_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.createComment", ctx, values, &resp)
	return
}

type Notes_Delete_Request struct {
	// Note ID.
	//  Minimum: 0
	NoteId int
}

func (r Notes_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "note_id", r.NoteId)
	return
}

// Notes_Delete Deletes a note of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamNoteId ]
//
// https://dev.vk.com/method/notes.delete
func (vk *VK) Notes_Delete(ctx context.Context, req Notes_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.delete", ctx, values, &resp)
	return
}

type Notes_DeleteComment_Request struct {
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
}

func (r Notes_DeleteComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "comment_id", r.CommentId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Notes_DeleteComment Deletes a comment on a note.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessNote, Error_AccessComment ]
//
// https://dev.vk.com/method/notes.deleteComment
func (vk *VK) Notes_DeleteComment(ctx context.Context, req Notes_DeleteComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.deleteComment", ctx, values, &resp)
	return
}

type Notes_Edit_Request struct {
	// Note ID.
	//  Minimum: 0
	NoteId int
	// Note title.
	Title string
	// Note text.
	Text string
	//  Default: all
	PrivacyView *[]string
	//  Default: all
	PrivacyComment *[]string
}

func (r Notes_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "note_id", r.NoteId)
	setString(values, "title", r.Title)
	setString(values, "text", r.Text)
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	return
}

// Notes_Edit Edits a note of the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamNoteId ]
//
// https://dev.vk.com/method/notes.edit
func (vk *VK) Notes_Edit(ctx context.Context, req Notes_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.edit", ctx, values, &resp)
	return
}

type Notes_EditComment_Request struct {
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
	// New comment text.
	//  MinLength: 2
	Message string
}

func (r Notes_EditComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "comment_id", r.CommentId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setString(values, "message", r.Message)
	return
}

// Notes_EditComment Edits a comment on a note.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessComment ]
//
// https://dev.vk.com/method/notes.editComment
func (vk *VK) Notes_EditComment(ctx context.Context, req Notes_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.editComment", ctx, values, &resp)
	return
}

type Notes_Get_Sort int

const (
	Notes_Get_Sort_0 Notes_Get_Sort = 0
	Notes_Get_Sort_1 Notes_Get_Sort = 1
)

type Notes_Get_Request struct {
	//  Minimum: 0
	NoteIds *[]int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of notes to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	//  Default: 0
	//  Minimum: 0
	Sort *Notes_Get_Sort
}

func (r Notes_Get_Request) fillIn(values url.Values) (err error) {
	if r.NoteIds != nil {
		setInts(values, "note_ids", *r.NoteIds)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	return
}

// Notes_Get Returns a list of notes created by a user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamNoteId ]
//
// https://dev.vk.com/method/notes.get
func (vk *VK) Notes_Get(ctx context.Context, req Notes_Get_Request, options ...Option) (resp Notes_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.get", ctx, values, &resp)
	return
}

type Notes_GetById_Request struct {
	// Note ID.
	//  Minimum: 0
	NoteId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
	//  Default: 0
	NeedWiki *bool
}

func (r Notes_GetById_Request) fillIn(values url.Values) (err error) {
	setInt(values, "note_id", r.NoteId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.NeedWiki != nil {
		setBool(values, "need_wiki", *r.NeedWiki)
	}
	return
}

// Notes_GetById Returns a note by its ID.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessNote, Error_ParamNoteId ]
//
// https://dev.vk.com/method/notes.getById
func (vk *VK) Notes_GetById(ctx context.Context, req Notes_GetById_Request, options ...Option) (resp Notes_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.getById", ctx, values, &resp)
	return
}

type Notes_GetComments_Sort int

const (
	Notes_GetComments_Sort_0 Notes_GetComments_Sort = 0
	Notes_GetComments_Sort_1 Notes_GetComments_Sort = 1
)

type Notes_GetComments_Request struct {
	// Note ID.
	//  Minimum: 0
	NoteId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
	//  Default: 0
	//  Minimum: 0
	Sort *Notes_GetComments_Sort
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// Number of comments to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r Notes_GetComments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "note_id", r.NoteId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Notes_GetComments Returns a list of comments on a note.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessNote ]
//
// https://dev.vk.com/method/notes.getComments
func (vk *VK) Notes_GetComments(ctx context.Context, req Notes_GetComments_Request, options ...Option) (resp Notes_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.getComments", ctx, values, &resp)
	return
}

type Notes_RestoreComment_Request struct {
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// Note owner ID.
	//  Format: int64
	//  Minimum: 0
	OwnerId *int
}

func (r Notes_RestoreComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "comment_id", r.CommentId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Notes_RestoreComment Restores a deleted comment on a note.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessComment ]
//
// https://dev.vk.com/method/notes.restoreComment
func (vk *VK) Notes_RestoreComment(ctx context.Context, req Notes_RestoreComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notes.restoreComment", ctx, values, &resp)
	return
}

type Notifications_Get_Filters string

const (
	Notifications_Get_Filters_Wall      Notifications_Get_Filters = "wall"
	Notifications_Get_Filters_Mentions  Notifications_Get_Filters = "mentions"
	Notifications_Get_Filters_Comments  Notifications_Get_Filters = "comments"
	Notifications_Get_Filters_Likes     Notifications_Get_Filters = "likes"
	Notifications_Get_Filters_Reposted  Notifications_Get_Filters = "reposted"
	Notifications_Get_Filters_Followers Notifications_Get_Filters = "followers"
	Notifications_Get_Filters_Friends   Notifications_Get_Filters = "friends"
)

type Notifications_Get_Request struct {
	// Number of notifications to return.
	//  Default: 30
	//  Minimum: 1
	//  Maximum: 100
	Count     *int
	StartFrom *string
	Filters   *[]Notifications_Get_Filters
	// Earliest timestamp (in Unix time) of a notification to return. By default, 24 hours ago.
	StartTime *int
	// Latest timestamp (in Unix time) of a notification to return. By default, the current time.
	EndTime *int
}

func (r Notifications_Get_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.StartFrom != nil {
		setString(values, "start_from", *r.StartFrom)
	}
	if r.Filters != nil {
		vs := make([]string, len(*r.Filters))
		for i, v := range *r.Filters {
			vs[i] = string(v)
		}
		setStrings(values, "filters", vs)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	return
}

// Notifications_Get Returns a list of notifications about other users' feedback to the current user's wall posts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/notifications.get
func (vk *VK) Notifications_Get(ctx context.Context, req Notifications_Get_Request, options ...Option) (resp Notifications_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notifications.get", ctx, values, &resp)
	return
}

// Notifications_MarkAsViewed Resets the counter of new notifications about other users' feedback to the current user's wall posts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/notifications.markAsViewed
func (vk *VK) Notifications_MarkAsViewed(ctx context.Context, options ...Option) (resp Notifications_MarkAsViewed_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("notifications.markAsViewed", ctx, values, &resp)
	return
}

type Notifications_SendMessage_SendingMode string

const (
	Notifications_SendMessage_SendingMode_Delayed     Notifications_SendMessage_SendingMode = "delayed"
	Notifications_SendMessage_SendingMode_DelayedPush Notifications_SendMessage_SendingMode = "delayed_push"
	Notifications_SendMessage_SendingMode_Immediately Notifications_SendMessage_SendingMode = "immediately"
)

type Notifications_SendMessage_Request struct {
	//  MinItems: 1
	//  MaxItems: 100
	//  Minimum: 0
	UserIds *[]int
	//  MaxLength: 254
	Message string
	//  MaxLength: 2047
	Fragment *string
	//  Format: int64
	//  Minimum: 0
	GroupId  *int
	RandomId *int
	// Type of sending (delivering) notifications: 'immediately' — push and bell notifications will be delivered as soon as possible, 'delayed' — push and bell notifications will be delivered in the most comfortable time for the user, 'delayed_push' — only push notifications will be delivered in the most comfortable time, while the bell notifications will be delivered as soon as possible
	//  Default: immediately
	SendingMode *Notifications_SendMessage_SendingMode
}

func (r Notifications_SendMessage_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	setString(values, "message", r.Message)
	if r.Fragment != nil {
		setString(values, "fragment", *r.Fragment)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.RandomId != nil {
		setInt(values, "random_id", *r.RandomId)
	}
	if r.SendingMode != nil {
		setString(values, "sending_mode", string(*r.SendingMode))
	}
	return
}

// Notifications_SendMessage ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_GroupAppIsNotInstalledInCommunity ]
//
// https://dev.vk.com/method/notifications.sendMessage
func (vk *VK) Notifications_SendMessage(ctx context.Context, req Notifications_SendMessage_Request, options ...Option) (resp Notifications_SendMessage_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("notifications.sendMessage", ctx, values, &resp)
	return
}

type Orders_CancelSubscription_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  Minimum: 0
	SubscriptionId int
	//  Default: 0
	PendingCancel *bool
}

func (r Orders_CancelSubscription_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setInt(values, "subscription_id", r.SubscriptionId)
	if r.PendingCancel != nil {
		setBool(values, "pending_cancel", *r.PendingCancel)
	}
	return
}

// Orders_CancelSubscription ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AppsSubscriptionNotFound, Error_AppsSubscriptionInvalidStatus ]
//
// https://dev.vk.com/method/orders.cancelSubscription
func (vk *VK) Orders_CancelSubscription(ctx context.Context, req Orders_CancelSubscription_Request, options ...Option) (resp Orders_CancelSubscription_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.cancelSubscription", ctx, values, &resp)
	return
}

type Orders_ChangeState_Action string

const (
	Orders_ChangeState_Action_Cancel Orders_ChangeState_Action = "cancel"
	Orders_ChangeState_Action_Charge Orders_ChangeState_Action = "charge"
	Orders_ChangeState_Action_Refund Orders_ChangeState_Action = "refund"
)

type Orders_ChangeState_Request struct {
	// order ID.
	//  Minimum: 0
	OrderId int
	// action to be done with the order. Available actions: *cancel — to cancel unconfirmed order. *charge — to confirm unconfirmed order. Applies only if processing of [vk.com/dev/payments_status|order_change_state] notification failed. *refund — to cancel confirmed order.
	Action Orders_ChangeState_Action
	// internal ID of the order in the application.
	//  Minimum: 0
	AppOrderId *int
	// if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
	TestMode *bool
}

func (r Orders_ChangeState_Request) fillIn(values url.Values) (err error) {
	setInt(values, "order_id", r.OrderId)
	setString(values, "action", string(r.Action))
	if r.AppOrderId != nil {
		setInt(values, "app_order_id", *r.AppOrderId)
	}
	if r.TestMode != nil {
		setBool(values, "test_mode", *r.TestMode)
	}
	return
}

// Orders_ChangeState Changes order status.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits, Error_ActionFailed ]
//
// https://dev.vk.com/method/orders.changeState
func (vk *VK) Orders_ChangeState(ctx context.Context, req Orders_ChangeState_Request, options ...Option) (resp Orders_ChangeState_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.changeState", ctx, values, &resp)
	return
}

type Orders_Get_Request struct {
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// number of returned orders.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
	TestMode *bool
}

func (r Orders_Get_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.TestMode != nil {
		setBool(values, "test_mode", *r.TestMode)
	}
	return
}

// Orders_Get Returns a list of orders.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/orders.get
func (vk *VK) Orders_Get(ctx context.Context, req Orders_Get_Request, options ...Option) (resp Orders_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.get", ctx, values, &resp)
	return
}

type Orders_GetAmount_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  MaxItems: 100
	Votes *[]string
}

func (r Orders_GetAmount_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	if r.Votes != nil {
		setStrings(values, "votes", *r.Votes)
	}
	return
}

// Orders_GetAmount ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/orders.getAmount
func (vk *VK) Orders_GetAmount(ctx context.Context, req Orders_GetAmount_Request, options ...Option) (resp Orders_GetAmount_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.getAmount", ctx, values, &resp)
	return
}

type Orders_GetById_Request struct {
	// order ID.
	//  Minimum: 0
	OrderId *int
	//  MaxItems: 500
	//  Minimum: 0
	OrderIds *[]int
	// if this parameter is set to 1, this method returns a list of test mode orders. By default — 0.
	TestMode *bool
}

func (r Orders_GetById_Request) fillIn(values url.Values) (err error) {
	if r.OrderId != nil {
		setInt(values, "order_id", *r.OrderId)
	}
	if r.OrderIds != nil {
		setInts(values, "order_ids", *r.OrderIds)
	}
	if r.TestMode != nil {
		setBool(values, "test_mode", *r.TestMode)
	}
	return
}

// Orders_GetById Returns information about orders by their IDs.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/orders.getById
func (vk *VK) Orders_GetById(ctx context.Context, req Orders_GetById_Request, options ...Option) (resp Orders_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.getById", ctx, values, &resp)
	return
}

type Orders_GetUserSubscriptionById_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  Minimum: 0
	SubscriptionId int
}

func (r Orders_GetUserSubscriptionById_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setInt(values, "subscription_id", r.SubscriptionId)
	return
}

// Orders_GetUserSubscriptionById ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AppsSubscriptionNotFound ]
//
// https://dev.vk.com/method/orders.getUserSubscriptionById
func (vk *VK) Orders_GetUserSubscriptionById(ctx context.Context, req Orders_GetUserSubscriptionById_Request, options ...Option) (resp Orders_GetUserSubscriptionById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.getUserSubscriptionById", ctx, values, &resp)
	return
}

type Orders_GetUserSubscriptions_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
}

func (r Orders_GetUserSubscriptions_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	return
}

// Orders_GetUserSubscriptions ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/orders.getUserSubscriptions
func (vk *VK) Orders_GetUserSubscriptions(ctx context.Context, req Orders_GetUserSubscriptions_Request, options ...Option) (resp Orders_GetUserSubscriptions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.getUserSubscriptions", ctx, values, &resp)
	return
}

type Orders_UpdateSubscription_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserId int
	//  Minimum: 0
	SubscriptionId int
	//  Minimum: 0
	Price int
}

func (r Orders_UpdateSubscription_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setInt(values, "subscription_id", r.SubscriptionId)
	setInt(values, "price", r.Price)
	return
}

// Orders_UpdateSubscription ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AppsSubscriptionNotFound, Error_AppsSubscriptionInvalidStatus ]
//
// https://dev.vk.com/method/orders.updateSubscription
func (vk *VK) Orders_UpdateSubscription(ctx context.Context, req Orders_UpdateSubscription_Request, options ...Option) (resp Orders_UpdateSubscription_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("orders.updateSubscription", ctx, values, &resp)
	return
}

type Pages_ClearCache_Request struct {
	// Address of the page where you need to refesh the cached version
	Url string
}

func (r Pages_ClearCache_Request) fillIn(values url.Values) (err error) {
	setString(values, "url", r.Url)
	return
}

// Pages_ClearCache Allows to clear the cache of particular 'external' pages which may be attached to VK posts.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/pages.clearCache
func (vk *VK) Pages_ClearCache(ctx context.Context, req Pages_ClearCache_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.clearCache", ctx, values, &resp)
	return
}

type Pages_Get_Request struct {
	// Page owner ID.
	//  Format: int64
	OwnerId *int
	// Wiki page ID.
	PageId *int
	// '1' — to return information about a global wiki page
	Global *bool
	// '1' — resulting wiki page is a preview for the attached link
	SitePreview *bool
	// Wiki page title.
	Title      *string
	NeedSource *bool
	// '1' — to return the page as HTML,
	NeedHtml *bool
}

func (r Pages_Get_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PageId != nil {
		setInt(values, "page_id", *r.PageId)
	}
	if r.Global != nil {
		setBool(values, "global", *r.Global)
	}
	if r.SitePreview != nil {
		setBool(values, "site_preview", *r.SitePreview)
	}
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.NeedSource != nil {
		setBool(values, "need_source", *r.NeedSource)
	}
	if r.NeedHtml != nil {
		setBool(values, "need_html", *r.NeedHtml)
	}
	return
}

// Pages_Get Returns information about a wiki page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/pages.get
func (vk *VK) Pages_Get(ctx context.Context, req Pages_Get_Request, options ...Option) (resp Pages_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.get", ctx, values, &resp)
	return
}

type Pages_GetHistory_Request struct {
	// Wiki page ID.
	PageId int
	// ID of the community that owns the wiki page.
	//  Format: int64
	GroupId *int
	//  Format: int64
	UserId *int
}

func (r Pages_GetHistory_Request) fillIn(values url.Values) (err error) {
	setInt(values, "page_id", r.PageId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Pages_GetHistory Returns a list of all previous versions of a wiki page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessPage, Error_ParamPageId ]
//
// https://dev.vk.com/method/pages.getHistory
func (vk *VK) Pages_GetHistory(ctx context.Context, req Pages_GetHistory_Request, options ...Option) (resp Pages_GetHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.getHistory", ctx, values, &resp)
	return
}

type Pages_GetTitles_Request struct {
	// ID of the community that owns the wiki page.
	//  Format: int64
	GroupId *int
}

func (r Pages_GetTitles_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Pages_GetTitles Returns a list of wiki pages in a group.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessPage ]
//
// https://dev.vk.com/method/pages.getTitles
func (vk *VK) Pages_GetTitles(ctx context.Context, req Pages_GetTitles_Request, options ...Option) (resp Pages_GetTitles_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.getTitles", ctx, values, &resp)
	return
}

type Pages_GetVersion_Request struct {
	VersionId int
	// ID of the community that owns the wiki page.
	//  Format: int64
	GroupId *int
	//  Format: int64
	UserId *int
	// '1' — to return the page as HTML
	NeedHtml *bool
}

func (r Pages_GetVersion_Request) fillIn(values url.Values) (err error) {
	setInt(values, "version_id", r.VersionId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.NeedHtml != nil {
		setBool(values, "need_html", *r.NeedHtml)
	}
	return
}

// Pages_GetVersion Returns the text of one of the previous versions of a wiki page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessPage ]
//
// https://dev.vk.com/method/pages.getVersion
func (vk *VK) Pages_GetVersion(ctx context.Context, req Pages_GetVersion_Request, options ...Option) (resp Pages_GetVersion_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.getVersion", ctx, values, &resp)
	return
}

type Pages_ParseWiki_Request struct {
	// Text of the wiki page.
	Text string
	// ID of the group in the context of which this markup is interpreted.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Pages_ParseWiki_Request) fillIn(values url.Values) (err error) {
	setString(values, "text", r.Text)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Pages_ParseWiki Returns HTML representation of the wiki markup.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/pages.parseWiki
func (vk *VK) Pages_ParseWiki(ctx context.Context, req Pages_ParseWiki_Request, options ...Option) (resp Pages_ParseWiki_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.parseWiki", ctx, values, &resp)
	return
}

type Pages_Save_Request struct {
	// Text of the wiki page in wiki-format.
	Text *string
	// Wiki page ID. The 'title' parameter can be passed instead of 'pid'.
	PageId *int
	// ID of the community that owns the wiki page.
	//  Format: int64
	GroupId *int
	// User ID
	//  Format: int64
	UserId *int
	// Wiki page title.
	Title *string
}

func (r Pages_Save_Request) fillIn(values url.Values) (err error) {
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	if r.PageId != nil {
		setInt(values, "page_id", *r.PageId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	return
}

// Pages_Save Saves the text of a wiki page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessPage, Error_ParamPageId, Error_ParamTitle ]
//
// https://dev.vk.com/method/pages.save
func (vk *VK) Pages_Save(ctx context.Context, req Pages_Save_Request, options ...Option) (resp Pages_Save_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.save", ctx, values, &resp)
	return
}

type Pages_SaveAccess_View int

const (
	Pages_SaveAccess_View_Managers Pages_SaveAccess_View = 0
	Pages_SaveAccess_View_Members  Pages_SaveAccess_View = 1
	Pages_SaveAccess_View_All      Pages_SaveAccess_View = 2
)

type Pages_SaveAccess_Edit int

const (
	Pages_SaveAccess_Edit_Managers Pages_SaveAccess_Edit = 0
	Pages_SaveAccess_Edit_Members  Pages_SaveAccess_Edit = 1
	Pages_SaveAccess_Edit_All      Pages_SaveAccess_Edit = 2
)

type Pages_SaveAccess_Request struct {
	// Wiki page ID.
	PageId int
	// ID of the community that owns the wiki page.
	//  Format: int64
	GroupId *int
	//  Format: int64
	UserId *int
	// Who can view the wiki page: '1' — only community members, '2' — all users can view the page, '0' — only community managers
	View *Pages_SaveAccess_View
	// Who can edit the wiki page: '1' — only community members, '2' — all users can edit the page, '0' — only community managers
	Edit *Pages_SaveAccess_Edit
}

func (r Pages_SaveAccess_Request) fillIn(values url.Values) (err error) {
	setInt(values, "page_id", r.PageId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.View != nil {
		setInt(values, "view", int(*r.View))
	}
	if r.Edit != nil {
		setInt(values, "edit", int(*r.Edit))
	}
	return
}

// Pages_SaveAccess Saves modified read and edit access settings for a wiki page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessPage, Error_ParamPageId ]
//
// https://dev.vk.com/method/pages.saveAccess
func (vk *VK) Pages_SaveAccess(ctx context.Context, req Pages_SaveAccess_Request, options ...Option) (resp Pages_SaveAccess_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("pages.saveAccess", ctx, values, &resp)
	return
}

type Photos_ConfirmTag_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId string
	// Tag ID.
	TagId int
}

func (r Photos_ConfirmTag_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setString(values, "photo_id", r.PhotoId)
	setInt(values, "tag_id", r.TagId)
	return
}

// Photos_ConfirmTag Confirms a tag on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.confirmTag
func (vk *VK) Photos_ConfirmTag(ctx context.Context, req Photos_ConfirmTag_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.confirmTag", ctx, values, &resp)
	return
}

type Photos_Copy_Request struct {
	// photo's owner ID
	//  Format: int64
	OwnerId int
	// photo ID
	//  Minimum: 0
	PhotoId int
	// for private photos
	AccessKey *string
}

func (r Photos_Copy_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "photo_id", r.PhotoId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Photos_Copy Allows to copy a photo to the "Saved photos" album
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.copy
func (vk *VK) Photos_Copy(ctx context.Context, req Photos_Copy_Request, options ...Option) (resp Photos_Copy_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.copy", ctx, values, &resp)
	return
}

type Photos_CreateAlbum_Request struct {
	// Album title.
	//  MinLength: 2
	Title string
	// ID of the community in which the album will be created.
	//  Format: int64
	GroupId *int
	// Album description.
	Description *string
	//  Default: all
	PrivacyView *[]string
	//  Default: all
	PrivacyComment     *[]string
	UploadByAdminsOnly *bool
	CommentsDisabled   *bool
}

func (r Photos_CreateAlbum_Request) fillIn(values url.Values) (err error) {
	setString(values, "title", r.Title)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	if r.UploadByAdminsOnly != nil {
		setBool(values, "upload_by_admins_only", *r.UploadByAdminsOnly)
	}
	if r.CommentsDisabled != nil {
		setBool(values, "comments_disabled", *r.CommentsDisabled)
	}
	return
}

// Photos_CreateAlbum Creates an empty photo album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AlbumsLimit ]
//
// https://dev.vk.com/method/photos.createAlbum
func (vk *VK) Photos_CreateAlbum(ctx context.Context, req Photos_CreateAlbum_Request, options ...Option) (resp Photos_CreateAlbum_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.createAlbum", ctx, values, &resp)
	return
}

type Photos_CreateComment_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId int
	// Comment text.
	Message     *string
	Attachments *[]string
	// '1' — to post a comment from the community
	FromGroup      *bool
	ReplyToComment *int
	//  Minimum: 0
	StickerId *int
	AccessKey *string
	Guid      *string
}

func (r Photos_CreateComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.ReplyToComment != nil {
		setInt(values, "reply_to_comment", *r.ReplyToComment)
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Photos_CreateComment Adds a new comment on the photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.createComment
func (vk *VK) Photos_CreateComment(ctx context.Context, req Photos_CreateComment_Request, options ...Option) (resp Photos_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.createComment", ctx, values, &resp)
	return
}

type Photos_Delete_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	//  Minimum: 0
	PhotoId int
}

func (r Photos_Delete_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	return
}

// Photos_Delete Deletes a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.delete
func (vk *VK) Photos_Delete(ctx context.Context, req Photos_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.delete", ctx, values, &resp)
	return
}

type Photos_DeleteAlbum_Request struct {
	// Album ID.
	//  Minimum: 0
	AlbumId int
	// ID of the community that owns the album.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Photos_DeleteAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "album_id", r.AlbumId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Photos_DeleteAlbum Deletes a photo album belonging to the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId ]
//
// https://dev.vk.com/method/photos.deleteAlbum
func (vk *VK) Photos_DeleteAlbum(ctx context.Context, req Photos_DeleteAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.deleteAlbum", ctx, values, &resp)
	return
}

type Photos_DeleteComment_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	CommentId int
}

func (r Photos_DeleteComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Photos_DeleteComment Deletes a comment on the photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.deleteComment
func (vk *VK) Photos_DeleteComment(ctx context.Context, req Photos_DeleteComment_Request, options ...Option) (resp Photos_DeleteComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.deleteComment", ctx, values, &resp)
	return
}

type Photos_Edit_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	//  Minimum: 0
	PhotoId int
	// New caption for the photo. If this parameter is not set, it is considered to be equal to an empty string.
	Caption      *string
	Latitude     *float64
	Longitude    *float64
	PlaceStr     *string
	FoursquareId *string
	DeletePlace  *bool
}

func (r Photos_Edit_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.Caption != nil {
		setString(values, "caption", *r.Caption)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.PlaceStr != nil {
		setString(values, "place_str", *r.PlaceStr)
	}
	if r.FoursquareId != nil {
		setString(values, "foursquare_id", *r.FoursquareId)
	}
	if r.DeletePlace != nil {
		setBool(values, "delete_place", *r.DeletePlace)
	}
	return
}

// Photos_Edit Edits the caption of a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.edit
func (vk *VK) Photos_Edit(ctx context.Context, req Photos_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.edit", ctx, values, &resp)
	return
}

type Photos_EditAlbum_Request struct {
	// ID of the photo album to be edited.
	//  Minimum: 0
	AlbumId int
	// New album title.
	Title *string
	// New album description.
	Description *string
	// ID of the user or community that owns the album.
	//  Format: int64
	OwnerId            *int
	PrivacyView        *[]string
	PrivacyComment     *[]string
	UploadByAdminsOnly *bool
	CommentsDisabled   *bool
}

func (r Photos_EditAlbum_Request) fillIn(values url.Values) (err error) {
	setInt(values, "album_id", r.AlbumId)
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	if r.UploadByAdminsOnly != nil {
		setBool(values, "upload_by_admins_only", *r.UploadByAdminsOnly)
	}
	if r.CommentsDisabled != nil {
		setBool(values, "comments_disabled", *r.CommentsDisabled)
	}
	return
}

// Photos_EditAlbum Edits information about a photo album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId ]
//
// https://dev.vk.com/method/photos.editAlbum
func (vk *VK) Photos_EditAlbum(ctx context.Context, req Photos_EditAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.editAlbum", ctx, values, &resp)
	return
}

type Photos_EditComment_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	CommentId int
	// New text of the comment.
	Message     *string
	Attachments *[]string
}

func (r Photos_EditComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Photos_EditComment Edits a comment on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.editComment
func (vk *VK) Photos_EditComment(ctx context.Context, req Photos_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.editComment", ctx, values, &resp)
	return
}

type Photos_Get_Request struct {
	// ID of the user or community that owns the photos. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Photo album ID. To return information about photos from service albums, use the following string values: 'profile, wall, saved'.
	AlbumId  *string
	PhotoIds *[]string
	// Sort order: '1' — reverse chronological, '0' — chronological
	Rev *bool
	// '1' — to return additional 'likes', 'comments', and 'tags' fields, '0' — (default)
	Extended *bool
	// Type of feed obtained in 'feed' field of the method.
	FeedType *string
	// unixtime, that can be obtained with [vk.com/dev/newsfeed.get|newsfeed.get] method in date field to get all photos uploaded by the user on a specific day, or photos the user has been tagged on. Also, 'uid' parameter of the user the event happened with shall be specified.
	Feed *int
	// '1' — to return photo sizes in a [vk.com/dev/photo_sizes|special format]
	PhotoSizes *bool
	//  Minimum: 0
	Offset *int
	//  Default: 50
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Photos_Get_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.AlbumId != nil {
		setString(values, "album_id", *r.AlbumId)
	}
	if r.PhotoIds != nil {
		setStrings(values, "photo_ids", *r.PhotoIds)
	}
	if r.Rev != nil {
		setBool(values, "rev", *r.Rev)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.FeedType != nil {
		setString(values, "feed_type", *r.FeedType)
	}
	if r.Feed != nil {
		setInt(values, "feed", *r.Feed)
	}
	if r.PhotoSizes != nil {
		setBool(values, "photo_sizes", *r.PhotoSizes)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Photos_Get Returns a list of a user's or community's photos.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.get
func (vk *VK) Photos_Get(ctx context.Context, req Photos_Get_Request, options ...Option) (resp Photos_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.get", ctx, values, &resp)
	return
}

type Photos_GetAlbums_Request struct {
	// ID of the user or community that owns the albums.
	//  Format: int64
	OwnerId *int
	//  MaxItems: 1000
	AlbumIds *[]int
	// Offset needed to return a specific subset of albums.
	//  Minimum: 0
	Offset *int
	// Number of albums to return.
	//  Minimum: 0
	Count *int
	// '1' — to return system albums with negative IDs
	NeedSystem *bool
	// '1' — to return an additional 'thumb_src' field, '0' — (default)
	NeedCovers *bool
	// '1' — to return photo sizes in a
	PhotoSizes *bool
}

func (r Photos_GetAlbums_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.NeedSystem != nil {
		setBool(values, "need_system", *r.NeedSystem)
	}
	if r.NeedCovers != nil {
		setBool(values, "need_covers", *r.NeedCovers)
	}
	if r.PhotoSizes != nil {
		setBool(values, "photo_sizes", *r.PhotoSizes)
	}
	return
}

// Photos_GetAlbums Returns a list of a user's or community's photo albums.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getAlbums
func (vk *VK) Photos_GetAlbums(ctx context.Context, req Photos_GetAlbums_Request, options ...Option) (resp Photos_GetAlbums_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getAlbums", ctx, values, &resp)
	return
}

type Photos_GetAlbumsCount_Request struct {
	// User ID.
	//  Format: int64
	UserId *int
	// Community ID.
	//  Format: int64
	GroupId *int
}

func (r Photos_GetAlbumsCount_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Photos_GetAlbumsCount Returns the number of photo albums belonging to a user or community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getAlbumsCount
func (vk *VK) Photos_GetAlbumsCount(ctx context.Context, req Photos_GetAlbumsCount_Request, options ...Option) (resp Photos_GetAlbumsCount_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getAlbumsCount", ctx, values, &resp)
	return
}

type Photos_GetAll_Request struct {
	// ID of a user or community that owns the photos. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Offset needed to return a specific subset of photos. By default, '0'.
	//  Minimum: 0
	Offset *int
	// Number of photos to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// '1' - to return image sizes in [vk.com/dev/photo_sizes|special format].
	PhotoSizes *bool
	// '1' - to return photos only from standard albums, '0' - to return all photos including those in service albums, e.g., 'My wall photos' (default)
	NoServiceAlbums *bool
	// '1' - to show information about photos being hidden from the block above the wall.
	NeedHidden *bool
	// '1' - not to return photos being hidden from the block above the wall. Works only with owner_id>0, no_service_albums is ignored.
	SkipHidden *bool
}

func (r Photos_GetAll_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.PhotoSizes != nil {
		setBool(values, "photo_sizes", *r.PhotoSizes)
	}
	if r.NoServiceAlbums != nil {
		setBool(values, "no_service_albums", *r.NoServiceAlbums)
	}
	if r.NeedHidden != nil {
		setBool(values, "need_hidden", *r.NeedHidden)
	}
	if r.SkipHidden != nil {
		setBool(values, "skip_hidden", *r.SkipHidden)
	}
	return
}

// Photos_GetAll Returns a list of photos belonging to a user or community, in reverse chronological order.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Blocked ]
//
// https://dev.vk.com/method/photos.getAll
func (vk *VK) Photos_GetAll(ctx context.Context, req Photos_GetAll_Request, options ...Option) (resp Photos_GetAll_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getAll", ctx, values, &resp)
	return
}

// Photos_GetAllExtended Returns a list of photos belonging to a user or community, in reverse chronological order.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Blocked ]
//
// https://dev.vk.com/method/photos.getAll
func (vk *VK) Photos_GetAllExtended(ctx context.Context, req Photos_GetAll_Request, options ...Option) (resp Photos_GetAllExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getAll", ctx, values, &resp)
	return
}

type Photos_GetAllComments_Request struct {
	// ID of the user or community that owns the album(s).
	//  Format: int64
	OwnerId *int
	// Album ID. If the parameter is not set, comments on all of the user's albums will be returned.
	//  Minimum: 0
	AlbumId *int
	// '1' — to return an additional 'likes' field, '0' — (default)
	NeedLikes *bool
	// Offset needed to return a specific subset of comments. By default, '0'.
	//  Minimum: 0
	Offset *int
	// Number of comments to return. By default, '20'. Maximum value, '100'.
	//  Minimum: 0
	Count *int
}

func (r Photos_GetAllComments_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Photos_GetAllComments Returns a list of comments on a specific photo album or all albums of the user sorted in reverse chronological order.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId ]
//
// https://dev.vk.com/method/photos.getAllComments
func (vk *VK) Photos_GetAllComments(ctx context.Context, req Photos_GetAllComments_Request, options ...Option) (resp Photos_GetAllComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getAllComments", ctx, values, &resp)
	return
}

type Photos_GetById_Request struct {
	//  MaxItems: 500
	Photos *[]string
	// '1' — to return additional fields, '0' — (default)
	Extended *bool
	// '1' — to return photo sizes in a
	PhotoSizes *bool
}

func (r Photos_GetById_Request) fillIn(values url.Values) (err error) {
	if r.Photos != nil {
		setStrings(values, "photos", *r.Photos)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.PhotoSizes != nil {
		setBool(values, "photo_sizes", *r.PhotoSizes)
	}
	return
}

// Photos_GetById Returns information about photos by their IDs.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getById
func (vk *VK) Photos_GetById(ctx context.Context, req Photos_GetById_Request, options ...Option) (resp Photos_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getById", ctx, values, &resp)
	return
}

type Photos_GetChatUploadServer_Request struct {
	// ID of the chat for which you want to upload a cover photo.
	//  Minimum: 0
	ChatId int
	//  Minimum: 0
	CropX *int
	//  Minimum: 0
	CropY *int
	// Width (in pixels) of the photo after cropping.
	//  Minimum: 200
	CropWidth *int
}

func (r Photos_GetChatUploadServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "chat_id", r.ChatId)
	if r.CropX != nil {
		setInt(values, "crop_x", *r.CropX)
	}
	if r.CropY != nil {
		setInt(values, "crop_y", *r.CropY)
	}
	if r.CropWidth != nil {
		setInt(values, "crop_width", *r.CropWidth)
	}
	return
}

// Photos_GetChatUploadServer Returns an upload link for chat cover pictures.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getChatUploadServer
func (vk *VK) Photos_GetChatUploadServer(ctx context.Context, req Photos_GetChatUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getChatUploadServer", ctx, values, &resp)
	return
}

type Photos_GetComments_Sort string

const (
	Photos_GetComments_Sort_OldFirst Photos_GetComments_Sort = "asc"
	Photos_GetComments_Sort_NewFirst Photos_GetComments_Sort = "desc"
)

type Photos_GetComments_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId int
	// '1' — to return an additional 'likes' field, '0' — (default)
	NeedLikes *bool
	//  Minimum: 0
	StartCommentId *int
	// Offset needed to return a specific subset of comments. By default, '0'.
	Offset *int
	// Number of comments to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// Sort order: 'asc' — old first, 'desc' — new first
	Sort      *Photos_GetComments_Sort
	AccessKey *string
	Fields    *[]Users_Fields
}

func (r Photos_GetComments_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.StartCommentId != nil {
		setInt(values, "start_comment_id", *r.StartCommentId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Photos_GetComments Returns a list of comments on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getComments
func (vk *VK) Photos_GetComments(ctx context.Context, req Photos_GetComments_Request, options ...Option) (resp Photos_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getComments", ctx, values, &resp)
	return
}

// Photos_GetCommentsExtended Returns a list of comments on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getComments
func (vk *VK) Photos_GetCommentsExtended(ctx context.Context, req Photos_GetComments_Request, options ...Option) (resp Photos_GetCommentsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getComments", ctx, values, &resp)
	return
}

type Photos_GetMarketAlbumUploadServer_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
}

func (r Photos_GetMarketAlbumUploadServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	return
}

// Photos_GetMarketAlbumUploadServer Returns the server address for market album photo upload.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/photos.getMarketAlbumUploadServer
func (vk *VK) Photos_GetMarketAlbumUploadServer(ctx context.Context, req Photos_GetMarketAlbumUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getMarketAlbumUploadServer", ctx, values, &resp)
	return
}

type Photos_GetMarketUploadServer_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// '1' if you want to upload the main item photo.
	MainPhoto *bool
	// X coordinate of the crop left upper corner.
	//  Minimum: 0
	CropX *int
	// Y coordinate of the crop left upper corner.
	//  Minimum: 0
	CropY *int
	// Width of the cropped photo in px.
	//  Minimum: 400
	CropWidth *int
}

func (r Photos_GetMarketUploadServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.MainPhoto != nil {
		setBool(values, "main_photo", *r.MainPhoto)
	}
	if r.CropX != nil {
		setInt(values, "crop_x", *r.CropX)
	}
	if r.CropY != nil {
		setInt(values, "crop_y", *r.CropY)
	}
	if r.CropWidth != nil {
		setInt(values, "crop_width", *r.CropWidth)
	}
	return
}

// Photos_GetMarketUploadServer Returns the server address for market photo upload.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/photos.getMarketUploadServer
func (vk *VK) Photos_GetMarketUploadServer(ctx context.Context, req Photos_GetMarketUploadServer_Request, options ...Option) (resp Photos_GetMarketUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getMarketUploadServer", ctx, values, &resp)
	return
}

type Photos_GetMessagesUploadServer_Request struct {
	// Destination ID. "For user: 'User ID', e.g. '12345'. For chat: '2000000000' + 'Chat ID', e.g. '2000000001'. For community: '- Community ID', e.g. '-12345'. "
	PeerId *int
}

func (r Photos_GetMessagesUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.PeerId != nil {
		setInt(values, "peer_id", *r.PeerId)
	}
	return
}

// Photos_GetMessagesUploadServer Returns the server address for photo upload in a private message for a user.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesDenySend ]
//
// https://dev.vk.com/method/photos.getMessagesUploadServer
func (vk *VK) Photos_GetMessagesUploadServer(ctx context.Context, req Photos_GetMessagesUploadServer_Request, options ...Option) (resp Photos_GetMessagesUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getMessagesUploadServer", ctx, values, &resp)
	return
}

type Photos_GetNewTags_Request struct {
	// Offset needed to return a specific subset of photos.
	Offset *int
	// Number of photos to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r Photos_GetNewTags_Request) fillIn(values url.Values) (err error) {
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Photos_GetNewTags Returns a list of photos with tags that have not been viewed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getNewTags
func (vk *VK) Photos_GetNewTags(ctx context.Context, req Photos_GetNewTags_Request, options ...Option) (resp Photos_GetNewTags_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getNewTags", ctx, values, &resp)
	return
}

type Photos_GetOwnerCoverPhotoUploadServer_Request struct {
	// ID of community that owns the album (if the photo will be uploaded to a community album).
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// X coordinate of the left-upper corner
	//  Default: 0
	//  Minimum: 0
	CropX *int
	// Y coordinate of the left-upper corner
	//  Default: 0
	//  Minimum: 0
	CropY *int
	// X coordinate of the right-bottom corner
	//  Default: 795
	//  Minimum: 0
	CropX2 *int
	// Y coordinate of the right-bottom corner
	//  Default: 200
	//  Minimum: 0
	CropY2 *int
}

func (r Photos_GetOwnerCoverPhotoUploadServer_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	if r.CropX != nil {
		setInt(values, "crop_x", *r.CropX)
	}
	if r.CropY != nil {
		setInt(values, "crop_y", *r.CropY)
	}
	if r.CropX2 != nil {
		setInt(values, "crop_x2", *r.CropX2)
	}
	if r.CropY2 != nil {
		setInt(values, "crop_y2", *r.CropY2)
	}
	return
}

// Photos_GetOwnerCoverPhotoUploadServer Returns the server address for owner cover upload.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getOwnerCoverPhotoUploadServer
func (vk *VK) Photos_GetOwnerCoverPhotoUploadServer(ctx context.Context, req Photos_GetOwnerCoverPhotoUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getOwnerCoverPhotoUploadServer", ctx, values, &resp)
	return
}

type Photos_GetOwnerPhotoUploadServer_Request struct {
	// identifier of a community or current user. "Note that community id must be negative. 'owner_id=1' - user, 'owner_id=-1' - community, "
	//  Format: int64
	OwnerId *int
}

func (r Photos_GetOwnerPhotoUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Photos_GetOwnerPhotoUploadServer Returns an upload server address for a profile or community photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getOwnerPhotoUploadServer
func (vk *VK) Photos_GetOwnerPhotoUploadServer(ctx context.Context, req Photos_GetOwnerPhotoUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getOwnerPhotoUploadServer", ctx, values, &resp)
	return
}

type Photos_GetTags_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId   int
	AccessKey *string
}

func (r Photos_GetTags_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	return
}

// Photos_GetTags Returns a list of tags on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getTags
func (vk *VK) Photos_GetTags(ctx context.Context, req Photos_GetTags_Request, options ...Option) (resp Photos_GetTags_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getTags", ctx, values, &resp)
	return
}

type Photos_GetUploadServer_Request struct {
	//  Format: int32
	AlbumId *int
	// ID of community that owns the album (if the photo will be uploaded to a community album).
	//  Format: int64
	GroupId *int
}

func (r Photos_GetUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Photos_GetUploadServer Returns the server address for photo upload.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getUploadServer
func (vk *VK) Photos_GetUploadServer(ctx context.Context, req Photos_GetUploadServer_Request, options ...Option) (resp Photos_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getUploadServer", ctx, values, &resp)
	return
}

type Photos_GetUserPhotos_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Offset needed to return a specific subset of photos. By default, '0'.
	//  Minimum: 0
	Offset *int
	// Number of photos to return. Maximum value is 1000.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// '1' — to return an additional 'likes' field, '0' — (default)
	Extended *bool
	// Sort order: '1' — by date the tag was added in ascending order, '0' — by date the tag was added in descending order
	Sort *string
}

func (r Photos_GetUserPhotos_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Sort != nil {
		setString(values, "sort", *r.Sort)
	}
	return
}

// Photos_GetUserPhotos Returns a list of photos in which a user is tagged.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getUserPhotos
func (vk *VK) Photos_GetUserPhotos(ctx context.Context, req Photos_GetUserPhotos_Request, options ...Option) (resp Photos_GetUserPhotos_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getUserPhotos", ctx, values, &resp)
	return
}

type Photos_GetWallUploadServer_Request struct {
	// ID of community to whose wall the photo will be uploaded.
	//  Format: int64
	GroupId *int
}

func (r Photos_GetWallUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Photos_GetWallUploadServer Returns the server address for photo upload onto a user's wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.getWallUploadServer
func (vk *VK) Photos_GetWallUploadServer(ctx context.Context, req Photos_GetWallUploadServer_Request, options ...Option) (resp Photos_GetWallUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.getWallUploadServer", ctx, values, &resp)
	return
}

type Photos_MakeCover_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId int
	// Album ID.
	AlbumId *int
}

func (r Photos_MakeCover_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	return
}

// Photos_MakeCover Makes a photo into an album cover.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.makeCover
func (vk *VK) Photos_MakeCover(ctx context.Context, req Photos_MakeCover_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.makeCover", ctx, values, &resp)
	return
}

type Photos_Move_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// ID of the album to which the photo will be moved.
	TargetAlbumId int
	//  MaxItems: 100
	PhotoIds int
}

func (r Photos_Move_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "target_album_id", r.TargetAlbumId)
	setInt(values, "photo_ids", r.PhotoIds)
	return
}

// Photos_Move Moves a photo from one album to another.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.move
func (vk *VK) Photos_Move(ctx context.Context, req Photos_Move_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.move", ctx, values, &resp)
	return
}

type Photos_PutTag_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	//  Minimum: 0
	PhotoId int
	// ID of the user to be tagged.
	//  Format: int64
	UserId int
	// Upper left-corner coordinate of the tagged area (as a percentage of the photo's width).
	X *float64
	// Upper left-corner coordinate of the tagged area (as a percentage of the photo's height).
	Y *float64
	// Lower right-corner coordinate of the tagged area (as a percentage of the photo's width).
	X2 *float64
	// Lower right-corner coordinate of the tagged area (as a percentage of the photo's height).
	Y2 *float64
}

func (r Photos_PutTag_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	setInt(values, "user_id", r.UserId)
	if r.X != nil {
		setFloat(values, "x", *r.X)
	}
	if r.Y != nil {
		setFloat(values, "y", *r.Y)
	}
	if r.X2 != nil {
		setFloat(values, "x2", *r.X2)
	}
	if r.Y2 != nil {
		setFloat(values, "y2", *r.Y2)
	}
	return
}

// Photos_PutTag Adds a tag on the photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.putTag
func (vk *VK) Photos_PutTag(ctx context.Context, req Photos_PutTag_Request, options ...Option) (resp Photos_PutTag_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.putTag", ctx, values, &resp)
	return
}

type Photos_RemoveTag_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId int
	// Tag ID.
	TagId int
}

func (r Photos_RemoveTag_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	setInt(values, "tag_id", r.TagId)
	return
}

// Photos_RemoveTag Removes a tag from a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.removeTag
func (vk *VK) Photos_RemoveTag(ctx context.Context, req Photos_RemoveTag_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.removeTag", ctx, values, &resp)
	return
}

type Photos_ReorderAlbums_Request struct {
	// ID of the user or community that owns the album.
	//  Format: int64
	OwnerId *int
	// Album ID.
	AlbumId int
	// ID of the album before which the album in question shall be placed.
	Before *int
	// ID of the album after which the album in question shall be placed.
	After *int
}

func (r Photos_ReorderAlbums_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "album_id", r.AlbumId)
	if r.Before != nil {
		setInt(values, "before", *r.Before)
	}
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Photos_ReorderAlbums Reorders the album in the list of user albums.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.reorderAlbums
func (vk *VK) Photos_ReorderAlbums(ctx context.Context, req Photos_ReorderAlbums_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.reorderAlbums", ctx, values, &resp)
	return
}

type Photos_ReorderPhotos_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	PhotoId int
	// ID of the photo before which the photo in question shall be placed.
	Before *int
	// ID of the photo after which the photo in question shall be placed.
	After *int
}

func (r Photos_ReorderPhotos_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	if r.Before != nil {
		setInt(values, "before", *r.Before)
	}
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Photos_ReorderPhotos Reorders the photo in the list of photos of the user album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhotos ]
//
// https://dev.vk.com/method/photos.reorderPhotos
func (vk *VK) Photos_ReorderPhotos(ctx context.Context, req Photos_ReorderPhotos_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.reorderPhotos", ctx, values, &resp)
	return
}

type Photos_Report_Reason int

const (
	Photos_Report_Reason_Spam             Photos_Report_Reason = 0
	Photos_Report_Reason_ChildPornography Photos_Report_Reason = 1
	Photos_Report_Reason_Extremism        Photos_Report_Reason = 2
	Photos_Report_Reason_Violence         Photos_Report_Reason = 3
	Photos_Report_Reason_DrugPropaganda   Photos_Report_Reason = 4
	Photos_Report_Reason_AdultMaterial    Photos_Report_Reason = 5
	Photos_Report_Reason_InsultAbuse      Photos_Report_Reason = 6
)

type Photos_Report_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId int
	// Photo ID.
	//  Minimum: 0
	PhotoId int
	// Reason for the complaint: '0' - spam, '1' - child pornography, '2' - extremism, '3' - violence, '4' - drug propaganda, '5' - adult material, '6' - insult, abuse
	//  Minimum: 0
	Reason *Photos_Report_Reason
}

func (r Photos_Report_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "photo_id", r.PhotoId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Photos_Report Reports (submits a complaint about) a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.report
func (vk *VK) Photos_Report(ctx context.Context, req Photos_Report_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.report", ctx, values, &resp)
	return
}

type Photos_ReportComment_Reason int

const (
	Photos_ReportComment_Reason_Spam             Photos_ReportComment_Reason = 0
	Photos_ReportComment_Reason_ChildPornography Photos_ReportComment_Reason = 1
	Photos_ReportComment_Reason_Extremism        Photos_ReportComment_Reason = 2
	Photos_ReportComment_Reason_Violence         Photos_ReportComment_Reason = 3
	Photos_ReportComment_Reason_DrugPropaganda   Photos_ReportComment_Reason = 4
	Photos_ReportComment_Reason_AdultMaterial    Photos_ReportComment_Reason = 5
	Photos_ReportComment_Reason_InsultAbuse      Photos_ReportComment_Reason = 6
)

type Photos_ReportComment_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId int
	// ID of the comment being reported.
	//  Minimum: 0
	CommentId int
	// Reason for the complaint: '0' - spam, '1' - child pornography, '2' - extremism, '3' - violence, '4' - drug propaganda, '5' - adult material, '6' - insult, abuse
	//  Minimum: 0
	Reason *Photos_ReportComment_Reason
}

func (r Photos_ReportComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Photos_ReportComment Reports (submits a complaint about) a comment on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.reportComment
func (vk *VK) Photos_ReportComment(ctx context.Context, req Photos_ReportComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.reportComment", ctx, values, &resp)
	return
}

type Photos_Restore_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// Photo ID.
	//  Minimum: 0
	PhotoId int
}

func (r Photos_Restore_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "photo_id", r.PhotoId)
	return
}

// Photos_Restore Restores a deleted photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.restore
func (vk *VK) Photos_Restore(ctx context.Context, req Photos_Restore_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.restore", ctx, values, &resp)
	return
}

type Photos_RestoreComment_Request struct {
	// ID of the user or community that owns the photo.
	//  Format: int64
	OwnerId *int
	// ID of the deleted comment.
	CommentId int
}

func (r Photos_RestoreComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Photos_RestoreComment Restores a deleted comment on a photo.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.restoreComment
func (vk *VK) Photos_RestoreComment(ctx context.Context, req Photos_RestoreComment_Request, options ...Option) (resp Photos_RestoreComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.restoreComment", ctx, values, &resp)
	return
}

type Photos_Save_Request struct {
	// ID of the album to save photos to.
	AlbumId *int
	// ID of the community to save photos to.
	//  Format: int64
	GroupId *int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Server *int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	PhotosList *string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash *string
	// Geographical latitude, in degrees (from '-90' to '90').
	Latitude *float64
	// Geographical longitude, in degrees (from '-180' to '180').
	Longitude *float64
	// Text describing the photo. 2048 digits max.
	Caption *string
}

func (r Photos_Save_Request) fillIn(values url.Values) (err error) {
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.Server != nil {
		setInt(values, "server", *r.Server)
	}
	if r.PhotosList != nil {
		setString(values, "photos_list", *r.PhotosList)
	}
	if r.Hash != nil {
		setString(values, "hash", *r.Hash)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.Caption != nil {
		setString(values, "caption", *r.Caption)
	}
	return
}

// Photos_Save Saves photos after successful uploading.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId, Error_ParamServer, Error_ParamHash ]
//
// https://dev.vk.com/method/photos.save
func (vk *VK) Photos_Save(ctx context.Context, req Photos_Save_Request, options ...Option) (resp Photos_Save_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.save", ctx, values, &resp)
	return
}

type Photos_SaveMarketAlbumPhoto_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 1
	GroupId int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Photo string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	//  Minimum: 0
	Server int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash string
}

func (r Photos_SaveMarketAlbumPhoto_Request) fillIn(values url.Values) (err error) {
	setInt(values, "group_id", r.GroupId)
	setString(values, "photo", r.Photo)
	setInt(values, "server", r.Server)
	setString(values, "hash", r.Hash)
	return
}

// Photos_SaveMarketAlbumPhoto Saves market album photos after successful uploading.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamHash, Error_ParamPhoto, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/photos.saveMarketAlbumPhoto
func (vk *VK) Photos_SaveMarketAlbumPhoto(ctx context.Context, req Photos_SaveMarketAlbumPhoto_Request, options ...Option) (resp Photos_SaveMarketAlbumPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveMarketAlbumPhoto", ctx, values, &resp)
	return
}

type Photos_SaveMarketPhoto_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Photo string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Server int
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	CropData *string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	CropHash *string
}

func (r Photos_SaveMarketPhoto_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	setString(values, "photo", r.Photo)
	setInt(values, "server", r.Server)
	setString(values, "hash", r.Hash)
	if r.CropData != nil {
		setString(values, "crop_data", *r.CropData)
	}
	if r.CropHash != nil {
		setString(values, "crop_hash", *r.CropHash)
	}
	return
}

// Photos_SaveMarketPhoto Saves market photos after successful uploading.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamHash, Error_ParamPhoto, Error_MarketNotEnabled ]
//
// https://dev.vk.com/method/photos.saveMarketPhoto
func (vk *VK) Photos_SaveMarketPhoto(ctx context.Context, req Photos_SaveMarketPhoto_Request, options ...Option) (resp Photos_SaveMarketPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveMarketPhoto", ctx, values, &resp)
	return
}

type Photos_SaveMessagesPhoto_Request struct {
	// Parameter returned when the photo is [vk.com/dev/upload_files|uploaded to the server].
	Photo  string
	Server *int
	Hash   *string
}

func (r Photos_SaveMessagesPhoto_Request) fillIn(values url.Values) (err error) {
	setString(values, "photo", r.Photo)
	if r.Server != nil {
		setInt(values, "server", *r.Server)
	}
	if r.Hash != nil {
		setString(values, "hash", *r.Hash)
	}
	return
}

// Photos_SaveMessagesPhoto Saves a photo after being successfully uploaded. URL obtained with [vk.com/dev/photos.getMessagesUploadServer|photos.getMessagesUploadServer] method.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId, Error_ParamServer, Error_ParamHash ]
//
// https://dev.vk.com/method/photos.saveMessagesPhoto
func (vk *VK) Photos_SaveMessagesPhoto(ctx context.Context, req Photos_SaveMessagesPhoto_Request, options ...Option) (resp Photos_SaveMessagesPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveMessagesPhoto", ctx, values, &resp)
	return
}

type Photos_SaveOwnerCoverPhoto_Request struct {
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Hash string
	// Parameter returned when photos are [vk.com/dev/upload_files|uploaded to server].
	Photo string
}

func (r Photos_SaveOwnerCoverPhoto_Request) fillIn(values url.Values) (err error) {
	setString(values, "hash", r.Hash)
	setString(values, "photo", r.Photo)
	return
}

// Photos_SaveOwnerCoverPhoto Saves cover photo after successful uploading.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhoto ]
//
// https://dev.vk.com/method/photos.saveOwnerCoverPhoto
func (vk *VK) Photos_SaveOwnerCoverPhoto(ctx context.Context, req Photos_SaveOwnerCoverPhoto_Request, options ...Option) (resp Photos_SaveOwnerCoverPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveOwnerCoverPhoto", ctx, values, &resp)
	return
}

type Photos_SaveOwnerPhoto_Request struct {
	// parameter returned after [vk.com/dev/upload_files|photo upload].
	Server *string
	// parameter returned after [vk.com/dev/upload_files|photo upload].
	Hash *string
	// parameter returned after [vk.com/dev/upload_files|photo upload].
	Photo *string
}

func (r Photos_SaveOwnerPhoto_Request) fillIn(values url.Values) (err error) {
	if r.Server != nil {
		setString(values, "server", *r.Server)
	}
	if r.Hash != nil {
		setString(values, "hash", *r.Hash)
	}
	if r.Photo != nil {
		setString(values, "photo", *r.Photo)
	}
	return
}

// Photos_SaveOwnerPhoto Saves a profile or community photo. Upload URL can be got with the [vk.com/dev/photos.getOwnerPhotoUploadServer|photos.getOwnerPhotoUploadServer] method.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhoto ]
//
// https://dev.vk.com/method/photos.saveOwnerPhoto
func (vk *VK) Photos_SaveOwnerPhoto(ctx context.Context, req Photos_SaveOwnerPhoto_Request, options ...Option) (resp Photos_SaveOwnerPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveOwnerPhoto", ctx, values, &resp)
	return
}

type Photos_SaveWallPhoto_Request struct {
	// ID of the user on whose wall the photo will be saved.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// ID of community on whose wall the photo will be saved.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Parameter returned when the the photo is [vk.com/dev/upload_files|uploaded to the server].
	Photo  string
	Server *int
	Hash   *string
	// Geographical latitude, in degrees (from '-90' to '90').
	Latitude *float64
	// Geographical longitude, in degrees (from '-180' to '180').
	Longitude *float64
	// Text describing the photo. 2048 digits max.
	Caption *string
}

func (r Photos_SaveWallPhoto_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	setString(values, "photo", r.Photo)
	if r.Server != nil {
		setInt(values, "server", *r.Server)
	}
	if r.Hash != nil {
		setString(values, "hash", *r.Hash)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.Caption != nil {
		setString(values, "caption", *r.Caption)
	}
	return
}

// Photos_SaveWallPhoto Saves a photo to a user's or community's wall after being uploaded.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamAlbumId, Error_ParamServer, Error_ParamHash ]
//
// https://dev.vk.com/method/photos.saveWallPhoto
func (vk *VK) Photos_SaveWallPhoto(ctx context.Context, req Photos_SaveWallPhoto_Request, options ...Option) (resp Photos_SaveWallPhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.saveWallPhoto", ctx, values, &resp)
	return
}

type Photos_Search_Request struct {
	// Search query string.
	Q *string
	// Geographical latitude, in degrees (from '-90' to '90').
	Lat *float64
	// Geographical longitude, in degrees (from '-180' to '180').
	Long *float64
	//  Minimum: 0
	StartTime *int
	//  Minimum: 0
	EndTime *int
	// Sort order:
	//  Minimum: 0
	Sort *int
	// Offset needed to return a specific subset of photos.
	//  Minimum: 0
	Offset *int
	// Number of photos to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
	// Radius of search in meters (works very approximately). Available values: '10', '100', '800', '6000', '50000'.
	//  Default: 5000
	//  Minimum: 0
	Radius *int
}

func (r Photos_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.StartTime != nil {
		setInt(values, "start_time", *r.StartTime)
	}
	if r.EndTime != nil {
		setInt(values, "end_time", *r.EndTime)
	}
	if r.Sort != nil {
		setInt(values, "sort", *r.Sort)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Radius != nil {
		setInt(values, "radius", *r.Radius)
	}
	return
}

// Photos_Search Returns a list of photos.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/photos.search
func (vk *VK) Photos_Search(ctx context.Context, req Photos_Search_Request, options ...Option) (resp Photos_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("photos.search", ctx, values, &resp)
	return
}

type Podcasts_SearchPodcast_Request struct {
	SearchString string
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 20
	//  Minimum: 1
	//  Maximum: 1000
	Count *int
}

func (r Podcasts_SearchPodcast_Request) fillIn(values url.Values) (err error) {
	setString(values, "search_string", r.SearchString)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Podcasts_SearchPodcast ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/podcasts.searchPodcast
func (vk *VK) Podcasts_SearchPodcast(ctx context.Context, req Podcasts_SearchPodcast_Request, options ...Option) (resp Podcasts_SearchPodcast_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("podcasts.searchPodcast", ctx, values, &resp)
	return
}

type Polls_AddVote_Request struct {
	// ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Poll ID.
	//  Minimum: 0
	PollId int
	//  Minimum: 0
	AnswerIds *[]int
	IsBoard   *bool
}

func (r Polls_AddVote_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "poll_id", r.PollId)
	if r.AnswerIds != nil {
		setInts(values, "answer_ids", *r.AnswerIds)
	}
	if r.IsBoard != nil {
		setBool(values, "is_board", *r.IsBoard)
	}
	return
}

// Polls_AddVote Adds the current user's vote to the selected answer in the poll.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PollsAccess, Error_PollsAnswerId, Error_PollsPollId ]
//
// https://dev.vk.com/method/polls.addVote
func (vk *VK) Polls_AddVote(ctx context.Context, req Polls_AddVote_Request, options ...Option) (resp Polls_AddVote_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.addVote", ctx, values, &resp)
	return
}

type Polls_Create_BackgroundId int

const (
	Polls_Create_BackgroundId_1 Polls_Create_BackgroundId = 1
	Polls_Create_BackgroundId_2 Polls_Create_BackgroundId = 2
	Polls_Create_BackgroundId_3 Polls_Create_BackgroundId = 3
	Polls_Create_BackgroundId_4 Polls_Create_BackgroundId = 4
	Polls_Create_BackgroundId_6 Polls_Create_BackgroundId = 6
	Polls_Create_BackgroundId_8 Polls_Create_BackgroundId = 8
	Polls_Create_BackgroundId_9 Polls_Create_BackgroundId = 9
)

type Polls_Create_Request struct {
	// question text
	Question *string
	// '1' - anonymous poll, participants list is hidden,, '0' - public poll, participants list is available,, Default value is '0'.
	IsAnonymous *bool
	IsMultiple  *bool
	//  Minimum: 1.5507e+09
	EndDate *int
	// If a poll will be added to a communty it is required to send a negative group identifier. Current user by default.
	//  Format: int64
	OwnerId *int
	AppId   *int
	// available answers list, for example: " ["yes","no","maybe"]", There can be from 1 to 10 answers.
	AddAnswers *string
	//  Minimum: 0
	PhotoId       *int
	BackgroundId  *Polls_Create_BackgroundId
	DisableUnvote *bool
}

func (r Polls_Create_Request) fillIn(values url.Values) (err error) {
	if r.Question != nil {
		setString(values, "question", *r.Question)
	}
	if r.IsAnonymous != nil {
		setBool(values, "is_anonymous", *r.IsAnonymous)
	}
	if r.IsMultiple != nil {
		setBool(values, "is_multiple", *r.IsMultiple)
	}
	if r.EndDate != nil {
		setInt(values, "end_date", *r.EndDate)
	}
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.AppId != nil {
		setInt(values, "app_id", *r.AppId)
	}
	if r.AddAnswers != nil {
		setString(values, "add_answers", *r.AddAnswers)
	}
	if r.PhotoId != nil {
		setInt(values, "photo_id", *r.PhotoId)
	}
	if r.BackgroundId != nil {
		setInt(values, "background_id", int(*r.BackgroundId))
	}
	if r.DisableUnvote != nil {
		setBool(values, "disable_unvote", *r.DisableUnvote)
	}
	return
}

// Polls_Create Creates polls that can be attached to the users' or communities' posts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/polls.create
func (vk *VK) Polls_Create(ctx context.Context, req Polls_Create_Request, options ...Option) (resp Polls_Create_Response, apiErr ApiError, err error) {
	values := make(url.Values, 12+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.create", ctx, values, &resp)
	return
}

type Polls_DeleteVote_Request struct {
	// ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Poll ID.
	//  Minimum: 0
	PollId int
	// Answer ID.
	//  Minimum: 0
	AnswerId int
	IsBoard  *bool
}

func (r Polls_DeleteVote_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "poll_id", r.PollId)
	setInt(values, "answer_id", r.AnswerId)
	if r.IsBoard != nil {
		setBool(values, "is_board", *r.IsBoard)
	}
	return
}

// Polls_DeleteVote Deletes the current user's vote from the selected answer in the poll.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PollsAccess, Error_PollsAnswerId, Error_PollsPollId ]
//
// https://dev.vk.com/method/polls.deleteVote
func (vk *VK) Polls_DeleteVote(ctx context.Context, req Polls_DeleteVote_Request, options ...Option) (resp Polls_DeleteVote_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.deleteVote", ctx, values, &resp)
	return
}

type Polls_Edit_BackgroundId int

const (
	Polls_Edit_BackgroundId_0 Polls_Edit_BackgroundId = 0
	Polls_Edit_BackgroundId_1 Polls_Edit_BackgroundId = 1
	Polls_Edit_BackgroundId_2 Polls_Edit_BackgroundId = 2
	Polls_Edit_BackgroundId_3 Polls_Edit_BackgroundId = 3
	Polls_Edit_BackgroundId_4 Polls_Edit_BackgroundId = 4
	Polls_Edit_BackgroundId_6 Polls_Edit_BackgroundId = 6
	Polls_Edit_BackgroundId_8 Polls_Edit_BackgroundId = 8
	Polls_Edit_BackgroundId_9 Polls_Edit_BackgroundId = 9
)

type Polls_Edit_Request struct {
	// poll owner id
	//  Format: int64
	OwnerId *int
	// edited poll's id
	//  Minimum: 0
	PollId int
	// new question text
	Question *string
	// answers list, for example: , "["yes","no","maybe"]"
	AddAnswers *string
	// object containing answers that need to be edited,, key - answer id, value - new answer text. Example: {"382967099":"option1", "382967103":"option2"}"
	EditAnswers *string
	// list of answer ids to be deleted. For example: "[382967099, 382967103]"
	DeleteAnswers *string
	//  Minimum: 0
	EndDate *int
	//  Minimum: 0
	PhotoId      *int
	BackgroundId *Polls_Edit_BackgroundId
}

func (r Polls_Edit_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "poll_id", r.PollId)
	if r.Question != nil {
		setString(values, "question", *r.Question)
	}
	if r.AddAnswers != nil {
		setString(values, "add_answers", *r.AddAnswers)
	}
	if r.EditAnswers != nil {
		setString(values, "edit_answers", *r.EditAnswers)
	}
	if r.DeleteAnswers != nil {
		setString(values, "delete_answers", *r.DeleteAnswers)
	}
	if r.EndDate != nil {
		setInt(values, "end_date", *r.EndDate)
	}
	if r.PhotoId != nil {
		setInt(values, "photo_id", *r.PhotoId)
	}
	if r.BackgroundId != nil {
		setInt(values, "background_id", int(*r.BackgroundId))
	}
	return
}

// Polls_Edit Edits created polls
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/polls.edit
func (vk *VK) Polls_Edit(ctx context.Context, req Polls_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.edit", ctx, values, &resp)
	return
}

// Polls_GetBackgrounds ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/polls.getBackgrounds
func (vk *VK) Polls_GetBackgrounds(ctx context.Context, options ...Option) (resp Polls_GetBackgrounds_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.getBackgrounds", ctx, values, &resp)
	return
}

type Polls_GetById_NameCase string

const (
	Polls_GetById_NameCase_Abl Polls_GetById_NameCase = "abl"
	Polls_GetById_NameCase_Acc Polls_GetById_NameCase = "acc"
	Polls_GetById_NameCase_Dat Polls_GetById_NameCase = "dat"
	Polls_GetById_NameCase_Gen Polls_GetById_NameCase = "gen"
	Polls_GetById_NameCase_Ins Polls_GetById_NameCase = "ins"
	Polls_GetById_NameCase_Nom Polls_GetById_NameCase = "nom"
)

type Polls_GetById_Request struct {
	// ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// '1' - poll is in a board, '0' - poll is on a wall. '0' by default.
	IsBoard *bool
	// Poll ID.
	//  Minimum: 0
	PollId   int
	Extended *bool
	//  Default: 3
	//  Minimum: 0
	//  Maximum: 100
	FriendsCount *int
	Fields       *[]string
	//  Default: nom
	NameCase *Polls_GetById_NameCase
}

func (r Polls_GetById_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.IsBoard != nil {
		setBool(values, "is_board", *r.IsBoard)
	}
	setInt(values, "poll_id", r.PollId)
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.FriendsCount != nil {
		setInt(values, "friends_count", *r.FriendsCount)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Polls_GetById Returns detailed information about a poll by its ID.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PollsAccess ]
//
// https://dev.vk.com/method/polls.getById
func (vk *VK) Polls_GetById(ctx context.Context, req Polls_GetById_Request, options ...Option) (resp Polls_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.getById", ctx, values, &resp)
	return
}

type Polls_GetPhotoUploadServer_Request struct {
	//  Format: int64
	OwnerId *int
}

func (r Polls_GetPhotoUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Polls_GetPhotoUploadServer ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/polls.getPhotoUploadServer
func (vk *VK) Polls_GetPhotoUploadServer(ctx context.Context, req Polls_GetPhotoUploadServer_Request, options ...Option) (resp Base_GetUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.getPhotoUploadServer", ctx, values, &resp)
	return
}

type Polls_GetVoters_NameCase string

const (
	Polls_GetVoters_NameCase_Nominative    Polls_GetVoters_NameCase = "nom"
	Polls_GetVoters_NameCase_Genitive      Polls_GetVoters_NameCase = "gen"
	Polls_GetVoters_NameCase_Dative        Polls_GetVoters_NameCase = "dat"
	Polls_GetVoters_NameCase_Accusative    Polls_GetVoters_NameCase = "acc"
	Polls_GetVoters_NameCase_Instrumental  Polls_GetVoters_NameCase = "ins"
	Polls_GetVoters_NameCase_Prepositional Polls_GetVoters_NameCase = "abl"
)

type Polls_GetVoters_Request struct {
	// ID of the user or community that owns the poll. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Poll ID.
	//  Minimum: 0
	PollId int
	//  Minimum: 0
	AnswerIds *[]int
	IsBoard   *bool
	// '1' — to return only current user's friends, '0' — to return all users (default),
	FriendsOnly *bool
	// Offset needed to return a specific subset of voters. '0' — (default)
	//  Minimum: 0
	Offset *int
	// Number of user IDs to return (if the 'friends_only' parameter is not set, maximum '1000', otherwise '10'). '100' — (default)
	//  Minimum: 0
	Count  *int
	Fields *[]Users_Fields
	// Case for declension of user name and surname: , 'nom' — nominative (default) , 'gen' — genitive , 'dat' — dative , 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Polls_GetVoters_NameCase
}

func (r Polls_GetVoters_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "poll_id", r.PollId)
	if r.AnswerIds != nil {
		setInts(values, "answer_ids", *r.AnswerIds)
	}
	if r.IsBoard != nil {
		setBool(values, "is_board", *r.IsBoard)
	}
	if r.FriendsOnly != nil {
		setBool(values, "friends_only", *r.FriendsOnly)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Polls_GetVoters Returns a list of IDs of users who selected specific answers in the poll.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PollsAccess, Error_PollsAnswerId, Error_PollsPollId, Error_PollsAccessWithoutVote ]
//
// https://dev.vk.com/method/polls.getVoters
func (vk *VK) Polls_GetVoters(ctx context.Context, req Polls_GetVoters_Request, options ...Option) (resp Polls_GetVoters_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.getVoters", ctx, values, &resp)
	return
}

type Polls_SavePhoto_Request struct {
	Photo string
	Hash  string
}

func (r Polls_SavePhoto_Request) fillIn(values url.Values) (err error) {
	setString(values, "photo", r.Photo)
	setString(values, "hash", r.Hash)
	return
}

// Polls_SavePhoto ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ParamPhoto ]
//
// https://dev.vk.com/method/polls.savePhoto
func (vk *VK) Polls_SavePhoto(ctx context.Context, req Polls_SavePhoto_Request, options ...Option) (resp Polls_SavePhoto_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("polls.savePhoto", ctx, values, &resp)
	return
}

type PrettyCards_Create_Request struct {
	OwnerId int
	Photo   string
	Title   string
	//  MaxLength: 2000
	Link string
	//  MaxLength: 20
	Price *string
	//  MaxLength: 20
	PriceOld *string
	//  MaxLength: 255
	Button *string
}

func (r PrettyCards_Create_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setString(values, "photo", r.Photo)
	setString(values, "title", r.Title)
	setString(values, "link", r.Link)
	if r.Price != nil {
		setString(values, "price", *r.Price)
	}
	if r.PriceOld != nil {
		setString(values, "price_old", *r.PriceOld)
	}
	if r.Button != nil {
		setString(values, "button", *r.Button)
	}
	return
}

// PrettyCards_Create ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PrettyCardsTooManyCards ]
//
// https://dev.vk.com/method/prettyCards.create
func (vk *VK) PrettyCards_Create(ctx context.Context, req PrettyCards_Create_Request, options ...Option) (resp PrettyCards_Create_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.create", ctx, values, &resp)
	return
}

type PrettyCards_Delete_Request struct {
	OwnerId int
	CardId  int
}

func (r PrettyCards_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "card_id", r.CardId)
	return
}

// PrettyCards_Delete ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PrettyCardsCardNotFound, Error_PrettyCardsCardIsConnectedToPost ]
//
// https://dev.vk.com/method/prettyCards.delete
func (vk *VK) PrettyCards_Delete(ctx context.Context, req PrettyCards_Delete_Request, options ...Option) (resp PrettyCards_Delete_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.delete", ctx, values, &resp)
	return
}

type PrettyCards_Edit_Request struct {
	OwnerId int
	CardId  int
	Photo   *string
	Title   *string
	//  MaxLength: 2000
	Link *string
	//  MaxLength: 20
	Price *string
	//  MaxLength: 20
	PriceOld *string
	//  MaxLength: 255
	Button *string
}

func (r PrettyCards_Edit_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "card_id", r.CardId)
	if r.Photo != nil {
		setString(values, "photo", *r.Photo)
	}
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Link != nil {
		setString(values, "link", *r.Link)
	}
	if r.Price != nil {
		setString(values, "price", *r.Price)
	}
	if r.PriceOld != nil {
		setString(values, "price_old", *r.PriceOld)
	}
	if r.Button != nil {
		setString(values, "button", *r.Button)
	}
	return
}

// PrettyCards_Edit ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_PrettyCardsCardNotFound ]
//
// https://dev.vk.com/method/prettyCards.edit
func (vk *VK) PrettyCards_Edit(ctx context.Context, req PrettyCards_Edit_Request, options ...Option) (resp PrettyCards_Edit_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.edit", ctx, values, &resp)
	return
}

type PrettyCards_Get_Request struct {
	OwnerId int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 0
	//  Maximum: 100
	Count *int
}

func (r PrettyCards_Get_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// PrettyCards_Get ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/prettyCards.get
func (vk *VK) PrettyCards_Get(ctx context.Context, req PrettyCards_Get_Request, options ...Option) (resp PrettyCards_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.get", ctx, values, &resp)
	return
}

type PrettyCards_GetById_Request struct {
	OwnerId int
	//  MaxItems: 10
	CardIds *[]int
}

func (r PrettyCards_GetById_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.CardIds != nil {
		setInts(values, "card_ids", *r.CardIds)
	}
	return
}

// PrettyCards_GetById ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/prettyCards.getById
func (vk *VK) PrettyCards_GetById(ctx context.Context, req PrettyCards_GetById_Request, options ...Option) (resp PrettyCards_GetById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.getById", ctx, values, &resp)
	return
}

// PrettyCards_GetUploadURL ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/prettyCards.getUploadURL
func (vk *VK) PrettyCards_GetUploadURL(ctx context.Context, options ...Option) (resp PrettyCards_GetUploadURL_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("prettyCards.getUploadURL", ctx, values, &resp)
	return
}

type Search_GetHints_Request struct {
	// Search query string.
	//  MaxLength: 9000
	Q *string
	// Offset for querying specific result subset
	//  Minimum: 0
	//  Maximum: 200
	Offset *int
	// Maximum number of results to return.
	//  Default: 9
	//  Minimum: 0
	//  Maximum: 200
	Limit   *int
	Filters *[]string
	Fields  *[]string
	//  Default: 1
	SearchGlobal *bool
}

func (r Search_GetHints_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	if r.Filters != nil {
		setStrings(values, "filters", *r.Filters)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	if r.SearchGlobal != nil {
		setBool(values, "search_global", *r.SearchGlobal)
	}
	return
}

// Search_GetHints Allows the programmer to do a quick search for any substring.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/search.getHints
func (vk *VK) Search_GetHints(ctx context.Context, req Search_GetHints_Request, options ...Option) (resp Search_GetHints_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("search.getHints", ctx, values, &resp)
	return
}

type Secure_AddAppEvent_Request struct {
	// ID of a user to save the data
	//  Format: int64
	//  Minimum: 1
	UserId int
	// there are 2 default activities: , * 1 - level. Works similar to ,, * 2 - points, saves points amount, Any other value is for saving completed missions
	//  Minimum: 0
	ActivityId int
	// depends on activity_id: * 1 - number, current level number,, * 2 - number, current user's points amount, , Any other value is ignored
	//  Minimum: 0
	Value *int
}

func (r Secure_AddAppEvent_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setInt(values, "activity_id", r.ActivityId)
	if r.Value != nil {
		setInt(values, "value", *r.Value)
	}
	return
}

// Secure_AddAppEvent Adds user activity information to an application
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AppsAlreadyUnlocked ]
//
// https://dev.vk.com/method/secure.addAppEvent
func (vk *VK) Secure_AddAppEvent(ctx context.Context, req Secure_AddAppEvent_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.addAppEvent", ctx, values, &resp)
	return
}

type Secure_CheckToken_Request struct {
	// client 'access_token'
	Token *string
	// user 'ip address'. Note that user may access using the 'ipv6' address, in this case it is required to transmit the 'ipv6' address. If not transmitted, the address will not be checked.
	Ip *string
}

func (r Secure_CheckToken_Request) fillIn(values url.Values) (err error) {
	if r.Token != nil {
		setString(values, "token", *r.Token)
	}
	if r.Ip != nil {
		setString(values, "ip", *r.Ip)
	}
	return
}

// Secure_CheckToken Checks the user authentication in 'IFrame' and 'Flash' apps using the 'access_token' parameter.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.checkToken
func (vk *VK) Secure_CheckToken(ctx context.Context, req Secure_CheckToken_Request, options ...Option) (resp Secure_CheckToken_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.checkToken", ctx, values, &resp)
	return
}

// Secure_GetAppBalance Returns payment balance of the application in hundredth of a vote.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.getAppBalance
func (vk *VK) Secure_GetAppBalance(ctx context.Context, options ...Option) (resp Secure_GetAppBalance_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.getAppBalance", ctx, values, &resp)
	return
}

type Secure_GetSMSHistory_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// filter by start date. It is set as UNIX-time.
	//  Minimum: 0
	DateFrom *int
	// filter by end date. It is set as UNIX-time.
	//  Minimum: 0
	DateTo *int
	// number of returned posts. By default — 1000.
	//  Default: 1000
	//  Minimum: 0
	//  Maximum: 1000
	Limit *int
}

func (r Secure_GetSMSHistory_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.DateFrom != nil {
		setInt(values, "date_from", *r.DateFrom)
	}
	if r.DateTo != nil {
		setInt(values, "date_to", *r.DateTo)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	return
}

// Secure_GetSMSHistory Shows a list of SMS notifications sent by the application using [vk.com/dev/secure.sendSMSNotification|secure.sendSMSNotification] method.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.getSMSHistory
func (vk *VK) Secure_GetSMSHistory(ctx context.Context, req Secure_GetSMSHistory_Request, options ...Option) (resp Secure_GetSMSHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.getSMSHistory", ctx, values, &resp)
	return
}

type Secure_GetTransactionsHistory_Request struct {
	Type *int
	//  Format: int64
	//  Minimum: 1
	UidFrom *int
	//  Format: int64
	//  Minimum: 1
	UidTo *int
	//  Minimum: 0
	DateFrom *int
	//  Minimum: 0
	DateTo *int
	//  Default: 1000
	//  Minimum: 0
	//  Maximum: 1000
	Limit *int
}

func (r Secure_GetTransactionsHistory_Request) fillIn(values url.Values) (err error) {
	if r.Type != nil {
		setInt(values, "type", *r.Type)
	}
	if r.UidFrom != nil {
		setInt(values, "uid_from", *r.UidFrom)
	}
	if r.UidTo != nil {
		setInt(values, "uid_to", *r.UidTo)
	}
	if r.DateFrom != nil {
		setInt(values, "date_from", *r.DateFrom)
	}
	if r.DateTo != nil {
		setInt(values, "date_to", *r.DateTo)
	}
	if r.Limit != nil {
		setInt(values, "limit", *r.Limit)
	}
	return
}

// Secure_GetTransactionsHistory Shows history of votes transaction between users and the application.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.getTransactionsHistory
func (vk *VK) Secure_GetTransactionsHistory(ctx context.Context, req Secure_GetTransactionsHistory_Request, options ...Option) (resp Secure_GetTransactionsHistory_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.getTransactionsHistory", ctx, values, &resp)
	return
}

type Secure_GetUserLevel_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserIds *[]int
}

func (r Secure_GetUserLevel_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	return
}

// Secure_GetUserLevel Returns one of the previously set game levels of one or more users in the application.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.getUserLevel
func (vk *VK) Secure_GetUserLevel(ctx context.Context, req Secure_GetUserLevel_Request, options ...Option) (resp Secure_GetUserLevel_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.getUserLevel", ctx, values, &resp)
	return
}

type Secure_GiveEventSticker_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserIds *[]int
	//  Minimum: 0
	AchievementId int
}

func (r Secure_GiveEventSticker_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	setInt(values, "achievement_id", r.AchievementId)
	return
}

// Secure_GiveEventSticker Opens the game achievement and gives the user a sticker
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.giveEventSticker
func (vk *VK) Secure_GiveEventSticker(ctx context.Context, req Secure_GiveEventSticker_Request, options ...Option) (resp Secure_GiveEventSticker_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.giveEventSticker", ctx, values, &resp)
	return
}

type Secure_SendNotification_Request struct {
	//  Format: int64
	//  Minimum: 1
	UserIds *[]int
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// notification text which should be sent in 'UTF-8' encoding ('254' characters maximum).
	Message string
}

func (r Secure_SendNotification_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	setString(values, "message", r.Message)
	return
}

// Secure_SendNotification Sends notification to the user.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.sendNotification
func (vk *VK) Secure_SendNotification(ctx context.Context, req Secure_SendNotification_Request, options ...Option) (resp Secure_SendNotification_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.sendNotification", ctx, values, &resp)
	return
}

type Secure_SendSMSNotification_Request struct {
	// ID of the user to whom SMS notification is sent. The user shall allow the application to send him/her notifications (, +1).
	//  Format: int64
	//  Minimum: 1
	UserId int
	// 'SMS' text to be sent in 'UTF-8' encoding. Only Latin letters and numbers are allowed. Maximum size is '160' characters.
	Message string
}

func (r Secure_SendSMSNotification_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setString(values, "message", r.Message)
	return
}

// Secure_SendSMSNotification Sends 'SMS' notification to a user's mobile device.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_InsufficientFunds, Error_MobileNotActivated ]
//
// https://dev.vk.com/method/secure.sendSMSNotification
func (vk *VK) Secure_SendSMSNotification(ctx context.Context, req Secure_SendSMSNotification_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.sendSMSNotification", ctx, values, &resp)
	return
}

type Secure_SetCounter_Request struct {
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// counter value.
	Counter   *int
	Increment *bool
}

func (r Secure_SetCounter_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Counter != nil {
		setInt(values, "counter", *r.Counter)
	}
	if r.Increment != nil {
		setBool(values, "increment", *r.Increment)
	}
	return
}

// Secure_SetCounter Sets a counter which is shown to the user in bold in the left menu.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.setCounter
func (vk *VK) Secure_SetCounter(ctx context.Context, req Secure_SetCounter_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.setCounter", ctx, values, &resp)
	return
}

type Secure_SetCounterCounters_Request struct {
	Counters *[]string
}

func (r Secure_SetCounterCounters_Request) fillIn(values url.Values) (err error) {
	if r.Counters != nil {
		setStrings(values, "counters", *r.Counters)
	}
	return
}

// Secure_SetCounterCounters Sets a counter which is shown to the user in bold in the left menu.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.setCounter
func (vk *VK) Secure_SetCounterCounters(ctx context.Context, req Secure_SetCounterCounters_Request, options ...Option) (resp Secure_SetCounterArray_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("secure.setCounter", ctx, values, &resp)
	return
}

type Secure_SetCounterNotSecure_Request struct {
	// counter value.
	Counter   *int
	Increment *bool
}

func (r Secure_SetCounterNotSecure_Request) fillIn(values url.Values) (err error) {
	if r.Counter != nil {
		setInt(values, "counter", *r.Counter)
	}
	if r.Increment != nil {
		setBool(values, "increment", *r.Increment)
	}
	return
}

// Secure_SetCounterNotSecure Sets a counter which is shown to the user in bold in the left menu.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/secure.setCounter
func (vk *VK) Secure_SetCounterNotSecure(ctx context.Context, req Secure_SetCounterNotSecure_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("setCounter", ctx, values, &resp)
	return
}

type Stats_Get_Interval string

const (
	Stats_Get_Interval_All   Stats_Get_Interval = "all"
	Stats_Get_Interval_Day   Stats_Get_Interval = "day"
	Stats_Get_Interval_Month Stats_Get_Interval = "month"
	Stats_Get_Interval_Week  Stats_Get_Interval = "week"
	Stats_Get_Interval_Year  Stats_Get_Interval = "year"
)

type Stats_Get_Request struct {
	// Community ID.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Application ID.
	//  Minimum: 0
	AppId *int
	//  Minimum: 0
	TimestampFrom *int
	//  Minimum: 0
	TimestampTo *int
	//  Default: day
	Interval *Stats_Get_Interval
	//  Minimum: 0
	IntervalsCount *int
	Filters        *[]string
	StatsGroups    *[]string
	//  Default: true
	Extended *bool
}

func (r Stats_Get_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.AppId != nil {
		setInt(values, "app_id", *r.AppId)
	}
	if r.TimestampFrom != nil {
		setInt(values, "timestamp_from", *r.TimestampFrom)
	}
	if r.TimestampTo != nil {
		setInt(values, "timestamp_to", *r.TimestampTo)
	}
	if r.Interval != nil {
		setString(values, "interval", string(*r.Interval))
	}
	if r.IntervalsCount != nil {
		setInt(values, "intervals_count", *r.IntervalsCount)
	}
	if r.Filters != nil {
		setStrings(values, "filters", *r.Filters)
	}
	if r.StatsGroups != nil {
		setStrings(values, "stats_groups", *r.StatsGroups)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Stats_Get Returns statistics of a community or an application.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stats.get
func (vk *VK) Stats_Get(ctx context.Context, req Stats_Get_Request, options ...Option) (resp Stats_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stats.get", ctx, values, &resp)
	return
}

type Stats_GetPostReach_Request struct {
	// post owner community id. Specify with "-" sign.
	OwnerId string
	//  MaxItems: 30
	//  Minimum: 0
	PostIds *[]int
}

func (r Stats_GetPostReach_Request) fillIn(values url.Values) (err error) {
	setString(values, "owner_id", r.OwnerId)
	if r.PostIds != nil {
		setInts(values, "post_ids", *r.PostIds)
	}
	return
}

// Stats_GetPostReach Returns stats for a wall post.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessPost ]
//
// https://dev.vk.com/method/stats.getPostReach
func (vk *VK) Stats_GetPostReach(ctx context.Context, req Stats_GetPostReach_Request, options ...Option) (resp Stats_GetPostReach_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stats.getPostReach", ctx, values, &resp)
	return
}

// Stats_TrackVisitor ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stats.trackVisitor
func (vk *VK) Stats_TrackVisitor(ctx context.Context, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("stats.trackVisitor", ctx, values, &resp)
	return
}

type Status_Get_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	UserId *int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Status_Get_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Status_Get Returns data required to show the status of a user or community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/status.get
func (vk *VK) Status_Get(ctx context.Context, req Status_Get_Request, options ...Option) (resp Status_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("status.get", ctx, values, &resp)
	return
}

type Status_Set_Request struct {
	// Text of the new status.
	Text *string
	// Identifier of a community to set a status in. If left blank the status is set to current user.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Status_Set_Request) fillIn(values url.Values) (err error) {
	if r.Text != nil {
		setString(values, "text", *r.Text)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Status_Set Sets a new status for the current user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StatusNoAudio ]
//
// https://dev.vk.com/method/status.set
func (vk *VK) Status_Set(ctx context.Context, req Status_Set_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("status.set", ctx, values, &resp)
	return
}

type Storage_Get_Request struct {
	//  MaxLength: 100
	Key *string
	//  MaxItems: 1000
	Keys *[]string
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Storage_Get_Request) fillIn(values url.Values) (err error) {
	if r.Key != nil {
		setString(values, "key", *r.Key)
	}
	if r.Keys != nil {
		setStrings(values, "keys", *r.Keys)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Storage_Get Returns a value of variable with the name set by key parameter.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/storage.get
func (vk *VK) Storage_Get(ctx context.Context, req Storage_Get_Request, options ...Option) (resp Storage_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("storage.get", ctx, values, &resp)
	return
}

type Storage_GetKeys_Request struct {
	// user id, whose variables names are returned if they were requested with a server method.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	//  Default: 0
	//  Minimum: 0
	Offset *int
	// amount of variable names the info needs to be collected from.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Storage_GetKeys_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Storage_GetKeys Returns the names of all variables.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/storage.getKeys
func (vk *VK) Storage_GetKeys(ctx context.Context, req Storage_GetKeys_Request, options ...Option) (resp Storage_GetKeys_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("storage.getKeys", ctx, values, &resp)
	return
}

type Storage_Set_Request struct {
	//  MaxLength: 100
	Key   string
	Value *string
	//  Format: int64
	//  Minimum: 0
	UserId *int
}

func (r Storage_Set_Request) fillIn(values url.Values) (err error) {
	setString(values, "key", r.Key)
	if r.Value != nil {
		setString(values, "value", *r.Value)
	}
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	return
}

// Storage_Set Saves a value of variable with the name set by 'key' parameter.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Limits ]
//
// https://dev.vk.com/method/storage.set
func (vk *VK) Storage_Set(ctx context.Context, req Storage_Set_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("storage.set", ctx, values, &resp)
	return
}

type Store_AddStickersToFavorite_Request struct {
	//  Minimum: 0
	StickerIds *[]int
}

func (r Store_AddStickersToFavorite_Request) fillIn(values url.Values) (err error) {
	if r.StickerIds != nil {
		setInts(values, "sticker_ids", *r.StickerIds)
	}
	return
}

// Store_AddStickersToFavorite Adds given sticker IDs to the list of user's favorite stickers
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StickersNotPurchased, Error_StickersTooManyFavorites ]
//
// https://dev.vk.com/method/store.addStickersToFavorite
func (vk *VK) Store_AddStickersToFavorite(ctx context.Context, req Store_AddStickersToFavorite_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("store.addStickersToFavorite", ctx, values, &resp)
	return
}

// Store_GetFavoriteStickers ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/store.getFavoriteStickers
func (vk *VK) Store_GetFavoriteStickers(ctx context.Context, options ...Option) (resp Store_GetFavoriteStickers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("store.getFavoriteStickers", ctx, values, &resp)
	return
}

type Store_GetProducts_Request struct {
	Type     *string
	Merchant *string
	Section  *string
	//  Minimum: 0
	ProductIds *[]int
	Filters    *[]string
	//  Default: 0
	Extended *bool
}

func (r Store_GetProducts_Request) fillIn(values url.Values) (err error) {
	if r.Type != nil {
		setString(values, "type", *r.Type)
	}
	if r.Merchant != nil {
		setString(values, "merchant", *r.Merchant)
	}
	if r.Section != nil {
		setString(values, "section", *r.Section)
	}
	if r.ProductIds != nil {
		setInts(values, "product_ids", *r.ProductIds)
	}
	if r.Filters != nil {
		setStrings(values, "filters", *r.Filters)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	return
}

// Store_GetProducts ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/store.getProducts
func (vk *VK) Store_GetProducts(ctx context.Context, req Store_GetProducts_Request, options ...Option) (resp Store_GetProducts_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("store.getProducts", ctx, values, &resp)
	return
}

type Store_GetStickersKeywords_Request struct {
	//  Minimum: 0
	StickersIds *[]int
	//  Minimum: 0
	ProductsIds *[]int
	//  Default: true
	Aliases     *bool
	AllProducts *bool
	//  Default: true
	NeedStickers *bool
}

func (r Store_GetStickersKeywords_Request) fillIn(values url.Values) (err error) {
	if r.StickersIds != nil {
		setInts(values, "stickers_ids", *r.StickersIds)
	}
	if r.ProductsIds != nil {
		setInts(values, "products_ids", *r.ProductsIds)
	}
	if r.Aliases != nil {
		setBool(values, "aliases", *r.Aliases)
	}
	if r.AllProducts != nil {
		setBool(values, "all_products", *r.AllProducts)
	}
	if r.NeedStickers != nil {
		setBool(values, "need_stickers", *r.NeedStickers)
	}
	return
}

// Store_GetStickersKeywords ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/store.getStickersKeywords
func (vk *VK) Store_GetStickersKeywords(ctx context.Context, req Store_GetStickersKeywords_Request, options ...Option) (resp Store_GetStickersKeywords_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("store.getStickersKeywords", ctx, values, &resp)
	return
}

type Store_RemoveStickersFromFavorite_Request struct {
	//  Minimum: 0
	StickerIds *[]int
}

func (r Store_RemoveStickersFromFavorite_Request) fillIn(values url.Values) (err error) {
	if r.StickerIds != nil {
		setInts(values, "sticker_ids", *r.StickerIds)
	}
	return
}

// Store_RemoveStickersFromFavorite Removes given sticker IDs from the list of user's favorite stickers
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StickersNotFavorite ]
//
// https://dev.vk.com/method/store.removeStickersFromFavorite
func (vk *VK) Store_RemoveStickersFromFavorite(ctx context.Context, req Store_RemoveStickersFromFavorite_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("store.removeStickersFromFavorite", ctx, values, &resp)
	return
}

type Stories_BanOwner_Request struct {
	//  Format: int64
	//  MaxItems: 200
	OwnersIds *[]int
}

func (r Stories_BanOwner_Request) fillIn(values url.Values) (err error) {
	if r.OwnersIds != nil {
		setInts(values, "owners_ids", *r.OwnersIds)
	}
	return
}

// Stories_BanOwner Allows to hide stories from chosen sources from current user's feed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.banOwner
func (vk *VK) Stories_BanOwner(ctx context.Context, req Stories_BanOwner_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.banOwner", ctx, values, &resp)
	return
}

type Stories_Delete_Request struct {
	// Story owner's ID. Current user id is used by default.
	//  Format: int64
	OwnerId *int
	// Story ID.
	//  Minimum: 0
	StoryId *int
	//  MaxItems: 100
	Stories *[]string
}

func (r Stories_Delete_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.StoryId != nil {
		setInt(values, "story_id", *r.StoryId)
	}
	if r.Stories != nil {
		setStrings(values, "stories", *r.Stories)
	}
	return
}

// Stories_Delete Allows to delete story.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.delete
func (vk *VK) Stories_Delete(ctx context.Context, req Stories_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.delete", ctx, values, &resp)
	return
}

type Stories_Get_Request struct {
	// Owner ID.
	//  Format: int64
	OwnerId *int
	// '1' — to return additional fields for users and communities. Default value is 0.
	//  Default: false
	Extended *bool
	Fields   *[]Base_UserGroupFields
}

func (r Stories_Get_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_Get Returns stories available for current user.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.get
func (vk *VK) Stories_Get(ctx context.Context, req Stories_Get_Request, options ...Option) (resp Stories_GetV5113_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.get", ctx, values, &resp)
	return
}

type Stories_GetBanned_Request struct {
	Fields *[]Base_UserGroupFields
}

func (r Stories_GetBanned_Request) fillIn(values url.Values) (err error) {
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_GetBanned Returns list of sources hidden from current user's feed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.getBanned
func (vk *VK) Stories_GetBanned(ctx context.Context, req Stories_GetBanned_Request, options ...Option) (resp Stories_GetBanned_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getBanned", ctx, values, &resp)
	return
}

// Stories_GetBannedExtended Returns list of sources hidden from current user's feed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.getBanned
func (vk *VK) Stories_GetBannedExtended(ctx context.Context, req Stories_GetBanned_Request, options ...Option) (resp Stories_GetBannedExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getBanned", ctx, values, &resp)
	return
}

type Stories_GetById_Request struct {
	//  MaxItems: 100
	Stories *[]string
	// '1' — to return additional fields for users and communities. Default value is 0.
	//  Default: false
	Extended *bool
	Fields   *[]Base_UserGroupFields
}

func (r Stories_GetById_Request) fillIn(values url.Values) (err error) {
	if r.Stories != nil {
		setStrings(values, "stories", *r.Stories)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_GetById Returns story by its ID.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StoryExpired ]
//
// https://dev.vk.com/method/stories.getById
func (vk *VK) Stories_GetById(ctx context.Context, req Stories_GetById_Request, options ...Option) (resp Stories_GetByIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getById", ctx, values, &resp)
	return
}

type Stories_GetPhotoUploadServer_Request struct {
	// 1 — to add the story to friend's feed.
	AddToNews *bool
	//  Minimum: 0
	UserIds *[]int
	// ID of the story to reply with the current.
	ReplyToStory *string
	// Link text (for community's stories only).
	LinkText *Stories_UploadLinkText
	// Link URL. Internal links on https://vk.com only.
	//  MaxLength: 2048
	LinkUrl *string
	// ID of the community to upload the story (should be verified or with the "fire" icon).
	//  Format: int64
	//  Minimum: 0
	GroupId           *int
	ClickableStickers *string
}

func (r Stories_GetPhotoUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.AddToNews != nil {
		setBool(values, "add_to_news", *r.AddToNews)
	}
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.ReplyToStory != nil {
		setString(values, "reply_to_story", *r.ReplyToStory)
	}
	if r.LinkText != nil {
		setString(values, "link_text", string(*r.LinkText))
	}
	if r.LinkUrl != nil {
		setString(values, "link_url", *r.LinkUrl)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.ClickableStickers != nil {
		setString(values, "clickable_stickers", *r.ClickableStickers)
	}
	return
}

// Stories_GetPhotoUploadServer Returns URL for uploading a story with photo.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesUserBlocked, Error_StoryIncorrectReplyPrivacy, Error_Blocked ]
//
// https://dev.vk.com/method/stories.getPhotoUploadServer
func (vk *VK) Stories_GetPhotoUploadServer(ctx context.Context, req Stories_GetPhotoUploadServer_Request, options ...Option) (resp Stories_GetPhotoUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getPhotoUploadServer", ctx, values, &resp)
	return
}

type Stories_GetReplies_Request struct {
	// Story owner ID.
	//  Format: int64
	OwnerId int
	// Story ID.
	//  Minimum: 0
	StoryId int
	// Access key for the private object.
	AccessKey *string
	// '1' — to return additional fields for users and communities. Default value is 0.
	//  Default: false
	Extended *bool
	Fields   *[]Base_UserGroupFields
}

func (r Stories_GetReplies_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "story_id", r.StoryId)
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_GetReplies Returns replies to the story.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.getReplies
func (vk *VK) Stories_GetReplies(ctx context.Context, req Stories_GetReplies_Request, options ...Option) (resp Stories_GetV5113_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getReplies", ctx, values, &resp)
	return
}

type Stories_GetStats_Request struct {
	// Story owner ID.
	//  Format: int64
	OwnerId int
	// Story ID.
	//  Minimum: 0
	StoryId int
}

func (r Stories_GetStats_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "story_id", r.StoryId)
	return
}

// Stories_GetStats Returns stories available for current user.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.getStats
func (vk *VK) Stories_GetStats(ctx context.Context, req Stories_GetStats_Request, options ...Option) (resp Stories_GetStats_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getStats", ctx, values, &resp)
	return
}

type Stories_GetVideoUploadServer_Request struct {
	// 1 — to add the story to friend's feed.
	AddToNews *bool
	//  Minimum: 0
	UserIds *[]int
	// ID of the story to reply with the current.
	ReplyToStory *string
	// Link text (for community's stories only).
	LinkText *Stories_UploadLinkText
	// Link URL. Internal links on https://vk.com only.
	//  MaxLength: 2048
	LinkUrl *string
	// ID of the community to upload the story (should be verified or with the "fire" icon).
	//  Format: int64
	//  Minimum: 0
	GroupId           *int
	ClickableStickers *string
}

func (r Stories_GetVideoUploadServer_Request) fillIn(values url.Values) (err error) {
	if r.AddToNews != nil {
		setBool(values, "add_to_news", *r.AddToNews)
	}
	if r.UserIds != nil {
		setInts(values, "user_ids", *r.UserIds)
	}
	if r.ReplyToStory != nil {
		setString(values, "reply_to_story", *r.ReplyToStory)
	}
	if r.LinkText != nil {
		setString(values, "link_text", string(*r.LinkText))
	}
	if r.LinkUrl != nil {
		setString(values, "link_url", *r.LinkUrl)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.ClickableStickers != nil {
		setString(values, "clickable_stickers", *r.ClickableStickers)
	}
	return
}

// Stories_GetVideoUploadServer Allows to receive URL for uploading story with video.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_MessagesUserBlocked, Error_StoryIncorrectReplyPrivacy, Error_Blocked ]
//
// https://dev.vk.com/method/stories.getVideoUploadServer
func (vk *VK) Stories_GetVideoUploadServer(ctx context.Context, req Stories_GetVideoUploadServer_Request, options ...Option) (resp Stories_GetVideoUploadServer_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getVideoUploadServer", ctx, values, &resp)
	return
}

type Stories_GetViewers_Request struct {
	// Story owner ID.
	//  Format: int64
	OwnerId int
	// Story ID.
	//  Minimum: 0
	StoryId int
	// Maximum number of results.
	//  Default: 100
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of results.
	//  Default: 0
	//  Minimum: 0
	Offset *int
	Fields *[]Base_UserGroupFields
}

func (r Stories_GetViewers_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "story_id", r.StoryId)
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_GetViewers Returns a list of story viewers.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StoryExpired ]
//
// https://dev.vk.com/method/stories.getViewers
func (vk *VK) Stories_GetViewers(ctx context.Context, req Stories_GetViewers_Request, options ...Option) (resp Stories_GetViewersExtendedV5115_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getViewers", ctx, values, &resp)
	return
}

// Stories_GetViewersExtended Returns a list of story viewers.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_StoryExpired ]
//
// https://dev.vk.com/method/stories.getViewers
func (vk *VK) Stories_GetViewersExtended(ctx context.Context, req Stories_GetViewers_Request, options ...Option) (resp Stories_GetViewersExtendedV5115_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.getViewers", ctx, values, &resp)
	return
}

type Stories_HideAllReplies_Request struct {
	// ID of the user whose replies should be hidden.
	//  Format: int64
	OwnerId int
	//  Format: int64
	//  Minimum: 0
	GroupId *int
}

func (r Stories_HideAllReplies_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	return
}

// Stories_HideAllReplies Hides all replies in the last 24 hours from the user to current user's stories.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.hideAllReplies
func (vk *VK) Stories_HideAllReplies(ctx context.Context, req Stories_HideAllReplies_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.hideAllReplies", ctx, values, &resp)
	return
}

type Stories_HideReply_Request struct {
	// ID of the user whose replies should be hidden.
	//  Format: int64
	OwnerId int
	// Story ID.
	//  Minimum: 0
	StoryId int
}

func (r Stories_HideReply_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "story_id", r.StoryId)
	return
}

// Stories_HideReply Hides the reply to the current user's story.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.hideReply
func (vk *VK) Stories_HideReply(ctx context.Context, req Stories_HideReply_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.hideReply", ctx, values, &resp)
	return
}

type Stories_Save_Request struct {
	UploadResults *[]string
	Extended      *bool
	Fields        *[]Base_UserGroupFields
}

func (r Stories_Save_Request) fillIn(values url.Values) (err error) {
	if r.UploadResults != nil {
		setStrings(values, "upload_results", *r.UploadResults)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_Save ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.save
func (vk *VK) Stories_Save(ctx context.Context, req Stories_Save_Request, options ...Option) (resp Stories_Save_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.save", ctx, values, &resp)
	return
}

type Stories_Search_Request struct {
	//  MaxLength: 255
	Q *string
	//  Minimum: 0
	PlaceId   *int
	Latitude  *float64
	Longitude *float64
	//  Minimum: 0
	Radius      *int
	MentionedId *int
	//  Default: 20
	//  Minimum: 1
	//  Maximum: 1000
	Count    *int
	Extended *bool
	Fields   *[]Base_UserGroupFields
}

func (r Stories_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.PlaceId != nil {
		setInt(values, "place_id", *r.PlaceId)
	}
	if r.Latitude != nil {
		setFloat(values, "latitude", *r.Latitude)
	}
	if r.Longitude != nil {
		setFloat(values, "longitude", *r.Longitude)
	}
	if r.Radius != nil {
		setInt(values, "radius", *r.Radius)
	}
	if r.MentionedId != nil {
		setInt(values, "mentioned_id", *r.MentionedId)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Stories_Search ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.search
func (vk *VK) Stories_Search(ctx context.Context, req Stories_Search_Request, options ...Option) (resp Stories_GetV5113_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.search", ctx, values, &resp)
	return
}

type Stories_SendInteraction_Request struct {
	AccessKey string
	//  MaxLength: 1000
	Message *string
	//  Default: false
	IsBroadcast *bool
	//  Default: false
	IsAnonymous *bool
	//  Default: false
	UnseenMarker *bool
}

func (r Stories_SendInteraction_Request) fillIn(values url.Values) (err error) {
	setString(values, "access_key", r.AccessKey)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.IsBroadcast != nil {
		setBool(values, "is_broadcast", *r.IsBroadcast)
	}
	if r.IsAnonymous != nil {
		setBool(values, "is_anonymous", *r.IsAnonymous)
	}
	if r.UnseenMarker != nil {
		setBool(values, "unseen_marker", *r.UnseenMarker)
	}
	return
}

// Stories_SendInteraction ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.sendInteraction
func (vk *VK) Stories_SendInteraction(ctx context.Context, req Stories_SendInteraction_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.sendInteraction", ctx, values, &resp)
	return
}

type Stories_UnbanOwner_Request struct {
	//  Format: int64
	//  MaxItems: 200
	OwnersIds *[]int
}

func (r Stories_UnbanOwner_Request) fillIn(values url.Values) (err error) {
	if r.OwnersIds != nil {
		setInts(values, "owners_ids", *r.OwnersIds)
	}
	return
}

// Stories_UnbanOwner Allows to show stories from hidden sources in current user's feed.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/stories.unbanOwner
func (vk *VK) Stories_UnbanOwner(ctx context.Context, req Stories_UnbanOwner_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("stories.unbanOwner", ctx, values, &resp)
	return
}

// Streaming_GetServerUrl Allows to receive data for the connection to Streaming API.
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/streaming.getServerUrl
func (vk *VK) Streaming_GetServerUrl(ctx context.Context, options ...Option) (resp Streaming_GetServerUrl_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("streaming.getServerUrl", ctx, values, &resp)
	return
}

type Streaming_SetSettings_MonthlyTier string

const (
	Streaming_SetSettings_MonthlyTier_Tier1     Streaming_SetSettings_MonthlyTier = "tier_1"
	Streaming_SetSettings_MonthlyTier_Tier2     Streaming_SetSettings_MonthlyTier = "tier_2"
	Streaming_SetSettings_MonthlyTier_Tier3     Streaming_SetSettings_MonthlyTier = "tier_3"
	Streaming_SetSettings_MonthlyTier_Tier4     Streaming_SetSettings_MonthlyTier = "tier_4"
	Streaming_SetSettings_MonthlyTier_Tier5     Streaming_SetSettings_MonthlyTier = "tier_5"
	Streaming_SetSettings_MonthlyTier_Tier6     Streaming_SetSettings_MonthlyTier = "tier_6"
	Streaming_SetSettings_MonthlyTier_Unlimited Streaming_SetSettings_MonthlyTier = "unlimited"
)

type Streaming_SetSettings_Request struct {
	MonthlyTier *Streaming_SetSettings_MonthlyTier
}

func (r Streaming_SetSettings_Request) fillIn(values url.Values) (err error) {
	if r.MonthlyTier != nil {
		setString(values, "monthly_tier", string(*r.MonthlyTier))
	}
	return
}

// Streaming_SetSettings ...
// May execute with listed access token types:
//    [ service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/streaming.setSettings
func (vk *VK) Streaming_SetSettings(ctx context.Context, req Streaming_SetSettings_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("streaming.setSettings", ctx, values, &resp)
	return
}

type Users_Get_NameCase string

const (
	Users_Get_NameCase_Nominative    Users_Get_NameCase = "nom"
	Users_Get_NameCase_Genitive      Users_Get_NameCase = "gen"
	Users_Get_NameCase_Dative        Users_Get_NameCase = "dat"
	Users_Get_NameCase_Accusative    Users_Get_NameCase = "acc"
	Users_Get_NameCase_Instrumental  Users_Get_NameCase = "ins"
	Users_Get_NameCase_Prepositional Users_Get_NameCase = "abl"
)

type Users_Get_Request struct {
	//  Format: int64
	//  MaxItems: 1000
	UserIds *[]string
	Fields  *[]Users_Fields
	// Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Users_Get_NameCase
}

func (r Users_Get_Request) fillIn(values url.Values) (err error) {
	if r.UserIds != nil {
		setStrings(values, "user_ids", *r.UserIds)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Users_Get Returns detailed information on users.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.get
func (vk *VK) Users_Get(ctx context.Context, req Users_Get_Request, options ...Option) (resp Users_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("users.get", ctx, values, &resp)
	return
}

type Users_GetFollowers_NameCase string

const (
	Users_GetFollowers_NameCase_Nominative    Users_GetFollowers_NameCase = "nom"
	Users_GetFollowers_NameCase_Genitive      Users_GetFollowers_NameCase = "gen"
	Users_GetFollowers_NameCase_Dative        Users_GetFollowers_NameCase = "dat"
	Users_GetFollowers_NameCase_Accusative    Users_GetFollowers_NameCase = "acc"
	Users_GetFollowers_NameCase_Instrumental  Users_GetFollowers_NameCase = "ins"
	Users_GetFollowers_NameCase_Prepositional Users_GetFollowers_NameCase = "abl"
)

type Users_GetFollowers_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Offset needed to return a specific subset of followers.
	//  Minimum: 0
	Offset *int
	// Number of followers to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 1000
	Count  *int
	Fields *[]Users_Fields
	// Case for declension of user name and surname: 'nom' — nominative (default), 'gen' — genitive , 'dat' — dative, 'acc' — accusative , 'ins' — instrumental , 'abl' — prepositional
	NameCase *Users_GetFollowers_NameCase
}

func (r Users_GetFollowers_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.NameCase != nil {
		setString(values, "name_case", string(*r.NameCase))
	}
	return
}

// Users_GetFollowers Returns a list of IDs of followers of the user in question, sorted by date added, most recent first.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.getFollowers
func (vk *VK) Users_GetFollowers(ctx context.Context, req Users_GetFollowers_Request, options ...Option) (resp Users_GetFollowers_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("users.getFollowers", ctx, values, &resp)
	return
}

type Users_GetSubscriptions_Request struct {
	// User ID.
	//  Format: int64
	//  Minimum: 0
	UserId *int
	// Offset needed to return a specific subset of subscriptions.
	//  Minimum: 0
	Offset *int
	// Number of users and communities to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count  *int
	Fields *[]Users_Fields
}

func (r Users_GetSubscriptions_Request) fillIn(values url.Values) (err error) {
	if r.UserId != nil {
		setInt(values, "user_id", *r.UserId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Users_GetSubscriptions Returns a list of IDs of users and communities followed by the user.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.getSubscriptions
func (vk *VK) Users_GetSubscriptions(ctx context.Context, req Users_GetSubscriptions_Request, options ...Option) (resp Users_GetSubscriptions_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("users.getSubscriptions", ctx, values, &resp)
	return
}

// Users_GetSubscriptionsExtended Returns a list of IDs of users and communities followed by the user.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.getSubscriptions
func (vk *VK) Users_GetSubscriptionsExtended(ctx context.Context, req Users_GetSubscriptions_Request, options ...Option) (resp Users_GetSubscriptionsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("users.getSubscriptions", ctx, values, &resp)
	return
}

type Users_Report_Type string

const (
	Users_Report_Type_Porn          Users_Report_Type = "porn"
	Users_Report_Type_Spam          Users_Report_Type = "spam"
	Users_Report_Type_Insult        Users_Report_Type = "insult"
	Users_Report_Type_Advertisement Users_Report_Type = "advertisement"
)

type Users_Report_Request struct {
	// ID of the user about whom a complaint is being made.
	//  Format: int64
	//  Minimum: 1
	UserId int
	// Type of complaint: 'porn' - pornography, 'spam' - spamming, 'insult' - abusive behavior, 'advertisement' - disruptive advertisements
	Type Users_Report_Type
	// Comment describing the complaint.
	Comment *string
}

func (r Users_Report_Request) fillIn(values url.Values) (err error) {
	setInt(values, "user_id", r.UserId)
	setString(values, "type", string(r.Type))
	if r.Comment != nil {
		setString(values, "comment", *r.Comment)
	}
	return
}

// Users_Report Reports (submits a complain about) a user.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.report
func (vk *VK) Users_Report(ctx context.Context, req Users_Report_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("users.report", ctx, values, &resp)
	return
}

type Users_Search_Sort int

const (
	Users_Search_Sort_ByRating         Users_Search_Sort = 0
	Users_Search_Sort_ByDateRegistered Users_Search_Sort = 1
)

type Users_Search_Sex int

const (
	Users_Search_Sex_Any    Users_Search_Sex = 0
	Users_Search_Sex_Female Users_Search_Sex = 1
	Users_Search_Sex_Male   Users_Search_Sex = 2
)

type Users_Search_Status int

const (
	Users_Search_Status_NotSpecified      Users_Search_Status = 0
	Users_Search_Status_NotMarried        Users_Search_Status = 1
	Users_Search_Status_Relationship      Users_Search_Status = 2
	Users_Search_Status_Engaged           Users_Search_Status = 3
	Users_Search_Status_Married           Users_Search_Status = 4
	Users_Search_Status_Complicated       Users_Search_Status = 5
	Users_Search_Status_ActivelySearching Users_Search_Status = 6
	Users_Search_Status_InLove            Users_Search_Status = 7
)

type Users_Search_Request struct {
	// Search query string (e.g., 'Vasya Babich').
	Q *string
	// Sort order: '1' — by date registered, '0' — by rating
	Sort *Users_Search_Sort
	// Offset needed to return a specific subset of users.
	//  Minimum: 0
	Offset *int
	// Number of users to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count  *int
	Fields *[]Users_Fields
	// City ID.
	//  Minimum: 0
	City *int
	// Country ID.
	//  Minimum: 0
	Country *int
	// City name in a string.
	Hometown *string
	// ID of the country where the user graduated.
	//  Minimum: 0
	UniversityCountry *int
	// ID of the institution of higher education.
	//  Minimum: 0
	University *int
	// Year of graduation from an institution of higher education.
	//  Minimum: 0
	UniversityYear *int
	// Faculty ID.
	//  Minimum: 0
	UniversityFaculty *int
	// Chair ID.
	//  Minimum: 0
	UniversityChair *int
	// '1' — female, '2' — male, '0' — any (default)
	//  Minimum: 0
	Sex *Users_Search_Sex
	// Relationship status: '1' — Not married, '2' — In a relationship, '3' — Engaged, '4' — Married, '5' — It's complicated, '6' — Actively searching, '7' — In love
	//  Minimum: 0
	Status *Users_Search_Status
	// Minimum age.
	//  Minimum: 0
	AgeFrom *int
	// Maximum age.
	//  Minimum: 0
	AgeTo *int
	// Day of birth.
	//  Minimum: 0
	BirthDay *int
	// Month of birth.
	//  Minimum: 0
	BirthMonth *int
	// Year of birth.
	//  Minimum: 1900
	//  Maximum: 2100
	BirthYear *int
	// '1' — online only, '0' — all users
	Online *bool
	// '1' — with photo only, '0' — all users
	HasPhoto *bool
	// ID of the country where users finished school.
	//  Minimum: 0
	SchoolCountry *int
	// ID of the city where users finished school.
	//  Minimum: 0
	SchoolCity *int
	//  Minimum: 0
	SchoolClass *int
	// ID of the school.
	//  Minimum: 0
	School *int
	// School graduation year.
	//  Minimum: 0
	SchoolYear *int
	// Users' religious affiliation.
	Religion *string
	// Name of the company where users work.
	Company *string
	// Job position.
	Position *string
	// ID of a community to search in communities.
	//  Format: int64
	//  Minimum: 0
	GroupId  *int
	FromList *[]string
}

func (r Users_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.City != nil {
		setInt(values, "city", *r.City)
	}
	if r.Country != nil {
		setInt(values, "country", *r.Country)
	}
	if r.Hometown != nil {
		setString(values, "hometown", *r.Hometown)
	}
	if r.UniversityCountry != nil {
		setInt(values, "university_country", *r.UniversityCountry)
	}
	if r.University != nil {
		setInt(values, "university", *r.University)
	}
	if r.UniversityYear != nil {
		setInt(values, "university_year", *r.UniversityYear)
	}
	if r.UniversityFaculty != nil {
		setInt(values, "university_faculty", *r.UniversityFaculty)
	}
	if r.UniversityChair != nil {
		setInt(values, "university_chair", *r.UniversityChair)
	}
	if r.Sex != nil {
		setInt(values, "sex", int(*r.Sex))
	}
	if r.Status != nil {
		setInt(values, "status", int(*r.Status))
	}
	if r.AgeFrom != nil {
		setInt(values, "age_from", *r.AgeFrom)
	}
	if r.AgeTo != nil {
		setInt(values, "age_to", *r.AgeTo)
	}
	if r.BirthDay != nil {
		setInt(values, "birth_day", *r.BirthDay)
	}
	if r.BirthMonth != nil {
		setInt(values, "birth_month", *r.BirthMonth)
	}
	if r.BirthYear != nil {
		setInt(values, "birth_year", *r.BirthYear)
	}
	if r.Online != nil {
		setBool(values, "online", *r.Online)
	}
	if r.HasPhoto != nil {
		setBool(values, "has_photo", *r.HasPhoto)
	}
	if r.SchoolCountry != nil {
		setInt(values, "school_country", *r.SchoolCountry)
	}
	if r.SchoolCity != nil {
		setInt(values, "school_city", *r.SchoolCity)
	}
	if r.SchoolClass != nil {
		setInt(values, "school_class", *r.SchoolClass)
	}
	if r.School != nil {
		setInt(values, "school", *r.School)
	}
	if r.SchoolYear != nil {
		setInt(values, "school_year", *r.SchoolYear)
	}
	if r.Religion != nil {
		setString(values, "religion", *r.Religion)
	}
	if r.Company != nil {
		setString(values, "company", *r.Company)
	}
	if r.Position != nil {
		setString(values, "position", *r.Position)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.FromList != nil {
		setStrings(values, "from_list", *r.FromList)
	}
	return
}

// Users_Search Returns a list of users matching the search criteria.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/users.search
func (vk *VK) Users_Search(ctx context.Context, req Users_Search_Request, options ...Option) (resp Users_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 34+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("users.search", ctx, values, &resp)
	return
}

type Utils_CheckLink_Request struct {
	// Link to check (e.g., 'http://google.com').
	Url string
}

func (r Utils_CheckLink_Request) fillIn(values url.Values) (err error) {
	setString(values, "url", r.Url)
	return
}

// Utils_CheckLink Checks whether a link is blocked in VK.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.checkLink
func (vk *VK) Utils_CheckLink(ctx context.Context, req Utils_CheckLink_Request, options ...Option) (resp Utils_CheckLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.checkLink", ctx, values, &resp)
	return
}

type Utils_DeleteFromLastShortened_Request struct {
	// Link key (characters after vk.cc/).
	Key string
}

func (r Utils_DeleteFromLastShortened_Request) fillIn(values url.Values) (err error) {
	setString(values, "key", r.Key)
	return
}

// Utils_DeleteFromLastShortened Deletes shortened link from user's list.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.deleteFromLastShortened
func (vk *VK) Utils_DeleteFromLastShortened(ctx context.Context, req Utils_DeleteFromLastShortened_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.deleteFromLastShortened", ctx, values, &resp)
	return
}

type Utils_GetLastShortenedLinks_Request struct {
	// Number of links to return.
	//  Default: 10
	//  Minimum: 0
	Count *int
	// Offset needed to return a specific subset of links.
	//  Default: 0
	//  Minimum: 0
	Offset *int
}

func (r Utils_GetLastShortenedLinks_Request) fillIn(values url.Values) (err error) {
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	return
}

// Utils_GetLastShortenedLinks Returns a list of user's shortened links.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.getLastShortenedLinks
func (vk *VK) Utils_GetLastShortenedLinks(ctx context.Context, req Utils_GetLastShortenedLinks_Request, options ...Option) (resp Utils_GetLastShortenedLinks_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.getLastShortenedLinks", ctx, values, &resp)
	return
}

type Utils_GetLinkStats_Source string

const (
	Utils_GetLinkStats_Source_VkCc   Utils_GetLinkStats_Source = "vk_cc"
	Utils_GetLinkStats_Source_VkLink Utils_GetLinkStats_Source = "vk_link"
)

type Utils_GetLinkStats_Interval string

const (
	Utils_GetLinkStats_Interval_Day     Utils_GetLinkStats_Interval = "day"
	Utils_GetLinkStats_Interval_Forever Utils_GetLinkStats_Interval = "forever"
	Utils_GetLinkStats_Interval_Hour    Utils_GetLinkStats_Interval = "hour"
	Utils_GetLinkStats_Interval_Month   Utils_GetLinkStats_Interval = "month"
	Utils_GetLinkStats_Interval_Week    Utils_GetLinkStats_Interval = "week"
)

type Utils_GetLinkStats_Request struct {
	// Link key (characters after vk.cc/).
	Key string
	// Source of scope
	//  Default: vk_cc
	Source *Utils_GetLinkStats_Source
	// Access key for private link stats.
	AccessKey *string
	// Interval.
	//  Default: day
	Interval *Utils_GetLinkStats_Interval
	// Number of intervals to return.
	//  Default: 1
	//  Minimum: 0
	//  Maximum: 100
	IntervalsCount *int
}

func (r Utils_GetLinkStats_Request) fillIn(values url.Values) (err error) {
	setString(values, "key", r.Key)
	if r.Source != nil {
		setString(values, "source", string(*r.Source))
	}
	if r.AccessKey != nil {
		setString(values, "access_key", *r.AccessKey)
	}
	if r.Interval != nil {
		setString(values, "interval", string(*r.Interval))
	}
	if r.IntervalsCount != nil {
		setInt(values, "intervals_count", *r.IntervalsCount)
	}
	return
}

// Utils_GetLinkStats Returns stats data for shortened link.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/utils.getLinkStats
func (vk *VK) Utils_GetLinkStats(ctx context.Context, req Utils_GetLinkStats_Request, options ...Option) (resp Utils_GetLinkStats_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.getLinkStats", ctx, values, &resp)
	return
}

// Utils_GetLinkStatsExtended Returns stats data for shortened link.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_NotFound ]
//
// https://dev.vk.com/method/utils.getLinkStats
func (vk *VK) Utils_GetLinkStatsExtended(ctx context.Context, req Utils_GetLinkStats_Request, options ...Option) (resp Utils_GetLinkStatsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 8+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.getLinkStats", ctx, values, &resp)
	return
}

// Utils_GetServerTime Returns the current time of the VK server.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.getServerTime
func (vk *VK) Utils_GetServerTime(ctx context.Context, options ...Option) (resp Utils_GetServerTime_Response, apiErr ApiError, err error) {
	values := make(url.Values, 2+len(options))
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.getServerTime", ctx, values, &resp)
	return
}

type Utils_GetShortLink_Request struct {
	// URL to be shortened.
	Url string
	// 1 — private stats, 0 — public stats.
	//  Default: false
	Private *bool
}

func (r Utils_GetShortLink_Request) fillIn(values url.Values) (err error) {
	setString(values, "url", r.Url)
	if r.Private != nil {
		setBool(values, "private", *r.Private)
	}
	return
}

// Utils_GetShortLink Allows to receive a link shortened via vk.cc.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.getShortLink
func (vk *VK) Utils_GetShortLink(ctx context.Context, req Utils_GetShortLink_Request, options ...Option) (resp Utils_GetShortLink_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.getShortLink", ctx, values, &resp)
	return
}

type Utils_ResolveScreenName_Request struct {
	// Screen name of the user, community (e.g., 'apiclub,' 'andrew', or 'rules_of_war'), or application.
	ScreenName string
}

func (r Utils_ResolveScreenName_Request) fillIn(values url.Values) (err error) {
	setString(values, "screen_name", r.ScreenName)
	return
}

// Utils_ResolveScreenName Detects a type of object (e.g., user, community, application) and its ID by screen name.
// May execute with listed access token types:
//    [ user, group, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/utils.resolveScreenName
func (vk *VK) Utils_ResolveScreenName(ctx context.Context, req Utils_ResolveScreenName_Request, options ...Option) (resp Utils_ResolveScreenName_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("utils.resolveScreenName", ctx, values, &resp)
	return
}

type Video_Add_Request struct {
	// identifier of a user or community to add a video to. Use a negative value to designate a community ID.
	//  Format: int64
	TargetId *int
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// ID of the user or community that owns the video. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
}

func (r Video_Add_Request) fillIn(values url.Values) (err error) {
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	setInt(values, "video_id", r.VideoId)
	setInt(values, "owner_id", r.OwnerId)
	return
}

// Video_Add Adds a video to a user or community page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo, Error_VideoAlreadyAdded ]
//
// https://dev.vk.com/method/video.add
func (vk *VK) Video_Add(ctx context.Context, req Video_Add_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.add", ctx, values, &resp)
	return
}

type Video_AddAlbum_Privacy string

const (
	Video_AddAlbum_Privacy_All              Video_AddAlbum_Privacy = "0"
	Video_AddAlbum_Privacy_Friends          Video_AddAlbum_Privacy = "1"
	Video_AddAlbum_Privacy_FriendsOfFriends Video_AddAlbum_Privacy = "2"
	Video_AddAlbum_Privacy_OnlyMe           Video_AddAlbum_Privacy = "3"
)

type Video_AddAlbum_Request struct {
	// Community ID (if the album will be created in a community).
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Album title.
	Title   *string
	Privacy *[]Video_AddAlbum_Privacy
}

func (r Video_AddAlbum_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.Title != nil {
		setString(values, "title", *r.Title)
	}
	if r.Privacy != nil {
		vs := make([]string, len(*r.Privacy))
		for i, v := range *r.Privacy {
			vs[i] = string(v)
		}
		setStrings(values, "privacy", vs)
	}
	return
}

// Video_AddAlbum Creates an empty album for videos.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo, Error_AlbumsLimit ]
//
// https://dev.vk.com/method/video.addAlbum
func (vk *VK) Video_AddAlbum(ctx context.Context, req Video_AddAlbum_Request, options ...Option) (resp Video_AddAlbum_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.addAlbum", ctx, values, &resp)
	return
}

type Video_AddToAlbum_Request struct {
	//  Format: int64
	TargetId *int
	AlbumId  *int
	AlbumIds *[]int
	//  Format: int64
	OwnerId int
	//  Format: int32
	//  Minimum: 0
	VideoId int
}

func (r Video_AddToAlbum_Request) fillIn(values url.Values) (err error) {
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "video_id", r.VideoId)
	return
}

// Video_AddToAlbum ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo, Error_VideoAlreadyAdded ]
//
// https://dev.vk.com/method/video.addToAlbum
func (vk *VK) Video_AddToAlbum(ctx context.Context, req Video_AddToAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.addToAlbum", ctx, values, &resp)
	return
}

type Video_CreateComment_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// New comment text.
	Message     *string
	Attachments *[]string
	// '1' — to post the comment from a community name (only if 'owner_id'<0)
	FromGroup *bool
	//  Minimum: 0
	ReplyToComment *int
	//  Minimum: 0
	StickerId *int
	Guid      *string
}

func (r Video_CreateComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "video_id", r.VideoId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.ReplyToComment != nil {
		setInt(values, "reply_to_comment", *r.ReplyToComment)
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Video_CreateComment Adds a new comment on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_VideoCommentsClosed ]
//
// https://dev.vk.com/method/video.createComment
func (vk *VK) Video_CreateComment(ctx context.Context, req Video_CreateComment_Request, options ...Option) (resp Video_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.createComment", ctx, values, &resp)
	return
}

type Video_Delete_Request struct {
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	//  Format: int64
	TargetId *int
}

func (r Video_Delete_Request) fillIn(values url.Values) (err error) {
	setInt(values, "video_id", r.VideoId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	return
}

// Video_Delete Deletes a video from a user or community page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.delete
func (vk *VK) Video_Delete(ctx context.Context, req Video_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.delete", ctx, values, &resp)
	return
}

type Video_DeleteAlbum_Request struct {
	// Community ID (if the album is owned by a community).
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Album ID.
	//  Minimum: 0
	AlbumId int
}

func (r Video_DeleteAlbum_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	setInt(values, "album_id", r.AlbumId)
	return
}

// Video_DeleteAlbum Deletes a video album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.deleteAlbum
func (vk *VK) Video_DeleteAlbum(ctx context.Context, req Video_DeleteAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.deleteAlbum", ctx, values, &resp)
	return
}

type Video_DeleteComment_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// ID of the comment to be deleted.
	CommentId int
}

func (r Video_DeleteComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Video_DeleteComment Deletes a comment on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.deleteComment
func (vk *VK) Video_DeleteComment(ctx context.Context, req Video_DeleteComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.deleteComment", ctx, values, &resp)
	return
}

type Video_Edit_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// New video title.
	Name *string
	// New video description.
	Desc           *string
	PrivacyView    *[]string
	PrivacyComment *[]string
	// Disable comments for the group video.
	NoComments *bool
	// '1' — to repeat the playback of the video, '0' — to play the video once,
	Repeat *bool
}

func (r Video_Edit_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "video_id", r.VideoId)
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	if r.Desc != nil {
		setString(values, "desc", *r.Desc)
	}
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	if r.NoComments != nil {
		setBool(values, "no_comments", *r.NoComments)
	}
	if r.Repeat != nil {
		setBool(values, "repeat", *r.Repeat)
	}
	return
}

// Video_Edit Edits information about a video on a user or community page.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.edit
func (vk *VK) Video_Edit(ctx context.Context, req Video_Edit_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.edit", ctx, values, &resp)
	return
}

type Video_EditAlbum_Privacy string

const (
	Video_EditAlbum_Privacy_All              Video_EditAlbum_Privacy = "0"
	Video_EditAlbum_Privacy_Friends          Video_EditAlbum_Privacy = "1"
	Video_EditAlbum_Privacy_FriendsOfFriends Video_EditAlbum_Privacy = "2"
	Video_EditAlbum_Privacy_OnlyMe           Video_EditAlbum_Privacy = "3"
)

type Video_EditAlbum_Request struct {
	// Community ID (if the album edited is owned by a community).
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// Album ID.
	//  Minimum: 0
	AlbumId int
	// New album title.
	Title   string
	Privacy *[]Video_EditAlbum_Privacy
}

func (r Video_EditAlbum_Request) fillIn(values url.Values) (err error) {
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	setInt(values, "album_id", r.AlbumId)
	setString(values, "title", r.Title)
	if r.Privacy != nil {
		vs := make([]string, len(*r.Privacy))
		for i, v := range *r.Privacy {
			vs[i] = string(v)
		}
		setStrings(values, "privacy", vs)
	}
	return
}

// Video_EditAlbum Edits the title of a video album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.editAlbum
func (vk *VK) Video_EditAlbum(ctx context.Context, req Video_EditAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.editAlbum", ctx, values, &resp)
	return
}

type Video_EditComment_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	CommentId int
	// New comment text.
	Message     *string
	Attachments *[]string
}

func (r Video_EditComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Video_EditComment Edits the text of a comment on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.editComment
func (vk *VK) Video_EditComment(ctx context.Context, req Video_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.editComment", ctx, values, &resp)
	return
}

type Video_Get_Request struct {
	// ID of the user or community that owns the video(s).
	//  Format: int64
	OwnerId *int
	Videos  *[]string
	// ID of the album containing the video(s).
	AlbumId *int
	// Number of videos to return.
	//  Default: 100
	//  Minimum: 0
	//  Maximum: 200
	Count *int
	// Offset needed to return a specific subset of videos.
	//  Minimum: 0
	Offset *int
	// '1' — to return an extended response with additional fields
	Extended *bool
	Fields   *[]string
}

func (r Video_Get_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Videos != nil {
		setStrings(values, "videos", *r.Videos)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Extended != nil {
		setBool(values, "extended", *r.Extended)
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	return
}

// Video_Get Returns detailed information about videos.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.get
func (vk *VK) Video_Get(ctx context.Context, req Video_Get_Request, options ...Option) (resp Video_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.get", ctx, values, &resp)
	return
}

type Video_GetAlbumById_Request struct {
	// identifier of a user or community to add a video to. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Album ID.
	AlbumId int
}

func (r Video_GetAlbumById_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "album_id", r.AlbumId)
	return
}

// Video_GetAlbumById Returns video album info
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.getAlbumById
func (vk *VK) Video_GetAlbumById(ctx context.Context, req Video_GetAlbumById_Request, options ...Option) (resp Video_GetAlbumById_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getAlbumById", ctx, values, &resp)
	return
}

type Video_GetAlbums_Request struct {
	// ID of the user or community that owns the video album(s).
	//  Format: int64
	OwnerId *int
	// Offset needed to return a specific subset of video albums.
	//  Minimum: 0
	Offset *int
	// Number of video albums to return.
	//  Default: 50
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	//  Default: 0
	NeedSystem *bool
}

func (r Video_GetAlbums_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.NeedSystem != nil {
		setBool(values, "need_system", *r.NeedSystem)
	}
	return
}

// Video_GetAlbums Returns a list of video albums owned by a user or community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.getAlbums
func (vk *VK) Video_GetAlbums(ctx context.Context, req Video_GetAlbums_Request, options ...Option) (resp Video_GetAlbums_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getAlbums", ctx, values, &resp)
	return
}

// Video_GetAlbumsExtended Returns a list of video albums owned by a user or community.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.getAlbums
func (vk *VK) Video_GetAlbumsExtended(ctx context.Context, req Video_GetAlbums_Request, options ...Option) (resp Video_GetAlbumsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getAlbums", ctx, values, &resp)
	return
}

type Video_GetAlbumsByVideo_Request struct {
	//  Format: int64
	TargetId *int
	//  Format: int64
	OwnerId int
	//  Format: int32
	//  Minimum: 0
	VideoId int
}

func (r Video_GetAlbumsByVideo_Request) fillIn(values url.Values) (err error) {
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "video_id", r.VideoId)
	return
}

// Video_GetAlbumsByVideo ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.getAlbumsByVideo
func (vk *VK) Video_GetAlbumsByVideo(ctx context.Context, req Video_GetAlbumsByVideo_Request, options ...Option) (resp Video_GetAlbumsByVideo_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getAlbumsByVideo", ctx, values, &resp)
	return
}

// Video_GetAlbumsByVideoExtended ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.getAlbumsByVideo
func (vk *VK) Video_GetAlbumsByVideoExtended(ctx context.Context, req Video_GetAlbumsByVideo_Request, options ...Option) (resp Video_GetAlbumsByVideoExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getAlbumsByVideo", ctx, values, &resp)
	return
}

type Video_GetComments_Sort string

const (
	Video_GetComments_Sort_OldestCommentFirst Video_GetComments_Sort = "asc"
	Video_GetComments_Sort_NewestCommentFirst Video_GetComments_Sort = "desc"
)

type Video_GetComments_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// '1' — to return an additional 'likes' field
	NeedLikes *bool
	//  Minimum: 0
	StartCommentId *int
	// Offset needed to return a specific subset of comments.
	Offset *int
	// Number of comments to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// Sort order: 'asc' — oldest comment first, 'desc' — newest comment first
	Sort   *Video_GetComments_Sort
	Fields *[]string
}

func (r Video_GetComments_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "video_id", r.VideoId)
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.StartCommentId != nil {
		setInt(values, "start_comment_id", *r.StartCommentId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.Fields != nil {
		setStrings(values, "fields", *r.Fields)
	}
	return
}

// Video_GetComments Returns a list of comments on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_VideoCommentsClosed ]
//
// https://dev.vk.com/method/video.getComments
func (vk *VK) Video_GetComments(ctx context.Context, req Video_GetComments_Request, options ...Option) (resp Video_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getComments", ctx, values, &resp)
	return
}

// Video_GetCommentsExtended Returns a list of comments on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_VideoCommentsClosed ]
//
// https://dev.vk.com/method/video.getComments
func (vk *VK) Video_GetCommentsExtended(ctx context.Context, req Video_GetComments_Request, options ...Option) (resp Video_GetCommentsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 11+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.getComments", ctx, values, &resp)
	return
}

type Video_RemoveFromAlbum_Request struct {
	//  Format: int64
	TargetId *int
	AlbumId  *int
	AlbumIds *[]int
	//  Format: int64
	OwnerId int
	//  Format: int32
	//  Minimum: 0
	VideoId int
}

func (r Video_RemoveFromAlbum_Request) fillIn(values url.Values) (err error) {
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.AlbumIds != nil {
		setInts(values, "album_ids", *r.AlbumIds)
	}
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "video_id", r.VideoId)
	return
}

// Video_RemoveFromAlbum ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.removeFromAlbum
func (vk *VK) Video_RemoveFromAlbum(ctx context.Context, req Video_RemoveFromAlbum_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.removeFromAlbum", ctx, values, &resp)
	return
}

type Video_ReorderAlbums_Request struct {
	// ID of the user or community that owns the albums..
	//  Format: int64
	OwnerId *int
	// Album ID.
	//  Minimum: 0
	AlbumId int
	// ID of the album before which the album in question shall be placed.
	//  Minimum: 0
	Before *int
	// ID of the album after which the album in question shall be placed.
	//  Minimum: 0
	After *int
}

func (r Video_ReorderAlbums_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "album_id", r.AlbumId)
	if r.Before != nil {
		setInt(values, "before", *r.Before)
	}
	if r.After != nil {
		setInt(values, "after", *r.After)
	}
	return
}

// Video_ReorderAlbums Reorders the album in the list of user video albums.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo, Error_NotFound ]
//
// https://dev.vk.com/method/video.reorderAlbums
func (vk *VK) Video_ReorderAlbums(ctx context.Context, req Video_ReorderAlbums_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.reorderAlbums", ctx, values, &resp)
	return
}

type Video_ReorderVideos_Request struct {
	// ID of the user or community that owns the album with videos.
	//  Format: int64
	TargetId *int
	// ID of the video album.
	//  Default: -2
	AlbumId *int
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId int
	// ID of the video.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// ID of the user or community that owns the video before which the video in question shall be placed.
	//  Format: int64
	BeforeOwnerId *int
	// ID of the video before which the video in question shall be placed.
	//  Format: int32
	//  Minimum: 0
	BeforeVideoId *int
	// ID of the user or community that owns the video after which the photo in question shall be placed.
	//  Format: int64
	AfterOwnerId *int
	// ID of the video after which the photo in question shall be placed.
	//  Format: int32
	//  Minimum: 0
	AfterVideoId *int
}

func (r Video_ReorderVideos_Request) fillIn(values url.Values) (err error) {
	if r.TargetId != nil {
		setInt(values, "target_id", *r.TargetId)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "video_id", r.VideoId)
	if r.BeforeOwnerId != nil {
		setInt(values, "before_owner_id", *r.BeforeOwnerId)
	}
	if r.BeforeVideoId != nil {
		setInt(values, "before_video_id", *r.BeforeVideoId)
	}
	if r.AfterOwnerId != nil {
		setInt(values, "after_owner_id", *r.AfterOwnerId)
	}
	if r.AfterVideoId != nil {
		setInt(values, "after_video_id", *r.AfterVideoId)
	}
	return
}

// Video_ReorderVideos Reorders the video in the video album.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo ]
//
// https://dev.vk.com/method/video.reorderVideos
func (vk *VK) Video_ReorderVideos(ctx context.Context, req Video_ReorderVideos_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.reorderVideos", ctx, values, &resp)
	return
}

type Video_Report_Reason int

const (
	Video_Report_Reason_Spam             Video_Report_Reason = 0
	Video_Report_Reason_ChildPornography Video_Report_Reason = 1
	Video_Report_Reason_Extremism        Video_Report_Reason = 2
	Video_Report_Reason_Violence         Video_Report_Reason = 3
	Video_Report_Reason_DrugPropaganda   Video_Report_Reason = 4
	Video_Report_Reason_AdultMaterial    Video_Report_Reason = 5
	Video_Report_Reason_InsultAbuse      Video_Report_Reason = 6
)

type Video_Report_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId int
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// Reason for the complaint: '0' - spam, '1' - child pornography, '2' - extremism, '3' - violence, '4' - drug propaganda, '5' - adult material, '6' - insult, abuse
	//  Minimum: 0
	Reason *Video_Report_Reason
	// Comment describing the complaint.
	Comment *string
	// (If the video was found in search results.) Search query string.
	SearchQuery *string
}

func (r Video_Report_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "video_id", r.VideoId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	if r.Comment != nil {
		setString(values, "comment", *r.Comment)
	}
	if r.SearchQuery != nil {
		setString(values, "search_query", *r.SearchQuery)
	}
	return
}

// Video_Report Reports (submits a complaint about) a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.report
func (vk *VK) Video_Report(ctx context.Context, req Video_Report_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.report", ctx, values, &resp)
	return
}

type Video_ReportComment_Reason int

const (
	Video_ReportComment_Reason_Spam             Video_ReportComment_Reason = 0
	Video_ReportComment_Reason_ChildPornography Video_ReportComment_Reason = 1
	Video_ReportComment_Reason_Extremism        Video_ReportComment_Reason = 2
	Video_ReportComment_Reason_Violence         Video_ReportComment_Reason = 3
	Video_ReportComment_Reason_DrugPropaganda   Video_ReportComment_Reason = 4
	Video_ReportComment_Reason_AdultMaterial    Video_ReportComment_Reason = 5
	Video_ReportComment_Reason_InsultAbuse      Video_ReportComment_Reason = 6
)

type Video_ReportComment_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId int
	// ID of the comment being reported.
	//  Minimum: 0
	CommentId int
	// Reason for the complaint: , 0 - spam , 1 - child pornography , 2 - extremism , 3 - violence , 4 - drug propaganda , 5 - adult material , 6 - insult, abuse
	//  Minimum: 0
	Reason *Video_ReportComment_Reason
}

func (r Video_ReportComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Video_ReportComment Reports (submits a complaint about) a comment on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.reportComment
func (vk *VK) Video_ReportComment(ctx context.Context, req Video_ReportComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.reportComment", ctx, values, &resp)
	return
}

type Video_Restore_Request struct {
	// Video ID.
	//  Format: int32
	//  Minimum: 0
	VideoId int
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
}

func (r Video_Restore_Request) fillIn(values url.Values) (err error) {
	setInt(values, "video_id", r.VideoId)
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	return
}

// Video_Restore Restores a previously deleted video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.restore
func (vk *VK) Video_Restore(ctx context.Context, req Video_Restore_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.restore", ctx, values, &resp)
	return
}

type Video_RestoreComment_Request struct {
	// ID of the user or community that owns the video.
	//  Format: int64
	OwnerId *int
	// ID of the deleted comment.
	CommentId int
}

func (r Video_RestoreComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Video_RestoreComment Restores a previously deleted comment on a video.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/video.restoreComment
func (vk *VK) Video_RestoreComment(ctx context.Context, req Video_RestoreComment_Request, options ...Option) (resp Video_RestoreComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.restoreComment", ctx, values, &resp)
	return
}

type Video_Save_Request struct {
	// Name of the video.
	Name *string
	// Description of the video.
	Description *string
	// '1' — to designate the video as private (send it via a private message), the video will not appear on the user's video list and will not be available by ID for other users, '0' — not to designate the video as private
	IsPrivate *bool
	// '1' — to post the saved video on a user's wall, '0' — not to post the saved video on a user's wall
	Wallpost *bool
	// URL for embedding the video from an external website.
	Link *string
	// ID of the community in which the video will be saved. By default, the current user's page.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	// ID of the album to which the saved video will be added.
	//  Minimum: 0
	AlbumId        *int
	PrivacyView    *[]string
	PrivacyComment *[]string
	NoComments     *bool
	// '1' — to repeat the playback of the video, '0' — to play the video once,
	Repeat      *bool
	Compression *bool
}

func (r Video_Save_Request) fillIn(values url.Values) (err error) {
	if r.Name != nil {
		setString(values, "name", *r.Name)
	}
	if r.Description != nil {
		setString(values, "description", *r.Description)
	}
	if r.IsPrivate != nil {
		setBool(values, "is_private", *r.IsPrivate)
	}
	if r.Wallpost != nil {
		setBool(values, "wallpost", *r.Wallpost)
	}
	if r.Link != nil {
		setString(values, "link", *r.Link)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.AlbumId != nil {
		setInt(values, "album_id", *r.AlbumId)
	}
	if r.PrivacyView != nil {
		setStrings(values, "privacy_view", *r.PrivacyView)
	}
	if r.PrivacyComment != nil {
		setStrings(values, "privacy_comment", *r.PrivacyComment)
	}
	if r.NoComments != nil {
		setBool(values, "no_comments", *r.NoComments)
	}
	if r.Repeat != nil {
		setBool(values, "repeat", *r.Repeat)
	}
	if r.Compression != nil {
		setBool(values, "compression", *r.Compression)
	}
	return
}

// Video_Save Returns a server address (required for upload) and video data.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_AccessVideo, Error_WallAddPost, Error_WallAdsPublished, Error_Upload, Error_GroupHostNeed2fa ]
//
// https://dev.vk.com/method/video.save
func (vk *VK) Video_Save(ctx context.Context, req Video_Save_Request, options ...Option) (resp Video_Save_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("video.save", ctx, values, &resp)
	return
}

type Video_Search_Sort int

const (
	Video_Search_Sort_Duration  Video_Search_Sort = 1
	Video_Search_Sort_Relevance Video_Search_Sort = 2
	Video_Search_Sort_DateAdded Video_Search_Sort = 0
)

type Video_Search_Filters string

const (
	Video_Search_Filters_Youtube Video_Search_Filters = "youtube"
	Video_Search_Filters_Vimeo   Video_Search_Filters = "vimeo"
	Video_Search_Filters_Short   Video_Search_Filters = "short"
	Video_Search_Filters_Long    Video_Search_Filters = "long"
)

type Video_Search_Request struct {
	// Search query string (e.g., 'The Beatles').
	Q *string
	// Sort order: '1' — by duration, '2' — by relevance, '0' — by date added
	Sort *Video_Search_Sort
	// If not null, only searches for high-definition videos.
	Hd *int
	// '1' — to disable the Safe Search filter, '0' — to enable the Safe Search filter
	Adult     *bool
	Live      *bool
	Filters   *[]Video_Search_Filters
	SearchOwn *bool
	// Offset needed to return a specific subset of videos.
	//  Minimum: 0
	Offset *int
	//  Minimum: 0
	Longer *int
	//  Minimum: 0
	Shorter *int
	// Number of videos to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 200
	Count *int
}

func (r Video_Search_Request) fillIn(values url.Values) (err error) {
	if r.Q != nil {
		setString(values, "q", *r.Q)
	}
	if r.Sort != nil {
		setInt(values, "sort", int(*r.Sort))
	}
	if r.Hd != nil {
		setInt(values, "hd", *r.Hd)
	}
	if r.Adult != nil {
		setBool(values, "adult", *r.Adult)
	}
	if r.Live != nil {
		setBool(values, "live", *r.Live)
	}
	if r.Filters != nil {
		vs := make([]string, len(*r.Filters))
		for i, v := range *r.Filters {
			vs[i] = string(v)
		}
		setStrings(values, "filters", vs)
	}
	if r.SearchOwn != nil {
		setBool(values, "search_own", *r.SearchOwn)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Longer != nil {
		setInt(values, "longer", *r.Longer)
	}
	if r.Shorter != nil {
		setInt(values, "shorter", *r.Shorter)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Video_Search Returns a list of videos under the set search criterion.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ActionFailed ]
//
// https://dev.vk.com/method/video.search
func (vk *VK) Video_Search(ctx context.Context, req Video_Search_Request, options ...Option) (resp Video_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.search", ctx, values, &resp)
	return
}

// Video_SearchExtended Returns a list of videos under the set search criterion.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_ActionFailed ]
//
// https://dev.vk.com/method/video.search
func (vk *VK) Video_SearchExtended(ctx context.Context, req Video_Search_Request, options ...Option) (resp Video_SearchExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("video.search", ctx, values, &resp)
	return
}

type Wall_CheckCopyrightLink_Request struct {
	Link string
}

func (r Wall_CheckCopyrightLink_Request) fillIn(values url.Values) (err error) {
	setString(values, "link", r.Link)
	return
}

// Wall_CheckCopyrightLink ...
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallCheckLinkCantDetermineSource ]
//
// https://dev.vk.com/method/wall.checkCopyrightLink
func (vk *VK) Wall_CheckCopyrightLink(ctx context.Context, req Wall_CheckCopyrightLink_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 3+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.checkCopyrightLink", ctx, values, &resp)
	return
}

type Wall_CloseComments_Request struct {
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	PostId int
}

func (r Wall_CloseComments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "post_id", r.PostId)
	return
}

// Wall_CloseComments ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.closeComments
func (vk *VK) Wall_CloseComments(ctx context.Context, req Wall_CloseComments_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.closeComments", ctx, values, &resp)
	return
}

type Wall_CreateComment_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID.
	//  Minimum: 0
	PostId int
	// Group ID.
	//  Format: int64
	//  Minimum: 0
	FromGroup *int
	// (Required if 'attachments' is not set.) Text of the comment.
	Message *string
	// ID of comment to reply.
	ReplyToComment *int
	Attachments    *[]string
	// Sticker ID.
	//  Minimum: 0
	StickerId *int
	// Unique identifier to avoid repeated comments.
	Guid *string
}

func (r Wall_CreateComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "post_id", r.PostId)
	if r.FromGroup != nil {
		setInt(values, "from_group", *r.FromGroup)
	}
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.ReplyToComment != nil {
		setInt(values, "reply_to_comment", *r.ReplyToComment)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.StickerId != nil {
		setInt(values, "sticker_id", *r.StickerId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	return
}

// Wall_CreateComment Adds a comment to a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessAddReply, Error_WallReplyOwnerFlood, Error_WallLinksForbidden, Error_WallAccessReplies ]
//
// https://dev.vk.com/method/wall.createComment
func (vk *VK) Wall_CreateComment(ctx context.Context, req Wall_CreateComment_Request, options ...Option) (resp Wall_CreateComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.createComment", ctx, values, &resp)
	return
}

type Wall_Delete_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// ID of the post to be deleted.
	//  Minimum: 0
	PostId *int
}

func (r Wall_Delete_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PostId != nil {
		setInt(values, "post_id", *r.PostId)
	}
	return
}

// Wall_Delete Deletes a post from a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessPost ]
//
// https://dev.vk.com/method/wall.delete
func (vk *VK) Wall_Delete(ctx context.Context, req Wall_Delete_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.delete", ctx, values, &resp)
	return
}

type Wall_DeleteComment_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	//  Minimum: 0
	CommentId int
}

func (r Wall_DeleteComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Wall_DeleteComment Deletes a comment on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessComment ]
//
// https://dev.vk.com/method/wall.deleteComment
func (vk *VK) Wall_DeleteComment(ctx context.Context, req Wall_DeleteComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.deleteComment", ctx, values, &resp)
	return
}

type Wall_Edit_TopicId int

const (
	Wall_Edit_TopicId_EmptyTopic     Wall_Edit_TopicId = 0
	Wall_Edit_TopicId_Art            Wall_Edit_TopicId = 1
	Wall_Edit_TopicId_It             Wall_Edit_TopicId = 7
	Wall_Edit_TopicId_Games          Wall_Edit_TopicId = 12
	Wall_Edit_TopicId_Music          Wall_Edit_TopicId = 16
	Wall_Edit_TopicId_Photo          Wall_Edit_TopicId = 19
	Wall_Edit_TopicId_ScienceAndTech Wall_Edit_TopicId = 21
	Wall_Edit_TopicId_Sport          Wall_Edit_TopicId = 23
	Wall_Edit_TopicId_Travel         Wall_Edit_TopicId = 25
	Wall_Edit_TopicId_TvAndCinema    Wall_Edit_TopicId = 26
	Wall_Edit_TopicId_Humor          Wall_Edit_TopicId = 32
	Wall_Edit_TopicId_Fashion        Wall_Edit_TopicId = 43
)

type Wall_Edit_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	//  Minimum: 0
	PostId      int
	FriendsOnly *bool
	// (Required if 'attachments' is not set.) Text of the post.
	Message     *string
	Attachments *[]string
	Services    *string
	Signed      *bool
	//  Minimum: 0
	PublishDate *int
	Lat         *float64
	Long        *float64
	//  Minimum: 0
	PlaceId           *int
	MarkAsAds         *bool
	CloseComments     *bool
	DonutPaidDuration *int
	//  Minimum: 0
	PosterBkgId         *int
	PosterBkgOwnerId    *int
	PosterBkgAccessHash *string
	Copyright           *string
	// Topic ID. Allowed values can be obtained from newsfeed.getPostTopics method
	//  Minimum: 0
	TopicId *Wall_Edit_TopicId
}

func (r Wall_Edit_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "post_id", r.PostId)
	if r.FriendsOnly != nil {
		setBool(values, "friends_only", *r.FriendsOnly)
	}
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.Services != nil {
		setString(values, "services", *r.Services)
	}
	if r.Signed != nil {
		setBool(values, "signed", *r.Signed)
	}
	if r.PublishDate != nil {
		setInt(values, "publish_date", *r.PublishDate)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.PlaceId != nil {
		setInt(values, "place_id", *r.PlaceId)
	}
	if r.MarkAsAds != nil {
		setBool(values, "mark_as_ads", *r.MarkAsAds)
	}
	if r.CloseComments != nil {
		setBool(values, "close_comments", *r.CloseComments)
	}
	if r.DonutPaidDuration != nil {
		setInt(values, "donut_paid_duration", *r.DonutPaidDuration)
	}
	if r.PosterBkgId != nil {
		setInt(values, "poster_bkg_id", *r.PosterBkgId)
	}
	if r.PosterBkgOwnerId != nil {
		setInt(values, "poster_bkg_owner_id", *r.PosterBkgOwnerId)
	}
	if r.PosterBkgAccessHash != nil {
		setString(values, "poster_bkg_access_hash", *r.PosterBkgAccessHash)
	}
	if r.Copyright != nil {
		setString(values, "copyright", *r.Copyright)
	}
	if r.TopicId != nil {
		setInt(values, "topic_id", int(*r.TopicId))
	}
	return
}

// Wall_Edit Edits a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAdsPostLimitReached, Error_WallDonut ]
//
// https://dev.vk.com/method/wall.edit
func (vk *VK) Wall_Edit(ctx context.Context, req Wall_Edit_Request, options ...Option) (resp Wall_Edit_Response, apiErr ApiError, err error) {
	values := make(url.Values, 21+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.edit", ctx, values, &resp)
	return
}

type Wall_EditAdsStealth_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID. Used for publishing of scheduled and suggested posts.
	//  Minimum: 0
	PostId int
	// (Required if 'attachments' is not set.) Text of the post.
	Message     *string
	Attachments *[]string
	// Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	Signed *bool
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// ID of the location where the user was tagged.
	//  Minimum: 0
	PlaceId *int
	// Link button ID
	LinkButton *string
	// Link title
	LinkTitle *string
	// Link image url
	LinkImage *string
	// Link video ID in format "<owner_id>_<media_id>"
	LinkVideo *string
}

func (r Wall_EditAdsStealth_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "post_id", r.PostId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.Signed != nil {
		setBool(values, "signed", *r.Signed)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.PlaceId != nil {
		setInt(values, "place_id", *r.PlaceId)
	}
	if r.LinkButton != nil {
		setString(values, "link_button", *r.LinkButton)
	}
	if r.LinkTitle != nil {
		setString(values, "link_title", *r.LinkTitle)
	}
	if r.LinkImage != nil {
		setString(values, "link_image", *r.LinkImage)
	}
	if r.LinkVideo != nil {
		setString(values, "link_video", *r.LinkVideo)
	}
	return
}

// Wall_EditAdsStealth Allows to edit hidden post.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAdsPostLimitReached ]
//
// https://dev.vk.com/method/wall.editAdsStealth
func (vk *VK) Wall_EditAdsStealth(ctx context.Context, req Wall_EditAdsStealth_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.editAdsStealth", ctx, values, &resp)
	return
}

type Wall_EditComment_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// New comment text.
	Message     *string
	Attachments *[]string
}

func (r Wall_EditComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	return
}

// Wall_EditComment Edits a comment on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.editComment
func (vk *VK) Wall_EditComment(ctx context.Context, req Wall_EditComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.editComment", ctx, values, &resp)
	return
}

type Wall_Get_Request struct {
	// ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// User or community short address.
	Domain *string
	// Offset needed to return a specific subset of posts.
	//  Minimum: 0
	Offset *int
	// Number of posts to return (maximum 100).
	//  Minimum: 0
	Count  *int
	Filter *Wall_GetFilter
	Fields *[]Base_UserGroupFields
}

func (r Wall_Get_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Domain != nil {
		setString(values, "domain", *r.Domain)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Filter != nil {
		setString(values, "filter", string(*r.Filter))
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Wall_Get Returns a list of posts on a user wall or community wall.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Blocked ]
//
// https://dev.vk.com/method/wall.get
func (vk *VK) Wall_Get(ctx context.Context, req Wall_Get_Request, options ...Option) (resp Wall_Get_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.get", ctx, values, &resp)
	return
}

// Wall_GetExtended Returns a list of posts on a user wall or community wall.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_Blocked ]
//
// https://dev.vk.com/method/wall.get
func (vk *VK) Wall_GetExtended(ctx context.Context, req Wall_Get_Request, options ...Option) (resp Wall_GetExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.get", ctx, values, &resp)
	return
}

type Wall_GetById_Request struct {
	Posts *[]string
	// Sets the number of parent elements to include in the array 'copy_history' that is returned if the post is a repost from another wall.
	//  Default: 2
	CopyHistoryDepth *int
	Fields           *[]Base_UserGroupFields
}

func (r Wall_GetById_Request) fillIn(values url.Values) (err error) {
	if r.Posts != nil {
		setStrings(values, "posts", *r.Posts)
	}
	if r.CopyHistoryDepth != nil {
		setInt(values, "copy_history_depth", *r.CopyHistoryDepth)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Wall_GetById Returns a list of posts from user or community walls by their IDs.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.getById
func (vk *VK) Wall_GetById(ctx context.Context, req Wall_GetById_Request, options ...Option) (resp Wall_GetByIdLegacy_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getById", ctx, values, &resp)
	return
}

// Wall_GetByIdExtended Returns a list of posts from user or community walls by their IDs.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.getById
func (vk *VK) Wall_GetByIdExtended(ctx context.Context, req Wall_GetById_Request, options ...Option) (resp Wall_GetByIdExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getById", ctx, values, &resp)
	return
}

type Wall_GetComment_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	//  Minimum: 0
	CommentId int
	Fields    *[]Base_UserGroupFields
}

func (r Wall_GetComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Wall_GetComment Returns a comment on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessReplies ]
//
// https://dev.vk.com/method/wall.getComment
func (vk *VK) Wall_GetComment(ctx context.Context, req Wall_GetComment_Request, options ...Option) (resp Wall_GetComment_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getComment", ctx, values, &resp)
	return
}

// Wall_GetCommentExtended Returns a comment on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessReplies ]
//
// https://dev.vk.com/method/wall.getComment
func (vk *VK) Wall_GetCommentExtended(ctx context.Context, req Wall_GetComment_Request, options ...Option) (resp Wall_GetCommentExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getComment", ctx, values, &resp)
	return
}

type Wall_GetComments_Sort string

const (
	Wall_GetComments_Sort_Chronological        Wall_GetComments_Sort = "asc"
	Wall_GetComments_Sort_ReverseChronological Wall_GetComments_Sort = "desc"
)

type Wall_GetComments_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID.
	//  Minimum: 0
	PostId *int
	// '1' — to return the 'likes' field, '0' — not to return the 'likes' field (default)
	NeedLikes *bool
	//  Minimum: 0
	StartCommentId *int
	// Offset needed to return a specific subset of comments.
	Offset *int
	// Number of comments to return (maximum 100).
	//  Minimum: 0
	Count *int
	// Sort order: 'asc' — chronological, 'desc' — reverse chronological
	Sort *Wall_GetComments_Sort
	// Number of characters at which to truncate comments when previewed. By default, '90'. Specify '0' if you do not want to truncate comments.
	//  Minimum: 0
	PreviewLength *int
	Fields        *[]Base_UserGroupFields
	// Comment ID.
	//  Minimum: 0
	CommentId *int
	// Count items in threads.
	//  Default: 0
	//  Minimum: 0
	//  Maximum: 10
	ThreadItemsCount *int
}

func (r Wall_GetComments_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PostId != nil {
		setInt(values, "post_id", *r.PostId)
	}
	if r.NeedLikes != nil {
		setBool(values, "need_likes", *r.NeedLikes)
	}
	if r.StartCommentId != nil {
		setInt(values, "start_comment_id", *r.StartCommentId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Sort != nil {
		setString(values, "sort", string(*r.Sort))
	}
	if r.PreviewLength != nil {
		setInt(values, "preview_length", *r.PreviewLength)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.CommentId != nil {
		setInt(values, "comment_id", *r.CommentId)
	}
	if r.ThreadItemsCount != nil {
		setInt(values, "thread_items_count", *r.ThreadItemsCount)
	}
	return
}

// Wall_GetComments Returns a list of comments on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessReplies ]
//
// https://dev.vk.com/method/wall.getComments
func (vk *VK) Wall_GetComments(ctx context.Context, req Wall_GetComments_Request, options ...Option) (resp Wall_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getComments", ctx, values, &resp)
	return
}

// Wall_GetCommentsExtended Returns a list of comments on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessReplies ]
//
// https://dev.vk.com/method/wall.getComments
func (vk *VK) Wall_GetCommentsExtended(ctx context.Context, req Wall_GetComments_Request, options ...Option) (resp Wall_GetCommentsExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getComments", ctx, values, &resp)
	return
}

type Wall_GetReposts_Request struct {
	// User ID or community ID. By default, current user ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID.
	//  Minimum: 0
	PostId *int
	// Offset needed to return a specific subset of reposts.
	//  Minimum: 0
	Offset *int
	// Number of reposts to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 1000
	Count *int
}

func (r Wall_GetReposts_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PostId != nil {
		setInt(values, "post_id", *r.PostId)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Wall_GetReposts Returns information about reposts of a post on user wall or community wall.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.getReposts
func (vk *VK) Wall_GetReposts(ctx context.Context, req Wall_GetReposts_Request, options ...Option) (resp Wall_GetReposts_Response, apiErr ApiError, err error) {
	values := make(url.Values, 6+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.getReposts", ctx, values, &resp)
	return
}

type Wall_OpenComments_Request struct {
	//  Format: int64
	OwnerId int
	//  Minimum: 0
	PostId int
}

func (r Wall_OpenComments_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "post_id", r.PostId)
	return
}

// Wall_OpenComments ...
// May execute with listed access token types:
//    [ user, group ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.openComments
func (vk *VK) Wall_OpenComments(ctx context.Context, req Wall_OpenComments_Request, options ...Option) (resp Base_Bool_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.openComments", ctx, values, &resp)
	return
}

type Wall_Pin_Request struct {
	// ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID.
	//  Minimum: 0
	PostId int
}

func (r Wall_Pin_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "post_id", r.PostId)
	return
}

// Wall_Pin Pins the post on wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.pin
func (vk *VK) Wall_Pin(ctx context.Context, req Wall_Pin_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.pin", ctx, values, &resp)
	return
}

type Wall_Post_TopicId int

const (
	Wall_Post_TopicId_EmptyTopic     Wall_Post_TopicId = 0
	Wall_Post_TopicId_Art            Wall_Post_TopicId = 1
	Wall_Post_TopicId_It             Wall_Post_TopicId = 7
	Wall_Post_TopicId_Games          Wall_Post_TopicId = 12
	Wall_Post_TopicId_Music          Wall_Post_TopicId = 16
	Wall_Post_TopicId_Photo          Wall_Post_TopicId = 19
	Wall_Post_TopicId_ScienceAndTech Wall_Post_TopicId = 21
	Wall_Post_TopicId_Sport          Wall_Post_TopicId = 23
	Wall_Post_TopicId_Travel         Wall_Post_TopicId = 25
	Wall_Post_TopicId_TvAndCinema    Wall_Post_TopicId = 26
	Wall_Post_TopicId_Humor          Wall_Post_TopicId = 32
	Wall_Post_TopicId_Fashion        Wall_Post_TopicId = 43
)

type Wall_Post_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// '1' — post will be available to friends only, '0' — post will be available to all users (default)
	FriendsOnly *bool
	// For a community: '1' — post will be published by the community, '0' — post will be published by the user (default)
	FromGroup *bool
	// (Required if 'attachments' is not set.) Text of the post.
	Message     *string
	Attachments *[]string
	// List of services or websites the update will be exported to, if the user has so requested. Sample values: 'twitter', 'facebook'.
	Services *string
	// Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	Signed *bool
	// Publication date (in Unix time). If used, posting will be delayed until the set time.
	//  Minimum: 0
	PublishDate *int
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// ID of the location where the user was tagged.
	//  Minimum: 0
	PlaceId *int
	// Post ID. Used for publishing of scheduled and suggested posts.
	//  Minimum: 0
	PostId *int
	Guid   *string
	//  Default: false
	MarkAsAds         *bool
	CloseComments     *bool
	DonutPaidDuration *int
	MuteNotifications *bool
	Copyright         *string
	// Topic ID. Allowed values can be obtained from newsfeed.getPostTopics method
	//  Minimum: 0
	TopicId *Wall_Post_TopicId
}

func (r Wall_Post_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.FriendsOnly != nil {
		setBool(values, "friends_only", *r.FriendsOnly)
	}
	if r.FromGroup != nil {
		setBool(values, "from_group", *r.FromGroup)
	}
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.Services != nil {
		setString(values, "services", *r.Services)
	}
	if r.Signed != nil {
		setBool(values, "signed", *r.Signed)
	}
	if r.PublishDate != nil {
		setInt(values, "publish_date", *r.PublishDate)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.PlaceId != nil {
		setInt(values, "place_id", *r.PlaceId)
	}
	if r.PostId != nil {
		setInt(values, "post_id", *r.PostId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	if r.MarkAsAds != nil {
		setBool(values, "mark_as_ads", *r.MarkAsAds)
	}
	if r.CloseComments != nil {
		setBool(values, "close_comments", *r.CloseComments)
	}
	if r.DonutPaidDuration != nil {
		setInt(values, "donut_paid_duration", *r.DonutPaidDuration)
	}
	if r.MuteNotifications != nil {
		setBool(values, "mute_notifications", *r.MuteNotifications)
	}
	if r.Copyright != nil {
		setString(values, "copyright", *r.Copyright)
	}
	if r.TopicId != nil {
		setInt(values, "topic_id", int(*r.TopicId))
	}
	return
}

// Wall_Post Adds a new post on a user wall or community wall. Can also be used to publish suggested or scheduled posts.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAdsPublished, Error_WallAddPost, Error_WallTooManyRecipients, Error_WallLinksForbidden, Error_WallAdsPostLimitReached, Error_WallDonut ]
//
// https://dev.vk.com/method/wall.post
func (vk *VK) Wall_Post(ctx context.Context, req Wall_Post_Request, options ...Option) (resp Wall_Post_Response, apiErr ApiError, err error) {
	values := make(url.Values, 21+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.post", ctx, values, &resp)
	return
}

type Wall_PostAdsStealth_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId int
	// (Required if 'attachments' is not set.) Text of the post.
	Message     *string
	Attachments *[]string
	// Only for posts in communities with 'from_group' set to '1': '1' — post will be signed with the name of the posting user, '0' — post will not be signed (default)
	Signed *bool
	// Geographical latitude of a check-in, in degrees (from -90 to 90).
	Lat *float64
	// Geographical longitude of a check-in, in degrees (from -180 to 180).
	Long *float64
	// ID of the location where the user was tagged.
	//  Minimum: 0
	PlaceId *int
	// Unique identifier to avoid duplication the same post.
	Guid *string
	// Link button ID
	LinkButton *string
	// Link title
	LinkTitle *string
	// Link image url
	LinkImage *string
	// Link video ID in format "<owner_id>_<media_id>"
	LinkVideo *string
}

func (r Wall_PostAdsStealth_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.Attachments != nil {
		setStrings(values, "attachments", *r.Attachments)
	}
	if r.Signed != nil {
		setBool(values, "signed", *r.Signed)
	}
	if r.Lat != nil {
		setFloat(values, "lat", *r.Lat)
	}
	if r.Long != nil {
		setFloat(values, "long", *r.Long)
	}
	if r.PlaceId != nil {
		setInt(values, "place_id", *r.PlaceId)
	}
	if r.Guid != nil {
		setString(values, "guid", *r.Guid)
	}
	if r.LinkButton != nil {
		setString(values, "link_button", *r.LinkButton)
	}
	if r.LinkTitle != nil {
		setString(values, "link_title", *r.LinkTitle)
	}
	if r.LinkImage != nil {
		setString(values, "link_image", *r.LinkImage)
	}
	if r.LinkVideo != nil {
		setString(values, "link_video", *r.LinkVideo)
	}
	return
}

// Wall_PostAdsStealth Allows to create hidden post which will not be shown on the community's wall and can be used for creating an ad with type "Community post".
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAdsPublished, Error_WallAddPost, Error_WallTooManyRecipients, Error_WallLinksForbidden ]
//
// https://dev.vk.com/method/wall.postAdsStealth
func (vk *VK) Wall_PostAdsStealth(ctx context.Context, req Wall_PostAdsStealth_Request, options ...Option) (resp Wall_PostAdsStealth_Response, apiErr ApiError, err error) {
	values := make(url.Values, 14+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.postAdsStealth", ctx, values, &resp)
	return
}

type Wall_ReportComment_Reason int

const (
	Wall_ReportComment_Reason_Spam             Wall_ReportComment_Reason = 0
	Wall_ReportComment_Reason_ChildPornography Wall_ReportComment_Reason = 1
	Wall_ReportComment_Reason_Extremism        Wall_ReportComment_Reason = 2
	Wall_ReportComment_Reason_Violence         Wall_ReportComment_Reason = 3
	Wall_ReportComment_Reason_DrugPropaganda   Wall_ReportComment_Reason = 4
	Wall_ReportComment_Reason_AdultMaterial    Wall_ReportComment_Reason = 5
	Wall_ReportComment_Reason_InsultAbuse      Wall_ReportComment_Reason = 6
)

type Wall_ReportComment_Request struct {
	// ID of the user or community that owns the wall.
	//  Format: int64
	OwnerId int
	// Comment ID.
	//  Minimum: 0
	CommentId int
	// Reason for the complaint: '0' - spam, '1' - child pornography, '2' - extremism, '3' - violence, '4' - drug propaganda, '5' - adult material, '6' - insult, abuse
	//  Minimum: 0
	Reason *Wall_ReportComment_Reason
}

func (r Wall_ReportComment_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "comment_id", r.CommentId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Wall_ReportComment Reports (submits a complaint about) a comment on a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.reportComment
func (vk *VK) Wall_ReportComment(ctx context.Context, req Wall_ReportComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.reportComment", ctx, values, &resp)
	return
}

type Wall_ReportPost_Reason int

const (
	Wall_ReportPost_Reason_Spam             Wall_ReportPost_Reason = 0
	Wall_ReportPost_Reason_ChildPornography Wall_ReportPost_Reason = 1
	Wall_ReportPost_Reason_Extremism        Wall_ReportPost_Reason = 2
	Wall_ReportPost_Reason_Violence         Wall_ReportPost_Reason = 3
	Wall_ReportPost_Reason_DrugPropaganda   Wall_ReportPost_Reason = 4
	Wall_ReportPost_Reason_AdultMaterial    Wall_ReportPost_Reason = 5
	Wall_ReportPost_Reason_InsultAbuse      Wall_ReportPost_Reason = 6
)

type Wall_ReportPost_Request struct {
	// ID of the user or community that owns the wall.
	//  Format: int64
	OwnerId int
	// Post ID.
	//  Minimum: 0
	PostId int
	// Reason for the complaint: '0' - spam, '1' - child pornography, '2' - extremism, '3' - violence, '4' - drug propaganda, '5' - adult material, '6' - insult, abuse
	//  Minimum: 0
	Reason *Wall_ReportPost_Reason
}

func (r Wall_ReportPost_Request) fillIn(values url.Values) (err error) {
	setInt(values, "owner_id", r.OwnerId)
	setInt(values, "post_id", r.PostId)
	if r.Reason != nil {
		setInt(values, "reason", int(*r.Reason))
	}
	return
}

// Wall_ReportPost Reports (submits a complaint about) a post on a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.reportPost
func (vk *VK) Wall_ReportPost(ctx context.Context, req Wall_ReportPost_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 5+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.reportPost", ctx, values, &resp)
	return
}

type Wall_Repost_Request struct {
	// ID of the object to be reposted on the wall. Example: "wall66748_3675"
	Object string
	// Comment to be added along with the reposted object.
	Message *string
	// Target community ID when reposting to a community.
	//  Format: int64
	//  Minimum: 0
	GroupId *int
	//  Default: false
	MarkAsAds         *bool
	MuteNotifications *bool
}

func (r Wall_Repost_Request) fillIn(values url.Values) (err error) {
	setString(values, "object", r.Object)
	if r.Message != nil {
		setString(values, "message", *r.Message)
	}
	if r.GroupId != nil {
		setInt(values, "group_id", *r.GroupId)
	}
	if r.MarkAsAds != nil {
		setBool(values, "mark_as_ads", *r.MarkAsAds)
	}
	if r.MuteNotifications != nil {
		setBool(values, "mute_notifications", *r.MuteNotifications)
	}
	return
}

// Wall_Repost Reposts (copies) an object to a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAdsPublished, Error_WallAddPost, Error_WallAdsPostLimitReached ]
//
// https://dev.vk.com/method/wall.repost
func (vk *VK) Wall_Repost(ctx context.Context, req Wall_Repost_Request, options ...Option) (resp Wall_Repost_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.repost", ctx, values, &resp)
	return
}

type Wall_Restore_Request struct {
	// User ID or community ID from whose wall the post was deleted. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// ID of the post to be restored.
	//  Minimum: 0
	PostId *int
}

func (r Wall_Restore_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.PostId != nil {
		setInt(values, "post_id", *r.PostId)
	}
	return
}

// Wall_Restore Restores a post deleted from a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessPost, Error_WallAddPost ]
//
// https://dev.vk.com/method/wall.restore
func (vk *VK) Wall_Restore(ctx context.Context, req Wall_Restore_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.restore", ctx, values, &resp)
	return
}

type Wall_RestoreComment_Request struct {
	// User ID or community ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Comment ID.
	CommentId int
}

func (r Wall_RestoreComment_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "comment_id", r.CommentId)
	return
}

// Wall_RestoreComment Restores a comment deleted from a user wall or community wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessComment ]
//
// https://dev.vk.com/method/wall.restoreComment
func (vk *VK) Wall_RestoreComment(ctx context.Context, req Wall_RestoreComment_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.restoreComment", ctx, values, &resp)
	return
}

type Wall_Search_Request struct {
	// user or community id. "Remember that for a community 'owner_id' must be negative."
	//  Format: int64
	OwnerId *int
	// user or community screen name.
	Domain *string
	// search query string.
	//  MaxLength: 9000
	Query *string
	// '1' - returns only page owner's posts.
	OwnersOnly *bool
	// count of posts to return.
	//  Default: 20
	//  Minimum: 0
	//  Maximum: 100
	Count *int
	// Offset needed to return a specific subset of posts.
	//  Default: 0
	//  Minimum: 0
	Offset *int
	Fields *[]Base_UserGroupFields
}

func (r Wall_Search_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	if r.Domain != nil {
		setString(values, "domain", *r.Domain)
	}
	if r.Query != nil {
		setString(values, "query", *r.Query)
	}
	if r.OwnersOnly != nil {
		setBool(values, "owners_only", *r.OwnersOnly)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	return
}

// Wall_Search Allows to search posts on user or community walls.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessPost ]
//
// https://dev.vk.com/method/wall.search
func (vk *VK) Wall_Search(ctx context.Context, req Wall_Search_Request, options ...Option) (resp Wall_Search_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "0")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.search", ctx, values, &resp)
	return
}

// Wall_SearchExtended Allows to search posts on user or community walls.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global or with listed codes API errors:
//    [ Error_WallAccessPost ]
//
// https://dev.vk.com/method/wall.search
func (vk *VK) Wall_SearchExtended(ctx context.Context, req Wall_Search_Request, options ...Option) (resp Wall_SearchExtended_Response, apiErr ApiError, err error) {
	values := make(url.Values, 10+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setString(values, "extended", "1")
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.search", ctx, values, &resp)
	return
}

type Wall_Unpin_Request struct {
	// ID of the user or community that owns the wall. By default, current user ID. Use a negative value to designate a community ID.
	//  Format: int64
	OwnerId *int
	// Post ID.
	//  Minimum: 0
	PostId int
}

func (r Wall_Unpin_Request) fillIn(values url.Values) (err error) {
	if r.OwnerId != nil {
		setInt(values, "owner_id", *r.OwnerId)
	}
	setInt(values, "post_id", r.PostId)
	return
}

// Wall_Unpin Unpins the post on wall.
// May execute with listed access token types:
//    [ user ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/wall.unpin
func (vk *VK) Wall_Unpin(ctx context.Context, req Wall_Unpin_Request, options ...Option) (resp Base_Ok_Response, apiErr ApiError, err error) {
	values := make(url.Values, 4+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("wall.unpin", ctx, values, &resp)
	return
}

type Widgets_GetComments_Request struct {
	WidgetApiId *int
	Url         *string
	PageId      *string
	//  Default: date
	Order  *string
	Fields *[]Users_Fields
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 10
	//  Maximum: 200
	Count *int
}

func (r Widgets_GetComments_Request) fillIn(values url.Values) (err error) {
	if r.WidgetApiId != nil {
		setInt(values, "widget_api_id", *r.WidgetApiId)
	}
	if r.Url != nil {
		setString(values, "url", *r.Url)
	}
	if r.PageId != nil {
		setString(values, "page_id", *r.PageId)
	}
	if r.Order != nil {
		setString(values, "order", *r.Order)
	}
	if r.Fields != nil {
		vs := make([]string, len(*r.Fields))
		for i, v := range *r.Fields {
			vs[i] = string(v)
		}
		setStrings(values, "fields", vs)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Widgets_GetComments Gets a list of comments for the page added through the [vk.com/dev/Comments|Comments widget].
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/widgets.getComments
func (vk *VK) Widgets_GetComments(ctx context.Context, req Widgets_GetComments_Request, options ...Option) (resp Widgets_GetComments_Response, apiErr ApiError, err error) {
	values := make(url.Values, 9+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("widgets.getComments", ctx, values, &resp)
	return
}

type Widgets_GetPages_Request struct {
	WidgetApiId *int
	//  Default: friend_likes
	Order *string
	//  Default: week
	Period *string
	//  Default: 0
	//  Minimum: 0
	Offset *int
	//  Default: 10
	//  Minimum: 10
	//  Maximum: 200
	Count *int
}

func (r Widgets_GetPages_Request) fillIn(values url.Values) (err error) {
	if r.WidgetApiId != nil {
		setInt(values, "widget_api_id", *r.WidgetApiId)
	}
	if r.Order != nil {
		setString(values, "order", *r.Order)
	}
	if r.Period != nil {
		setString(values, "period", *r.Period)
	}
	if r.Offset != nil {
		setInt(values, "offset", *r.Offset)
	}
	if r.Count != nil {
		setInt(values, "count", *r.Count)
	}
	return
}

// Widgets_GetPages Gets a list of application/site pages where the [vk.com/dev/Comments|Comments widget] or [vk.com/dev/Like|Like widget] is installed.
// May execute with listed access token types:
//    [ user, service ]
// When executing method, may return one of global API errors.
//
// https://dev.vk.com/method/widgets.getPages
func (vk *VK) Widgets_GetPages(ctx context.Context, req Widgets_GetPages_Request, options ...Option) (resp Widgets_GetPages_Response, apiErr ApiError, err error) {
	values := make(url.Values, 7+len(options))
	if err = req.fillIn(values); err != nil {
		return
	}
	setOptions(values, options)
	apiErr, err = vk.doReq("widgets.getPages", ctx, values, &resp)
	return
}
